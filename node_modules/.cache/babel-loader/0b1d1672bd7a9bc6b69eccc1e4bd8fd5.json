{"ast":null,"code":"'use strict';\n\nvar AsyncQueue = require('./asyncQueue').AsyncQueue;\n\nvar AudioPlayer = require('@twilio/audioplayer');\n\nvar InvalidArgumentError = require('./errors').InvalidArgumentError;\n/**\n * @class\n * @param {string} name - Name of the sound\n * @param {string} url - URL of the sound\n * @param {Sound#ConstructorOptions} options\n * @property {boolean} isPlaying - Whether the Sound is currently playing audio.\n * @property {string} name - Name of the sound\n * @property {string} url - URL of the sound\n * @property {AudioContext} audioContext - The AudioContext to use if available for AudioPlayer.\n */\n\n/**\n* @typedef {Object} Sound#ConstructorOptions\n* @property {number} [maxDuration=0] - The maximum length of time to play the sound\n*   before stopping it.\n* @property {Boolean} [shouldLoop=false] - Whether the sound should be looped.\n*/\n\n\nfunction Sound(name, url, options) {\n  if (!(this instanceof Sound)) {\n    return new Sound(name, url, options);\n  }\n\n  if (!name || !url) {\n    throw new InvalidArgumentError('name and url are required arguments');\n  }\n\n  options = Object.assign({\n    AudioFactory: typeof Audio !== 'undefined' ? Audio : null,\n    maxDuration: 0,\n    shouldLoop: false\n  }, options);\n  options.AudioPlayer = options.audioContext ? AudioPlayer.bind(AudioPlayer, options.audioContext) : options.AudioFactory;\n  Object.defineProperties(this, {\n    _activeEls: {\n      value: new Map()\n    },\n    _Audio: {\n      value: options.AudioPlayer\n    },\n    _isSinkSupported: {\n      value: options.AudioFactory !== null && typeof options.AudioFactory.prototype.setSinkId === 'function'\n    },\n    _maxDuration: {\n      value: options.maxDuration\n    },\n    _maxDurationTimeout: {\n      value: null,\n      writable: true\n    },\n    _operations: {\n      value: new AsyncQueue()\n    },\n    _playPromise: {\n      value: null,\n      writable: true\n    },\n    _shouldLoop: {\n      value: options.shouldLoop\n    },\n    _sinkIds: {\n      value: ['default']\n    },\n    isPlaying: {\n      enumerable: true,\n      get: function get() {\n        return !!this._playPromise;\n      }\n    },\n    name: {\n      enumerable: true,\n      value: name\n    },\n    url: {\n      enumerable: true,\n      value: url\n    }\n  });\n\n  if (this._Audio) {\n    // Play it (muted and should not loop) as soon as possible so that it does not get incorrectly caught by Chrome's\n    // \"gesture requirement for media playback\" feature.\n    // https://plus.google.com/+FrancoisBeaufort/posts/6PiJQqJzGqX\n    this._play(true, false);\n  }\n}\n\nfunction destroyAudioElement(audioElement) {\n  if (audioElement) {\n    audioElement.pause();\n    audioElement.src = '';\n    audioElement.srcObject = null;\n    audioElement.load();\n  }\n}\n/**\n * Plays the audio element that was initialized using the speficied sinkId\n */\n\n\nSound.prototype._playAudioElement = function _playAudioElement(sinkId, isMuted, shouldLoop) {\n  var _this = this;\n\n  var audioElement = this._activeEls.get(sinkId);\n\n  if (!audioElement) {\n    throw new InvalidArgumentError('sinkId: \"' + sinkId + '\" doesn\\'t have an audio element');\n  }\n\n  audioElement.muted = !!isMuted;\n  audioElement.loop = !!shouldLoop;\n  return audioElement.play().then(function () {\n    return audioElement;\n  }).catch(function (reason) {\n    destroyAudioElement(audioElement);\n\n    _this._activeEls.delete(sinkId);\n\n    throw reason;\n  });\n};\n/**\n * Start playing the sound. Will stop the currently playing sound first.\n * If it exists, the audio element that was initialized for the sinkId will be used\n */\n\n\nSound.prototype._play = function _play(forceIsMuted, forceShouldLoop) {\n  if (this.isPlaying) {\n    this._stop();\n  }\n\n  if (this._maxDuration > 0) {\n    this._maxDurationTimeout = setTimeout(this._stop.bind(this), this._maxDuration);\n  }\n\n  forceShouldLoop = typeof forceShouldLoop === 'boolean' ? forceShouldLoop : this._shouldLoop;\n  var self = this;\n  var playPromise = this._playPromise = Promise.all(this._sinkIds.map(function createAudioElement(sinkId) {\n    if (!self._Audio) {\n      return Promise.resolve();\n    }\n\n    var audioElement = self._activeEls.get(sinkId);\n\n    if (audioElement) {\n      return self._playAudioElement(sinkId, forceIsMuted, forceShouldLoop);\n    }\n\n    audioElement = new self._Audio(self.url); // Make sure the browser always retrieves the resource using CORS.\n    // By default when using media tags, origin header is not sent to server\n    // which causes the server to not return CORS headers. When this caches\n    // on the CDN or browser, it causes issues to future requests that needs CORS,\n    // which is true when using AudioContext. Please note that we won't have to do this\n    // once we migrate to CloudFront.\n\n    if (typeof audioElement.setAttribute === 'function') {\n      audioElement.setAttribute('crossorigin', 'anonymous');\n    }\n    /**\n     * (rrowland) Bug in Chrome 53 & 54 prevents us from calling Audio.setSinkId without\n     *   crashing the tab. https://bugs.chromium.org/p/chromium/issues/detail?id=655342\n     */\n\n\n    return new Promise(function (resolve) {\n      audioElement.addEventListener('canplaythrough', resolve);\n    }).then(function () {\n      return (self._isSinkSupported ? audioElement.setSinkId(sinkId) : Promise.resolve()).then(function setSinkIdSuccess() {\n        self._activeEls.set(sinkId, audioElement); // Stop has been called, bail out\n\n\n        if (!self._playPromise) {\n          return Promise.resolve();\n        }\n\n        return self._playAudioElement(sinkId, forceIsMuted, forceShouldLoop);\n      });\n    });\n  }));\n  return playPromise;\n};\n/**\n * Stop playing the sound.\n */\n\n\nSound.prototype._stop = function _stop() {\n  var _this2 = this;\n\n  this._activeEls.forEach(function (audioEl, sinkId) {\n    if (_this2._sinkIds.includes(sinkId)) {\n      audioEl.pause();\n      audioEl.currentTime = 0;\n    } else {\n      // Destroy the ones that are not used anymore\n      destroyAudioElement(audioEl);\n\n      _this2._activeEls.delete(sinkId);\n    }\n  });\n\n  clearTimeout(this._maxDurationTimeout);\n  this._playPromise = null;\n  this._maxDurationTimeout = null;\n};\n/**\n * Update the sinkIds of the audio output devices this sound should play through.\n */\n\n\nSound.prototype.setSinkIds = function setSinkIds(ids) {\n  if (!this._isSinkSupported) {\n    return;\n  }\n\n  ids = ids.forEach ? ids : [ids];\n  [].splice.apply(this._sinkIds, [0, this._sinkIds.length].concat(ids));\n};\n/**\n * Add a stop operation to the queue\n */\n\n\nSound.prototype.stop = function stop() {\n  var _this3 = this;\n\n  this._operations.enqueue(function () {\n    _this3._stop();\n\n    return Promise.resolve();\n  });\n};\n/**\n * Add a play operation to the queue\n */\n\n\nSound.prototype.play = function play() {\n  var _this4 = this;\n\n  return this._operations.enqueue(function () {\n    return _this4._play();\n  });\n};\n\nmodule.exports = Sound;","map":{"version":3,"sources":["/root/twilio-phone-client/node_modules/twilio-client/es5/twilio/sound.js"],"names":["AsyncQueue","require","AudioPlayer","InvalidArgumentError","Sound","name","url","options","Object","assign","AudioFactory","Audio","maxDuration","shouldLoop","audioContext","bind","defineProperties","_activeEls","value","Map","_Audio","_isSinkSupported","prototype","setSinkId","_maxDuration","_maxDurationTimeout","writable","_operations","_playPromise","_shouldLoop","_sinkIds","isPlaying","enumerable","get","_play","destroyAudioElement","audioElement","pause","src","srcObject","load","_playAudioElement","sinkId","isMuted","_this","muted","loop","play","then","catch","reason","delete","forceIsMuted","forceShouldLoop","_stop","setTimeout","self","playPromise","Promise","all","map","createAudioElement","resolve","setAttribute","addEventListener","setSinkIdSuccess","set","_this2","forEach","audioEl","includes","currentTime","clearTimeout","setSinkIds","ids","splice","apply","length","concat","stop","_this3","enqueue","_this4","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar AsyncQueue = require('./asyncQueue').AsyncQueue;\nvar AudioPlayer = require('@twilio/audioplayer');\nvar InvalidArgumentError = require('./errors').InvalidArgumentError;\n\n/**\n * @class\n * @param {string} name - Name of the sound\n * @param {string} url - URL of the sound\n * @param {Sound#ConstructorOptions} options\n * @property {boolean} isPlaying - Whether the Sound is currently playing audio.\n * @property {string} name - Name of the sound\n * @property {string} url - URL of the sound\n * @property {AudioContext} audioContext - The AudioContext to use if available for AudioPlayer.\n */ /**\n    * @typedef {Object} Sound#ConstructorOptions\n    * @property {number} [maxDuration=0] - The maximum length of time to play the sound\n    *   before stopping it.\n    * @property {Boolean} [shouldLoop=false] - Whether the sound should be looped.\n    */\nfunction Sound(name, url, options) {\n  if (!(this instanceof Sound)) {\n    return new Sound(name, url, options);\n  }\n\n  if (!name || !url) {\n    throw new InvalidArgumentError('name and url are required arguments');\n  }\n\n  options = Object.assign({\n    AudioFactory: typeof Audio !== 'undefined' ? Audio : null,\n    maxDuration: 0,\n    shouldLoop: false\n  }, options);\n\n  options.AudioPlayer = options.audioContext ? AudioPlayer.bind(AudioPlayer, options.audioContext) : options.AudioFactory;\n\n  Object.defineProperties(this, {\n    _activeEls: {\n      value: new Map()\n    },\n    _Audio: {\n      value: options.AudioPlayer\n    },\n    _isSinkSupported: {\n      value: options.AudioFactory !== null && typeof options.AudioFactory.prototype.setSinkId === 'function'\n    },\n    _maxDuration: {\n      value: options.maxDuration\n    },\n    _maxDurationTimeout: {\n      value: null,\n      writable: true\n    },\n    _operations: {\n      value: new AsyncQueue()\n    },\n    _playPromise: {\n      value: null,\n      writable: true\n    },\n    _shouldLoop: {\n      value: options.shouldLoop\n    },\n    _sinkIds: {\n      value: ['default']\n    },\n    isPlaying: {\n      enumerable: true,\n      get: function get() {\n        return !!this._playPromise;\n      }\n    },\n    name: {\n      enumerable: true,\n      value: name\n    },\n    url: {\n      enumerable: true,\n      value: url\n    }\n  });\n\n  if (this._Audio) {\n    // Play it (muted and should not loop) as soon as possible so that it does not get incorrectly caught by Chrome's\n    // \"gesture requirement for media playback\" feature.\n    // https://plus.google.com/+FrancoisBeaufort/posts/6PiJQqJzGqX\n    this._play(true, false);\n  }\n}\n\nfunction destroyAudioElement(audioElement) {\n  if (audioElement) {\n    audioElement.pause();\n    audioElement.src = '';\n    audioElement.srcObject = null;\n    audioElement.load();\n  }\n}\n\n/**\n * Plays the audio element that was initialized using the speficied sinkId\n */\nSound.prototype._playAudioElement = function _playAudioElement(sinkId, isMuted, shouldLoop) {\n  var _this = this;\n\n  var audioElement = this._activeEls.get(sinkId);\n\n  if (!audioElement) {\n    throw new InvalidArgumentError('sinkId: \"' + sinkId + '\" doesn\\'t have an audio element');\n  }\n\n  audioElement.muted = !!isMuted;\n  audioElement.loop = !!shouldLoop;\n\n  return audioElement.play().then(function () {\n    return audioElement;\n  }).catch(function (reason) {\n    destroyAudioElement(audioElement);\n    _this._activeEls.delete(sinkId);\n    throw reason;\n  });\n};\n\n/**\n * Start playing the sound. Will stop the currently playing sound first.\n * If it exists, the audio element that was initialized for the sinkId will be used\n */\nSound.prototype._play = function _play(forceIsMuted, forceShouldLoop) {\n  if (this.isPlaying) {\n    this._stop();\n  }\n\n  if (this._maxDuration > 0) {\n    this._maxDurationTimeout = setTimeout(this._stop.bind(this), this._maxDuration);\n  }\n\n  forceShouldLoop = typeof forceShouldLoop === 'boolean' ? forceShouldLoop : this._shouldLoop;\n  var self = this;\n  var playPromise = this._playPromise = Promise.all(this._sinkIds.map(function createAudioElement(sinkId) {\n    if (!self._Audio) {\n      return Promise.resolve();\n    }\n\n    var audioElement = self._activeEls.get(sinkId);\n    if (audioElement) {\n      return self._playAudioElement(sinkId, forceIsMuted, forceShouldLoop);\n    }\n\n    audioElement = new self._Audio(self.url);\n\n    // Make sure the browser always retrieves the resource using CORS.\n    // By default when using media tags, origin header is not sent to server\n    // which causes the server to not return CORS headers. When this caches\n    // on the CDN or browser, it causes issues to future requests that needs CORS,\n    // which is true when using AudioContext. Please note that we won't have to do this\n    // once we migrate to CloudFront.\n    if (typeof audioElement.setAttribute === 'function') {\n      audioElement.setAttribute('crossorigin', 'anonymous');\n    }\n\n    /**\n     * (rrowland) Bug in Chrome 53 & 54 prevents us from calling Audio.setSinkId without\n     *   crashing the tab. https://bugs.chromium.org/p/chromium/issues/detail?id=655342\n     */\n    return new Promise(function (resolve) {\n      audioElement.addEventListener('canplaythrough', resolve);\n    }).then(function () {\n      return (self._isSinkSupported ? audioElement.setSinkId(sinkId) : Promise.resolve()).then(function setSinkIdSuccess() {\n        self._activeEls.set(sinkId, audioElement);\n\n        // Stop has been called, bail out\n        if (!self._playPromise) {\n          return Promise.resolve();\n        }\n        return self._playAudioElement(sinkId, forceIsMuted, forceShouldLoop);\n      });\n    });\n  }));\n\n  return playPromise;\n};\n\n/**\n * Stop playing the sound.\n */\nSound.prototype._stop = function _stop() {\n  var _this2 = this;\n\n  this._activeEls.forEach(function (audioEl, sinkId) {\n    if (_this2._sinkIds.includes(sinkId)) {\n      audioEl.pause();\n      audioEl.currentTime = 0;\n    } else {\n      // Destroy the ones that are not used anymore\n      destroyAudioElement(audioEl);\n      _this2._activeEls.delete(sinkId);\n    }\n  });\n\n  clearTimeout(this._maxDurationTimeout);\n\n  this._playPromise = null;\n  this._maxDurationTimeout = null;\n};\n\n/**\n * Update the sinkIds of the audio output devices this sound should play through.\n */\nSound.prototype.setSinkIds = function setSinkIds(ids) {\n  if (!this._isSinkSupported) {\n    return;\n  }\n\n  ids = ids.forEach ? ids : [ids];\n  [].splice.apply(this._sinkIds, [0, this._sinkIds.length].concat(ids));\n};\n\n/**\n * Add a stop operation to the queue\n */\nSound.prototype.stop = function stop() {\n  var _this3 = this;\n\n  this._operations.enqueue(function () {\n    _this3._stop();\n    return Promise.resolve();\n  });\n};\n\n/**\n * Add a play operation to the queue\n */\nSound.prototype.play = function play() {\n  var _this4 = this;\n\n  return this._operations.enqueue(function () {\n    return _this4._play();\n  });\n};\n\nmodule.exports = Sound;"]},"metadata":{},"sourceType":"script"}