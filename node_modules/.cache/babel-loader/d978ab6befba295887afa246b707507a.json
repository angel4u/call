{"ast":null,"code":"\"use strict\";\n/**\n * @packageDocumentation\n * @module Tools\n * @internalapi\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar WebSocket = require(\"ws\");\n\nvar errors_1 = require(\"./errors\");\n\nvar log_1 = require(\"./log\"); // tslint:disable-next-line\n\n\nvar Backoff = require('backoff');\n\nvar CONNECT_SUCCESS_TIMEOUT = 10000;\nvar CONNECT_TIMEOUT = 5000;\nvar HEARTBEAT_TIMEOUT = 15000;\n/**\n * All possible states of WSTransport.\n */\n\nvar WSTransportState;\n\n(function (WSTransportState) {\n  /**\n   * The WebSocket is not open but is trying to connect.\n   */\n  WSTransportState[\"Connecting\"] = \"connecting\";\n  /**\n   * The WebSocket is not open and is not trying to connect.\n   */\n\n  WSTransportState[\"Closed\"] = \"closed\";\n  /**\n   * The underlying WebSocket is open and active.\n   */\n\n  WSTransportState[\"Open\"] = \"open\";\n})(WSTransportState = exports.WSTransportState || (exports.WSTransportState = {}));\n/**\n * WebSocket Transport\n */\n\n\nvar WSTransport =\n/** @class */\nfunction (_super) {\n  __extends(WSTransport, _super);\n  /**\n   * @constructor\n   * @param uris - List of URI of the endpoints to connect to.\n   * @param [options] - Constructor options.\n   */\n\n\n  function WSTransport(uris, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this) || this;\n    /**\n     * The current state of the WSTransport.\n     */\n\n\n    _this.state = WSTransportState.Closed;\n    /**\n     * An instance of Logger to use.\n     */\n\n    _this._log = log_1.default.getInstance();\n    /**\n     * Whether we should attempt to fallback if we receive an applicable error\n     * when trying to connect to a signaling endpoint.\n     */\n\n    _this._shouldFallback = false;\n    /**\n     * The current uri index that the transport is connected to.\n     */\n\n    _this._uriIndex = 0;\n    /**\n     * Move the uri index to the next index\n     * If the index is at the end, the index goes back to the first one.\n     */\n\n    _this._moveUriIndex = function () {\n      _this._uriIndex++;\n\n      if (_this._uriIndex >= _this._uris.length) {\n        _this._uriIndex = 0;\n      }\n    };\n    /**\n     * Called in response to WebSocket#close event.\n     */\n\n\n    _this._onSocketClose = function (event) {\n      _this._log.info(\"Received websocket close event code: \" + event.code + \". Reason: \" + event.reason); // 1006: Abnormal close. When the server is unreacheable\n      // 1015: TLS Handshake error\n\n\n      if (event.code === 1006 || event.code === 1015) {\n        _this.emit('error', {\n          code: 31005,\n          message: event.reason || 'Websocket connection to Twilio\\'s signaling servers were ' + 'unexpectedly ended. If this is happening consistently, there may ' + 'be an issue resolving the hostname provided. If a region or an ' + 'edge is being specified in Device setup, ensure it is valid.',\n          twilioError: new errors_1.SignalingErrors.ConnectionError()\n        });\n\n        var wasConnected = // Only in Safari and certain Firefox versions, on network interruption, websocket drops right away with 1006\n        // Let's check current state if it's open, meaning we should not fallback\n        // because we're coming from a previously connected session\n        _this.state === WSTransportState.Open || // But on other browsers, websocket doesn't drop\n        // but our heartbeat catches it, setting the internal state to \"Connecting\".\n        // With this, we should check the previous state instead.\n        _this._previousState === WSTransportState.Open; // Only fallback if this is not the first error\n        // and if we were not connected previously\n\n        if (_this._shouldFallback || !wasConnected) {\n          _this._moveUriIndex();\n        }\n\n        _this._shouldFallback = true;\n      }\n\n      _this._closeSocket();\n    };\n    /**\n     * Called in response to WebSocket#error event.\n     */\n\n\n    _this._onSocketError = function (err) {\n      _this._log.info(\"WebSocket received error: \" + err.message);\n\n      _this.emit('error', {\n        code: 31000,\n        message: err.message || 'WSTransport socket error',\n        twilioError: new errors_1.SignalingErrors.ConnectionDisconnected()\n      });\n    };\n    /**\n     * Called in response to WebSocket#message event.\n     */\n\n\n    _this._onSocketMessage = function (message) {\n      // Clear heartbeat timeout on any incoming message, as they\n      // all indicate an active connection.\n      _this._setHeartbeatTimeout(); // Filter and respond to heartbeats\n\n\n      if (_this._socket && message.data === '\\n') {\n        _this._socket.send('\\n');\n\n        return;\n      }\n\n      _this.emit('message', message);\n    };\n    /**\n     * Called in response to WebSocket#open event.\n     */\n\n\n    _this._onSocketOpen = function () {\n      _this._log.info('WebSocket opened successfully.');\n\n      _this._timeOpened = Date.now();\n      _this._shouldFallback = false;\n\n      _this._setState(WSTransportState.Open);\n\n      clearTimeout(_this._connectTimeout);\n\n      _this._setHeartbeatTimeout();\n\n      _this.emit('open');\n    };\n\n    _this._connectTimeoutMs = options.connectTimeoutMs || CONNECT_TIMEOUT;\n    var initialDelay = 100;\n\n    if (uris && uris.length > 1) {\n      // We only want a random initial delay if there are any fallback edges\n      // Initial delay between 1s and 5s both inclusive\n      initialDelay = Math.floor(Math.random() * (5000 - 1000 + 1)) + 1000;\n    }\n\n    var backoffConfig = {\n      factor: 2.0,\n      initialDelay: initialDelay,\n      maxDelay: typeof options.backoffMaxMs === 'number' ? Math.max(options.backoffMaxMs, 3000) : 20000,\n      randomisationFactor: 0.40\n    };\n\n    _this._log.info('Initializing transport backoff using config: ', backoffConfig);\n\n    _this._backoff = Backoff.exponential(backoffConfig);\n    _this._uris = uris;\n    _this._WebSocket = options.WebSocket || WebSocket; // Called when a backoff timer is started.\n\n    _this._backoff.on('backoff', function (_, delay) {\n      if (_this.state === WSTransportState.Closed) {\n        return;\n      }\n\n      _this._log.info(\"Will attempt to reconnect WebSocket in \" + delay + \"ms\");\n    }); // Called when a backoff timer ends. We want to try to reconnect\n    // the WebSocket at this point.\n\n\n    _this._backoff.on('ready', function (attempt) {\n      if (_this.state === WSTransportState.Closed) {\n        return;\n      }\n\n      _this._connect(attempt + 1);\n    });\n\n    return _this;\n  }\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n\n\n  WSTransport.prototype.close = function () {\n    this._log.info('WSTransport.close() called...');\n\n    this._close();\n  };\n  /**\n   * Attempt to open a WebSocket connection.\n   */\n\n\n  WSTransport.prototype.open = function () {\n    this._log.info('WSTransport.open() called...');\n\n    if (this._socket && (this._socket.readyState === WebSocket.CONNECTING || this._socket.readyState === WebSocket.OPEN)) {\n      this._log.info('WebSocket already open.');\n\n      return;\n    }\n\n    this._connect();\n  };\n  /**\n   * Send a message through the WebSocket connection.\n   * @param message - A message to send to the endpoint.\n   * @returns Whether the message was sent.\n   */\n\n\n  WSTransport.prototype.send = function (message) {\n    // We can't send the message if the WebSocket isn't open\n    if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n      return false;\n    }\n\n    try {\n      this._socket.send(message);\n    } catch (e) {\n      // Some unknown error occurred. Reset the socket to get a fresh session.\n      this._log.info('Error while sending message:', e.message);\n\n      this._closeSocket();\n\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n\n\n  WSTransport.prototype._close = function () {\n    this._setState(WSTransportState.Closed);\n\n    this._closeSocket();\n  };\n  /**\n   * Close the WebSocket and remove all event listeners.\n   */\n\n\n  WSTransport.prototype._closeSocket = function () {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._heartbeatTimeout);\n\n    this._log.info('Closing and cleaning up WebSocket...');\n\n    if (!this._socket) {\n      this._log.info('No WebSocket to clean up.');\n\n      return;\n    }\n\n    this._socket.removeEventListener('close', this._onSocketClose);\n\n    this._socket.removeEventListener('error', this._onSocketError);\n\n    this._socket.removeEventListener('message', this._onSocketMessage);\n\n    this._socket.removeEventListener('open', this._onSocketOpen);\n\n    if (this._socket.readyState === WebSocket.CONNECTING || this._socket.readyState === WebSocket.OPEN) {\n      this._socket.close();\n    } // Reset backoff counter if connection was open for long enough to be considered successful\n\n\n    if (this._timeOpened && Date.now() - this._timeOpened > CONNECT_SUCCESS_TIMEOUT) {\n      this._backoff.reset();\n    }\n\n    this._backoff.backoff();\n\n    delete this._socket;\n    this.emit('close');\n  };\n  /**\n   * Attempt to connect to the endpoint via WebSocket.\n   * @param [retryCount] - Retry number, if this is a retry. Undefined if\n   *   first attempt, 1+ if a retry.\n   */\n\n\n  WSTransport.prototype._connect = function (retryCount) {\n    var _this = this;\n\n    if (retryCount) {\n      this._log.info(\"Attempting to reconnect (retry #\" + retryCount + \")...\");\n    } else {\n      this._log.info('Attempting to connect...');\n    }\n\n    this._closeSocket();\n\n    this._setState(WSTransportState.Connecting);\n\n    var socket = null;\n\n    try {\n      socket = new this._WebSocket(this._uris[this._uriIndex]);\n    } catch (e) {\n      this._log.info('Could not connect to endpoint:', e.message);\n\n      this._close();\n\n      this.emit('error', {\n        code: 31000,\n        message: e.message || \"Could not connect to \" + this._uris[this._uriIndex],\n        twilioError: new errors_1.SignalingErrors.ConnectionDisconnected()\n      });\n      return;\n    }\n\n    delete this._timeOpened;\n    this._connectTimeout = setTimeout(function () {\n      _this._log.info('WebSocket connection attempt timed out.');\n\n      _this._moveUriIndex();\n\n      _this._closeSocket();\n    }, this._connectTimeoutMs);\n    socket.addEventListener('close', this._onSocketClose);\n    socket.addEventListener('error', this._onSocketError);\n    socket.addEventListener('message', this._onSocketMessage);\n    socket.addEventListener('open', this._onSocketOpen);\n    this._socket = socket;\n  };\n  /**\n   * Set a timeout to reconnect after HEARTBEAT_TIMEOUT milliseconds\n   *   have passed without receiving a message over the WebSocket.\n   */\n\n\n  WSTransport.prototype._setHeartbeatTimeout = function () {\n    var _this = this;\n\n    clearTimeout(this._heartbeatTimeout);\n    this._heartbeatTimeout = setTimeout(function () {\n      _this._log.info(\"No messages received in \" + HEARTBEAT_TIMEOUT / 1000 + \" seconds. Reconnecting...\");\n\n      _this._shouldFallback = true;\n\n      _this._closeSocket();\n    }, HEARTBEAT_TIMEOUT);\n  };\n  /**\n   * Set the current and previous state\n   */\n\n\n  WSTransport.prototype._setState = function (state) {\n    this._previousState = this.state;\n    this.state = state;\n  };\n\n  Object.defineProperty(WSTransport.prototype, \"uri\", {\n    /**\n     * The uri the transport is currently connected to\n     */\n    get: function get() {\n      return this._uris[this._uriIndex];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return WSTransport;\n}(events_1.EventEmitter);\n\nexports.default = WSTransport;","map":{"version":3,"sources":["../../lib/twilio/wstransport.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @packageDocumentation\n * @module Tools\n * @internalapi\n */\n\nimport { EventEmitter } from 'events';\nimport * as WebSocket from 'ws';\nimport { SignalingErrors } from './errors';\nimport Log from './log';\n\n// tslint:disable-next-line\nconst Backoff = require('backoff');\n\nconst CONNECT_SUCCESS_TIMEOUT = 10000;\nconst CONNECT_TIMEOUT = 5000;\nconst HEARTBEAT_TIMEOUT = 15000;\n\nexport interface IMessageEvent {\n  data: string;\n  target: WebSocket;\n  type: string;\n}\n\n/**\n * All possible states of WSTransport.\n */\nexport enum WSTransportState {\n  /**\n   * The WebSocket is not open but is trying to connect.\n   */\n  Connecting = 'connecting',\n\n  /**\n   * The WebSocket is not open and is not trying to connect.\n   */\n  Closed = 'closed',\n\n  /**\n   * The underlying WebSocket is open and active.\n   */\n  Open = 'open',\n}\n\n/**\n * Options to be passed to the WSTransport constructor.\n */\nexport interface IWSTransportConstructorOptions {\n  /**\n   * Maximum time to wait before attempting to reconnect the signaling websocket.\n   * Default is 20000ms. Minimum is 3000ms.\n   */\n  backoffMaxMs?: number;\n\n  /**\n   * Time in milliseconds before websocket times out when attempting to connect\n   */\n  connectTimeoutMs?: number;\n\n  /**\n   * A WebSocket factory to use instead of WebSocket.\n   */\n  WebSocket?: any;\n}\n\n/**\n * WebSocket Transport\n */\nexport default class WSTransport extends EventEmitter {\n  /**\n   * The current state of the WSTransport.\n   */\n  state: WSTransportState = WSTransportState.Closed;\n\n  /**\n   * The backoff instance used to schedule reconnection attempts.\n   */\n  private readonly _backoff: any;\n\n  /**\n   * The current connection timeout. If it times out, we've failed to connect\n   * and should try again.\n   *\n   * We use any here because NodeJS returns a Timer and browser returns a number\n   * and one can't be cast to the other, despite their working interoperably.\n   */\n  private _connectTimeout?: any;\n\n  /**\n   * Time in milliseconds before websocket times out when attempting to connect\n   */\n  private _connectTimeoutMs?: number;\n\n  /**\n   * The current connection timeout. If it times out, we've failed to connect\n   * and should try again.\n   *\n   * We use any here because NodeJS returns a Timer and browser returns a number\n   * and one can't be cast to the other, despite their working interoperably.\n   */\n  private _heartbeatTimeout?: any;\n\n  /**\n   * An instance of Logger to use.\n   */\n  private _log: Log = Log.getInstance();\n\n  /**\n   * Previous state of the connection\n   */\n  private _previousState: WSTransportState;\n\n  /**\n   * Whether we should attempt to fallback if we receive an applicable error\n   * when trying to connect to a signaling endpoint.\n   */\n  private _shouldFallback: boolean = false;\n\n  /**\n   * The currently connecting or open WebSocket.\n   */\n  private _socket?: WebSocket;\n\n  /**\n   * The time the active connection was opened.\n   */\n  private _timeOpened?: number;\n\n  /**\n   * The current uri index that the transport is connected to.\n   */\n  private _uriIndex: number = 0;\n\n  /**\n   * List of URI of the endpoints to connect to.\n   */\n  private readonly _uris: string[];\n\n  /**\n   * The constructor to use for WebSocket\n   */\n  private readonly _WebSocket: typeof WebSocket;\n\n  /**\n   * @constructor\n   * @param uris - List of URI of the endpoints to connect to.\n   * @param [options] - Constructor options.\n   */\n  constructor(uris: string[], options: IWSTransportConstructorOptions = { }) {\n    super();\n\n    this._connectTimeoutMs = options.connectTimeoutMs || CONNECT_TIMEOUT;\n\n    let initialDelay = 100;\n    if (uris && uris.length > 1) {\n      // We only want a random initial delay if there are any fallback edges\n      // Initial delay between 1s and 5s both inclusive\n      initialDelay = Math.floor(Math.random() * (5000 - 1000 + 1)) + 1000;\n    }\n\n    const backoffConfig = {\n      factor: 2.0,\n      initialDelay,\n      maxDelay: typeof options.backoffMaxMs === 'number'\n        ? Math.max(options.backoffMaxMs, 3000)\n        : 20000,\n      randomisationFactor: 0.40,\n    };\n\n    this._log.info('Initializing transport backoff using config: ', backoffConfig);\n    this._backoff = Backoff.exponential(backoffConfig);\n\n    this._uris = uris;\n    this._WebSocket = options.WebSocket || WebSocket;\n\n    // Called when a backoff timer is started.\n    this._backoff.on('backoff', (_: any, delay: number) => {\n      if (this.state === WSTransportState.Closed) { return; }\n      this._log.info(`Will attempt to reconnect WebSocket in ${delay}ms`);\n    });\n\n    // Called when a backoff timer ends. We want to try to reconnect\n    // the WebSocket at this point.\n    this._backoff.on('ready', (attempt: number) => {\n      if (this.state === WSTransportState.Closed) { return; }\n      this._connect(attempt + 1);\n    });\n  }\n\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  close(): void {\n    this._log.info('WSTransport.close() called...');\n    this._close();\n  }\n\n  /**\n   * Attempt to open a WebSocket connection.\n   */\n  open(): void {\n    this._log.info('WSTransport.open() called...');\n\n    if (this._socket &&\n        (this._socket.readyState === WebSocket.CONNECTING ||\n        this._socket.readyState === WebSocket.OPEN)) {\n      this._log.info('WebSocket already open.');\n      return;\n    }\n\n    this._connect();\n  }\n\n  /**\n   * Send a message through the WebSocket connection.\n   * @param message - A message to send to the endpoint.\n   * @returns Whether the message was sent.\n   */\n  send(message: string): boolean {\n    // We can't send the message if the WebSocket isn't open\n    if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n      return false;\n    }\n\n    try {\n      this._socket.send(message);\n    } catch (e) {\n      // Some unknown error occurred. Reset the socket to get a fresh session.\n      this._log.info('Error while sending message:', e.message);\n      this._closeSocket();\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  private _close(): void {\n    this._setState(WSTransportState.Closed);\n    this._closeSocket();\n  }\n\n  /**\n   * Close the WebSocket and remove all event listeners.\n   */\n  private _closeSocket(): void {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._heartbeatTimeout);\n\n    this._log.info('Closing and cleaning up WebSocket...');\n\n    if (!this._socket) {\n      this._log.info('No WebSocket to clean up.');\n      return;\n    }\n\n    this._socket.removeEventListener('close', this._onSocketClose as any);\n    this._socket.removeEventListener('error', this._onSocketError as any);\n    this._socket.removeEventListener('message', this._onSocketMessage as any);\n    this._socket.removeEventListener('open', this._onSocketOpen as any);\n\n    if (this._socket.readyState === WebSocket.CONNECTING ||\n        this._socket.readyState === WebSocket.OPEN) {\n      this._socket.close();\n    }\n\n    // Reset backoff counter if connection was open for long enough to be considered successful\n    if (this._timeOpened && Date.now() - this._timeOpened > CONNECT_SUCCESS_TIMEOUT) {\n      this._backoff.reset();\n    }\n\n    this._backoff.backoff();\n    delete this._socket;\n\n    this.emit('close');\n  }\n\n  /**\n   * Attempt to connect to the endpoint via WebSocket.\n   * @param [retryCount] - Retry number, if this is a retry. Undefined if\n   *   first attempt, 1+ if a retry.\n   */\n  private _connect(retryCount?: number): void {\n    if (retryCount) {\n      this._log.info(`Attempting to reconnect (retry #${retryCount})...`);\n    } else {\n      this._log.info('Attempting to connect...');\n    }\n\n    this._closeSocket();\n\n    this._setState(WSTransportState.Connecting);\n    let socket = null;\n    try {\n      socket = new this._WebSocket(this._uris[this._uriIndex]);\n    } catch (e) {\n      this._log.info('Could not connect to endpoint:', e.message);\n      this._close();\n      this.emit('error', {\n        code: 31000,\n        message: e.message || `Could not connect to ${this._uris[this._uriIndex]}`,\n        twilioError: new SignalingErrors.ConnectionDisconnected(),\n      });\n      return;\n    }\n\n    delete this._timeOpened;\n    this._connectTimeout = setTimeout(() => {\n      this._log.info('WebSocket connection attempt timed out.');\n      this._moveUriIndex();\n      this._closeSocket();\n    }, this._connectTimeoutMs);\n\n    socket.addEventListener('close', this._onSocketClose as any);\n    socket.addEventListener('error', this._onSocketError as any);\n    socket.addEventListener('message', this._onSocketMessage as any);\n    socket.addEventListener('open', this._onSocketOpen as any);\n    this._socket = socket;\n  }\n\n  /**\n   * Move the uri index to the next index\n   * If the index is at the end, the index goes back to the first one.\n   */\n  private _moveUriIndex = (): void => {\n    this._uriIndex++;\n    if (this._uriIndex >= this._uris.length) {\n      this._uriIndex = 0;\n    }\n  }\n\n  /**\n   * Called in response to WebSocket#close event.\n   */\n  private _onSocketClose = (event: CloseEvent): void => {\n    this._log.info(`Received websocket close event code: ${event.code}. Reason: ${event.reason}`);\n    // 1006: Abnormal close. When the server is unreacheable\n    // 1015: TLS Handshake error\n    if (event.code === 1006 || event.code === 1015) {\n      this.emit('error', {\n        code: 31005,\n        message: event.reason ||\n          'Websocket connection to Twilio\\'s signaling servers were ' +\n          'unexpectedly ended. If this is happening consistently, there may ' +\n          'be an issue resolving the hostname provided. If a region or an ' +\n          'edge is being specified in Device setup, ensure it is valid.',\n        twilioError: new SignalingErrors.ConnectionError(),\n      });\n\n      const wasConnected = (\n        // Only in Safari and certain Firefox versions, on network interruption, websocket drops right away with 1006\n        // Let's check current state if it's open, meaning we should not fallback\n        // because we're coming from a previously connected session\n        this.state === WSTransportState.Open ||\n\n        // But on other browsers, websocket doesn't drop\n        // but our heartbeat catches it, setting the internal state to \"Connecting\".\n        // With this, we should check the previous state instead.\n        this._previousState === WSTransportState.Open\n      );\n\n      // Only fallback if this is not the first error\n      // and if we were not connected previously\n      if (this._shouldFallback || !wasConnected) {\n        this._moveUriIndex();\n      }\n\n      this._shouldFallback = true;\n    }\n    this._closeSocket();\n  }\n\n  /**\n   * Called in response to WebSocket#error event.\n   */\n  private _onSocketError = (err: Error): void => {\n    this._log.info(`WebSocket received error: ${err.message}`);\n    this.emit('error', {\n      code: 31000,\n      message: err.message || 'WSTransport socket error',\n      twilioError: new SignalingErrors.ConnectionDisconnected(),\n    });\n  }\n\n  /**\n   * Called in response to WebSocket#message event.\n   */\n  private _onSocketMessage = (message: IMessageEvent): void => {\n    // Clear heartbeat timeout on any incoming message, as they\n    // all indicate an active connection.\n    this._setHeartbeatTimeout();\n\n    // Filter and respond to heartbeats\n    if (this._socket && message.data === '\\n') {\n      this._socket.send('\\n');\n      return;\n    }\n\n    this.emit('message', message);\n  }\n\n  /**\n   * Called in response to WebSocket#open event.\n   */\n  private _onSocketOpen = (): void => {\n    this._log.info('WebSocket opened successfully.');\n    this._timeOpened = Date.now();\n    this._shouldFallback = false;\n    this._setState(WSTransportState.Open);\n    clearTimeout(this._connectTimeout);\n\n    this._setHeartbeatTimeout();\n    this.emit('open');\n  }\n\n  /**\n   * Set a timeout to reconnect after HEARTBEAT_TIMEOUT milliseconds\n   *   have passed without receiving a message over the WebSocket.\n   */\n  private _setHeartbeatTimeout(): void {\n    clearTimeout(this._heartbeatTimeout);\n    this._heartbeatTimeout = setTimeout(() => {\n      this._log.info(`No messages received in ${HEARTBEAT_TIMEOUT / 1000} seconds. Reconnecting...`);\n      this._shouldFallback = true;\n      this._closeSocket();\n    }, HEARTBEAT_TIMEOUT);\n  }\n\n  /**\n   * Set the current and previous state\n   */\n  private _setState(state: WSTransportState): void {\n    this._previousState = this.state;\n    this.state = state;\n  }\n\n  /**\n   * The uri the transport is currently connected to\n   */\n  get uri(): string {\n    return this._uris[this._uriIndex];\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}