{"ast":null,"code":"var _jsxFileName = \"/root/twilio-phone-client/src/components/PhoneClient.js\";\nimport React, { Component } from 'react';\nimport styled from 'styled-components';\nimport update from 'immutability-helper';\nimport jwt_decode from 'jwt-decode';\nimport { formParams, stringify } from '../lib/common';\nimport ChannelSwitcher from './ChannelSwitcher';\nimport ChannelContent from './ChannelContent';\nimport AuthForm from './AuthForm';\nimport { ModalMessage } from './CommonComponents';\n\nconst TwilioChat = require('twilio-chat');\n\nconst TwilioVoice = require('twilio-client');\n\nconst maxAuthAttempts = 3;\nexport default class Canvas extends Component {\n  constructor(props) {\n    super(props);\n\n    this._fetchToken = () => {\n      return new Promise((resolve, reject) => {\n        const accessTokenGenerator = (process.env.REACT_APP_RUNTIME_DOMAIN ? process.env.REACT_APP_RUNTIME_DOMAIN : '') + '/getAccessToken';\n        const body = formParams({\n          secret: this.state.secret // handle escaping\n\n        });\n        fetch(accessTokenGenerator, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n          },\n          body\n        }).then(async response => {\n          if (response.status === 200) {\n            return response.text();\n          } else if (response.status === 401) {\n            const errText = await response.text();\n            this.setState({\n              authorized: false,\n              authError: this.state.authCounter === 0 ? '' : errText,\n              authCounter: this.state.authCounter + 1\n            });\n            console.error('Authorization failed - check if SECRET env variable is set correctly:', errText);\n            reject(errText);\n          }\n        }).then(token => {\n          if (token !== undefined) {\n            this.setState({\n              authorized: true,\n              authError: '',\n              authCounter: 0\n            });\n            resolve(token);\n          }\n        }).catch(err => {\n          console.error('Error fetching Access Token:', err);\n          this.setState({\n            displayError: `Error fetching Access Token (${stringify(err)})`\n          });\n          reject(err);\n        });\n      });\n    };\n\n    this.setSecret = secret => {\n      this.setState({\n        secret\n      }, () => this.initClients());\n    };\n\n    this.setCallDisplay = callDisplay => {\n      this.setState({\n        callDisplay\n      });\n    };\n\n    this.setCallConnection = callConnection => {\n      this.callConnection = callConnection;\n    };\n\n    this.getCallConnection = () => {\n      return this.callConnection;\n    };\n\n    this.setCallStartTime = callStartTime => {\n      this.callStartTime = callStartTime;\n    };\n\n    this.getCallStartTime = () => {\n      return this.callStartTime;\n    };\n\n    this.setCallNextKeyReset = callNextKeyReset => {\n      this.callNextKeyReset = callNextKeyReset;\n    };\n\n    this.getCallNextKeyReset = () => {\n      return this.callNextKeyReset;\n    };\n\n    this.setCallTypingPN = callTypingPN => {\n      this.callTypingPN = callTypingPN;\n    };\n\n    this.getCallTypingPN = () => {\n      return this.callTypingPN;\n    };\n\n    this.setUnreadsCache = (contact, unread) => {\n      this.setState({\n        msgUnreadsCache: update(this.state.msgUnreadsCache, {\n          [contact]: {\n            $set: unread\n          }\n        })\n      });\n    };\n\n    this.setUnreadMsgs = (channel, contact) => {\n      // if there's no consumed messages, all messages are unread\n      // (getUnconsumedMessagesCount doesn't really work in this case\n      // so we need to handle this edge case manually)\n      if (channel.lastConsumedMessageIndex === null) {\n        channel.getMessagesCount().then(cnt => {\n          this.setState({\n            msgUnreadsCache: update(this.state.msgUnreadsCache, {\n              [contact]: {\n                $set: cnt\n              }\n            })\n          });\n        });\n      } else {\n        channel.getUnconsumedMessagesCount().then(cnt => {\n          this.setState({\n            msgUnreadsCache: update(this.state.msgUnreadsCache, {\n              [contact]: {\n                $set: cnt\n              }\n            })\n          });\n        });\n      }\n    };\n\n    this.setMsgCachePage = (contact, messages, paginator) => {\n      this.setState({\n        msgCache: update(this.state.msgCache, {\n          [contact]: {\n            $set: messages\n          }\n        }),\n        pgtrCache: update(this.state.msgPgtrCache, {\n          [contact]: {\n            $set: paginator\n          }\n        })\n      });\n    };\n\n    this.addMsgCachePage = (contact, messages, paginator) => {\n      this.setState({\n        msgCache: update(this.state.msgCache, {\n          [contact]: {\n            $unshift: messages\n          }\n        }),\n        pgtrCache: update(this.state.msgPgtrCache, {\n          [contact]: {\n            $set: paginator\n          }\n        })\n      });\n    };\n\n    this.addMsgCacheMsg = (contact, msg) => {\n      if (this.state.msgCache[contact] === undefined) {\n        this.setState({\n          msgCache: update(this.state.msgCache, {\n            $merge: {\n              [contact]: []\n            }\n          })\n        });\n      }\n\n      this.setState({\n        msgCache: update(this.state.msgCache, {\n          [contact]: {\n            $push: [msg]\n          }\n        })\n      });\n    };\n\n    this.getToken = () => {\n      return new Promise((resolve, reject) => {\n        if (this.state.token) {\n          const decoded_token = jwt_decode(this.state.token);\n          const s_now = Math.floor(Date.now() / 1000);\n          const s_expire = decoded_token.exp;\n          console.log(`Token is expiring in ${s_expire - s_now}s`);\n\n          if (s_expire - s_now < 300) {\n            // token is about to expire, let's renew it\n            this._fetchToken().then(token => {\n              this.setState({\n                token\n              });\n              this.getTokenActive = false;\n              resolve(token);\n            });\n          } else {\n            this.getTokenActive = false;\n            resolve(this.state.token);\n          }\n        } else {\n          this._fetchToken().then(token => {\n            this.setState({\n              token\n            });\n            this.getTokenActive = false;\n            resolve(token);\n          });\n        }\n      });\n    };\n\n    this.initClients = () => {\n      if (this.state.chatClient === null && this.state.voiceClient === null) {\n        this.getToken().then(token => {\n          // initialize Voice client\n          const voiceClient = new TwilioVoice.Device();\n          voiceClient.setup(token, {\n            // Set Opus as our preferred codec. Opus generally performs better,\n            // requiring less bandwidth and providing better audio quality in\n            // restrained network conditions. Opus will be default in 2.0.\n            codecPreferences: ['opus', 'pcmu'],\n            // Use fake DTMF tones client-side. Real tones are still sent to the\n            // other end of the call, but the client-side DTMF tones are fake.\n            // This prevents the local mic capturing the DTMF tone a second time\n            // and sending the tone twice. This will be default in 2.0.\n            fakeLocalDTMF: true,\n            // Use `enableRingingState` to enable the device to emit the `ringing`\n            // state. The TwiML backend also needs to have the attribute\n            // `answerOnBridge` also set to true in the `Dial` verb. This option\n            // changes the behavior of the SDK to consider a call `ringing`\n            // starting from the connection to the TwiML backend to when the\n            // recipient of the `Dial` verb answers.\n            enableRingingState: true\n          });\n          voiceClient.on('ready', device => {\n            console.log('voiceClient is ready');\n          });\n          voiceClient.on('error', error => {\n            console.log('Twilio.Device Error: ', error); // JWT Token Expired\n\n            if (error.code === 31205) {\n              this.getToken().then(() => {\n                this.state.chatClient.updateToken(this.state.token);\n                this.state.voiceClient.updateToken(this.state.token);\n                console.log('Token updated after expiration (from voiceClient)');\n              });\n            }\n          });\n          voiceClient.on('incoming', connection => {\n            console.log('PC: INCOMING event fired from ' + connection.parameters.From);\n            this.setState({\n              incomingCall: connection\n            });\n            this.setCallConnection(connection);\n            connection.on('reject', connection => {\n              // when incoming call gets rejected from CallCanvas, update state\n              this.setState({\n                incomingCall: null\n              });\n            });\n          });\n          voiceClient.on('cancel', connection => {\n            console.log('PC: CANCEL event fired');\n            this.setState({\n              incomingCall: null\n            });\n          });\n          voiceClient.on('connect', connection => {\n            console.log('PC: CONNECT event fired');\n            this.setState({\n              incomingCall: null\n            }); // cleanup the incoming call state and let the component handle this natively\n          });\n          voiceClient.on('disconnect', connection => {\n            console.log('PC: DISCONNECT event fired');\n            this.setCallDisplay('');\n            this.setCallStartTime(null);\n            this.setCallTypingPN(true);\n            this.setCallNextKeyReset(false);\n          });\n          console.log('voiceClient is initialized');\n          this.setState({\n            voiceClient\n          }); // initialize Chat client\n\n          TwilioChat.Client.create(token).then(chatClient => {\n            this.setState({\n              chatClient\n            });\n            chatClient.getSubscribedChannels().then(paginator => {\n              let chatChannelList = {};\n\n              for (let i = 0; i < paginator.items.length; i++) {\n                const channel = paginator.items[i];\n                chatChannelList[channel.uniqueName] = channel;\n              }\n\n              console.log('chatClient is initialized');\n              this.setState({\n                chatChannelList\n              });\n            });\n            chatClient.on('channelRemoved', channel => {\n              if (this.state.chatChannelList !== null) {\n                this.setState({\n                  chatChannelList: update(this.state.chatChannelList, {\n                    $unset: [channel.uniqueName]\n                  }),\n                  msgUnreadsCache: update(this.state.msgUnreadsCache, {\n                    $unset: [channel.uniqueName]\n                  }),\n                  msgCache: update(this.state.msgCache, {\n                    $unset: [channel.uniqueName]\n                  }),\n                  msgPgtrCache: update(this.state.msgPgtrCache, {\n                    $unset: [channel.uniqueName]\n                  })\n                });\n              }\n            });\n            chatClient.on('channelAdded', channel => {\n              if (this.state.chatChannelList !== null) {\n                this.setState({\n                  chatChannelList: update(this.state.chatChannelList, {\n                    $merge: {\n                      [channel.uniqueName]: channel\n                    }\n                  }),\n                  msgCache: update(this.state.msgCache, {\n                    [channel.uniqueName]: {\n                      $set: undefined\n                    }\n                  })\n                });\n              }\n            });\n            chatClient.on('channelUpdated', ({\n              channel,\n              updateReasons\n            }) => {\n              if (this.state.chatChannelList !== null && updateReasons.includes('lastMessage')) {\n                this.setState({\n                  chatChannelList: update(this.state.chatChannelList, {\n                    [channel.uniqueName]: {\n                      $set: channel\n                    }\n                  })\n                });\n              }\n            });\n            chatClient.on('tokenAboutToExpire', () => {\n              this.getToken().then(() => {\n                this.state.chatClient.updateToken(this.state.token);\n                this.state.voiceClient.updateToken(this.state.token);\n                console.log('Token updated before expiration');\n              });\n            });\n            chatClient.on('tokenExpired', () => {\n              this.getToken().then(() => {\n                this.state.chatClient.updateToken(this.state.token);\n                this.state.voiceClient.updateToken(this.state.token);\n                console.log('Token updated after expiration (from chatClient)');\n              });\n            });\n          });\n        });\n      }\n    };\n\n    this.setChannel = selectedChannel => {\n      this.setState({\n        selectedChannel\n      });\n    };\n\n    this.state = {\n      selectedChannel: 'sms',\n      chatClient: null,\n      chatChannelList: null,\n      voiceClient: null,\n      incomingCall: null,\n      token: null,\n      authorized: false,\n      authCounter: 0,\n      authError: '',\n      secret: localStorage.getItem('secret'),\n      displayError: null,\n      msgUnreadsCache: {},\n      msgCache: {},\n      msgPgtrCache: {},\n      callDisplay: '' // phone number after formatting\n\n    };\n    this.callConnection = null;\n    this.callStartTime = null;\n    this.callNextKeyReset = false; // is user typing a phone number (i.e. no call in progress) or\n    // are they using DTMF during a call?\n\n    this.callTypingPN = true;\n  }\n  /**\n   * Fetch token from the <tt>getAccessToken</tt> function.\n   * @returns {string}\n   */\n\n\n  componentDidMount() {\n    this.initClients();\n  }\n\n  componentDidUpdate() {}\n\n  componentWillUnmount() {\n    if (this.state.chatClient) {\n      this.state.chatClient.removeAllListeners('channelAdded');\n      this.state.chatClient.removeAllListeners('channelUpdated');\n    }\n\n    if (this.state.voiceClient) {\n      this.state.voiceClient.removeAllListeners('ready');\n      this.state.voiceClient.removeAllListeners('error');\n    }\n  }\n\n  render() {\n    if (this.state.displayError) {\n      return /*#__PURE__*/React.createElement(ViewPort, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 436,\n          columnNumber: 9\n        }\n      }, /*#__PURE__*/React.createElement(ModalMessage, {\n        msg: 'Error occurred: ' + this.state.displayError,\n        img: \"alert\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 437,\n          columnNumber: 11\n        }\n      }));\n    } else if ( // if the initial login attempt hasn't bee made yet, don't show anything\n    // (to avoid UI redraws with login form flashing brieafly before client load)\n    this.state.authorized === false && this.state.authCounter === 0) {\n      return /*#__PURE__*/React.createElement(ViewPort, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 449,\n          columnNumber: 14\n        }\n      });\n    } else if ( // if the initial login attempt failed, show a login form\n    this.state.authorized === false && this.state.authCounter <= maxAuthAttempts) {\n      return /*#__PURE__*/React.createElement(ViewPort, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 456,\n          columnNumber: 9\n        }\n      }, /*#__PURE__*/React.createElement(AuthForm, {\n        setSecret: this.setSecret,\n        errMsg: this.state.authError,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 457,\n          columnNumber: 11\n        }\n      }));\n    } else if ( // if the max number of attempts was exceeded, show error to discourage\n    // repeated logins\n    this.state.authorized === false && this.state.authCounter > maxAuthAttempts) {\n      return /*#__PURE__*/React.createElement(ViewPort, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 467,\n          columnNumber: 9\n        }\n      }, /*#__PURE__*/React.createElement(ModalMessage, {\n        msg: \"Authorization failed\",\n        img: \"auth_fail\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 468,\n          columnNumber: 11\n        }\n      }));\n    } else {\n      return /*#__PURE__*/React.createElement(React.StrictMode, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 473,\n          columnNumber: 9\n        }\n      }, /*#__PURE__*/React.createElement(ViewPort, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 474,\n          columnNumber: 11\n        }\n      }, /*#__PURE__*/React.createElement(ChannelSwitcher, {\n        setChannel: this.setChannel,\n        selectedChannel: this.state.selectedChannel,\n        incomingCall: this.state.incomingCall,\n        msgUnreadsCache: this.state.msgUnreadsCache,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 475,\n          columnNumber: 13\n        }\n      }), /*#__PURE__*/React.createElement(ChannelContent, {\n        msgUnreadsCache: this.state.msgUnreadsCache,\n        setUnreadsCache: this.setUnreadsCache,\n        setUnreadMsgs: this.setUnreadMsgs,\n        msgCache: this.state.msgCache,\n        msgPgtrCache: this.state.msgPgtrCache,\n        addMsgCachePage: this.addMsgCachePage,\n        setMsgCachePage: this.setMsgCachePage,\n        addMsgCacheMsg: this.addMsgCacheMsg,\n        setCallDisplay: this.setCallDisplay,\n        callDisplay: this.state.callDisplay,\n        setCallConnection: this.setCallConnection,\n        getCallConnection: this.getCallConnection,\n        setCallStartTime: this.setCallStartTime,\n        getCallStartTime: this.getCallStartTime,\n        setCallNextKeyReset: this.setCallNextKeyReset,\n        getCallNextKeyReset: this.getCallNextKeyReset,\n        setCallTypingPN: this.setCallTypingPN,\n        getCallTypingPN: this.getCallTypingPN,\n        selectedChannel: this.state.selectedChannel,\n        secret: this.state.secret,\n        client: this.state.selectedChannel === 'sms' ? this.state.chatClient : this.state.voiceClient,\n        channelList: this.state.selectedChannel === 'sms' ? this.state.chatChannelList : null,\n        incomingCall: this.state.incomingCall,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 481,\n          columnNumber: 13\n        }\n      })));\n    }\n  }\n\n}\nconst ViewPort = styled.div`\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  align-items: stretch;\n  max-width: 400px;\n`;","map":{"version":3,"sources":["/root/twilio-phone-client/src/components/PhoneClient.js"],"names":["React","Component","styled","update","jwt_decode","formParams","stringify","ChannelSwitcher","ChannelContent","AuthForm","ModalMessage","TwilioChat","require","TwilioVoice","maxAuthAttempts","Canvas","constructor","props","_fetchToken","Promise","resolve","reject","accessTokenGenerator","process","env","REACT_APP_RUNTIME_DOMAIN","body","secret","state","fetch","method","headers","then","response","status","text","errText","setState","authorized","authError","authCounter","console","error","token","undefined","catch","err","displayError","setSecret","initClients","setCallDisplay","callDisplay","setCallConnection","callConnection","getCallConnection","setCallStartTime","callStartTime","getCallStartTime","setCallNextKeyReset","callNextKeyReset","getCallNextKeyReset","setCallTypingPN","callTypingPN","getCallTypingPN","setUnreadsCache","contact","unread","msgUnreadsCache","$set","setUnreadMsgs","channel","lastConsumedMessageIndex","getMessagesCount","cnt","getUnconsumedMessagesCount","setMsgCachePage","messages","paginator","msgCache","pgtrCache","msgPgtrCache","addMsgCachePage","$unshift","addMsgCacheMsg","msg","$merge","$push","getToken","decoded_token","s_now","Math","floor","Date","now","s_expire","exp","log","getTokenActive","chatClient","voiceClient","Device","setup","codecPreferences","fakeLocalDTMF","enableRingingState","on","device","code","updateToken","connection","parameters","From","incomingCall","Client","create","getSubscribedChannels","chatChannelList","i","items","length","uniqueName","$unset","updateReasons","includes","setChannel","selectedChannel","localStorage","getItem","componentDidMount","componentDidUpdate","componentWillUnmount","removeAllListeners","render","ViewPort","div"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport styled from 'styled-components';\nimport update from 'immutability-helper';\nimport jwt_decode from 'jwt-decode';\nimport { formParams, stringify } from '../lib/common';\n\nimport ChannelSwitcher from './ChannelSwitcher';\nimport ChannelContent from './ChannelContent';\nimport AuthForm from './AuthForm';\nimport { ModalMessage } from './CommonComponents';\n\nconst TwilioChat = require('twilio-chat');\nconst TwilioVoice = require('twilio-client');\n\nconst maxAuthAttempts = 3;\n\nexport default class Canvas extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      selectedChannel: 'sms',\n      chatClient: null,\n      chatChannelList: null,\n      voiceClient: null,\n      incomingCall: null,\n      token: null,\n      authorized: false,\n      authCounter: 0,\n      authError: '',\n      secret: localStorage.getItem('secret'),\n      displayError: null,\n      msgUnreadsCache: {},\n      msgCache: {},\n      msgPgtrCache: {},\n      callDisplay: '' // phone number after formatting\n    };\n\n    this.callConnection = null;\n    this.callStartTime = null;\n    this.callNextKeyReset = false;\n    // is user typing a phone number (i.e. no call in progress) or\n    // are they using DTMF during a call?\n    this.callTypingPN = true;\n  }\n\n  /**\n   * Fetch token from the <tt>getAccessToken</tt> function.\n   * @returns {string}\n   */\n  _fetchToken = () => {\n    return new Promise((resolve, reject) => {\n      const accessTokenGenerator =\n        (process.env.REACT_APP_RUNTIME_DOMAIN\n          ? process.env.REACT_APP_RUNTIME_DOMAIN\n          : '') + '/getAccessToken';\n\n      const body = formParams({\n        secret: this.state.secret // handle escaping\n      });\n      fetch(accessTokenGenerator, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body\n      })\n        .then(async (response) => {\n          if (response.status === 200) {\n            return response.text();\n          } else if (response.status === 401) {\n            const errText = await response.text();\n            this.setState({\n              authorized: false,\n              authError: this.state.authCounter === 0 ? '' : errText,\n              authCounter: this.state.authCounter + 1\n            });\n            console.error(\n              'Authorization failed - check if SECRET env variable is set correctly:',\n              errText\n            );\n            reject(errText);\n          }\n        })\n        .then((token) => {\n          if (token !== undefined) {\n            this.setState({\n              authorized: true,\n              authError: '',\n              authCounter: 0\n            });\n            resolve(token);\n          }\n        })\n        .catch((err) => {\n          console.error('Error fetching Access Token:', err);\n          this.setState({\n            displayError: `Error fetching Access Token (${stringify(err)})`\n          });\n          reject(err);\n        });\n    });\n  };\n\n  /**\n   * Setters & getters for properties that don't have to be part of the state,\n   * but need to be accessed by child components and need their values to\n   * survive unmounting of the consuming component\n   */\n\n  setSecret = (secret) => {\n    this.setState({ secret }, () => this.initClients());\n  };\n  setCallDisplay = (callDisplay) => {\n    this.setState({ callDisplay });\n  };\n  setCallConnection = (callConnection) => {\n    this.callConnection = callConnection;\n  };\n  getCallConnection = () => {\n    return this.callConnection;\n  };\n  setCallStartTime = (callStartTime) => {\n    this.callStartTime = callStartTime;\n  };\n  getCallStartTime = () => {\n    return this.callStartTime;\n  };\n  setCallNextKeyReset = (callNextKeyReset) => {\n    this.callNextKeyReset = callNextKeyReset;\n  };\n  getCallNextKeyReset = () => {\n    return this.callNextKeyReset;\n  };\n  setCallTypingPN = (callTypingPN) => {\n    this.callTypingPN = callTypingPN;\n  };\n  getCallTypingPN = () => {\n    return this.callTypingPN;\n  };\n\n  /**\n   * msgUnreadsCache setter\n   * @param {*} contact - the contact for which the cache should be updated\n   * @param {*} unread - new value\n   */\n  setUnreadsCache = (contact, unread) => {\n    this.setState({\n      msgUnreadsCache: update(this.state.msgUnreadsCache, {\n        [contact]: { $set: unread }\n      })\n    });\n  };\n\n  setUnreadMsgs = (channel, contact) => {\n    // if there's no consumed messages, all messages are unread\n    // (getUnconsumedMessagesCount doesn't really work in this case\n    // so we need to handle this edge case manually)\n    if (channel.lastConsumedMessageIndex === null) {\n      channel.getMessagesCount().then((cnt) => {\n        this.setState({\n          msgUnreadsCache: update(this.state.msgUnreadsCache, {\n            [contact]: { $set: cnt }\n          })\n        });\n      });\n    } else {\n      channel.getUnconsumedMessagesCount().then((cnt) => {\n        this.setState({\n          msgUnreadsCache: update(this.state.msgUnreadsCache, {\n            [contact]: { $set: cnt }\n          })\n        });\n      });\n    }\n  };\n\n  /**\n   * Initialize message cache for given contact\n   * @param {*} contact\n   * @param {*} messages\n   * @param {*} paginator\n   */\n  setMsgCachePage = (contact, messages, paginator) => {\n    this.setState({\n      msgCache: update(this.state.msgCache, {\n        [contact]: { $set: messages }\n      }),\n      pgtrCache: update(this.state.msgPgtrCache, {\n        [contact]: { $set: paginator }\n      })\n    });\n  };\n\n  /**\n   * Add new page worth of messages using paginator\n   * @param {*} contact\n   * @param {*} messages\n   * @param {*} paginator\n   */\n  addMsgCachePage = (contact, messages, paginator) => {\n    this.setState({\n      msgCache: update(this.state.msgCache, {\n        [contact]: { $unshift: messages }\n      }),\n      pgtrCache: update(this.state.msgPgtrCache, {\n        [contact]: { $set: paginator }\n      })\n    });\n  };\n\n  /**\n   * Add one new message to the cache\n   * @param {*} contact\n   * @param {*} msg\n   */\n  addMsgCacheMsg = (contact, msg) => {\n    if (this.state.msgCache[contact] === undefined) {\n      this.setState({\n        msgCache: update(this.state.msgCache, {\n          $merge: { [contact]: [] }\n        })\n      });\n    }\n    this.setState({\n      msgCache: update(this.state.msgCache, { [contact]: { $push: [msg] } })\n    });\n  };\n\n  /**\n   * Wrapper around _fetchToken that stores the token in component's state\n   * @returns {string}\n   */\n  getToken = () => {\n    return new Promise((resolve, reject) => {\n      if (this.state.token) {\n        const decoded_token = jwt_decode(this.state.token);\n        const s_now = Math.floor(Date.now() / 1000);\n        const s_expire = decoded_token.exp;\n        console.log(`Token is expiring in ${s_expire - s_now}s`);\n        if (s_expire - s_now < 300) {\n          // token is about to expire, let's renew it\n          this._fetchToken().then((token) => {\n            this.setState({ token });\n            this.getTokenActive = false;\n            resolve(token);\n          });\n        } else {\n          this.getTokenActive = false;\n          resolve(this.state.token);\n        }\n      } else {\n        this._fetchToken().then((token) => {\n          this.setState({ token });\n          this.getTokenActive = false;\n          resolve(token);\n        });\n      }\n    });\n  };\n\n  /**\n   * Initialize the Voice and Chat clients\n   * @returns {string}\n   */\n  initClients = () => {\n    if (this.state.chatClient === null && this.state.voiceClient === null) {\n      this.getToken().then((token) => {\n        // initialize Voice client\n        const voiceClient = new TwilioVoice.Device();\n        voiceClient.setup(token, {\n          // Set Opus as our preferred codec. Opus generally performs better,\n          // requiring less bandwidth and providing better audio quality in\n          // restrained network conditions. Opus will be default in 2.0.\n          codecPreferences: ['opus', 'pcmu'],\n          // Use fake DTMF tones client-side. Real tones are still sent to the\n          // other end of the call, but the client-side DTMF tones are fake.\n          // This prevents the local mic capturing the DTMF tone a second time\n          // and sending the tone twice. This will be default in 2.0.\n          fakeLocalDTMF: true,\n          // Use `enableRingingState` to enable the device to emit the `ringing`\n          // state. The TwiML backend also needs to have the attribute\n          // `answerOnBridge` also set to true in the `Dial` verb. This option\n          // changes the behavior of the SDK to consider a call `ringing`\n          // starting from the connection to the TwiML backend to when the\n          // recipient of the `Dial` verb answers.\n          enableRingingState: true\n        });\n        voiceClient.on('ready', (device) => {\n          console.log('voiceClient is ready');\n        });\n        voiceClient.on('error', (error) => {\n          console.log('Twilio.Device Error: ', error);\n          // JWT Token Expired\n          if (error.code === 31205) {\n            this.getToken().then(() => {\n              this.state.chatClient.updateToken(this.state.token);\n              this.state.voiceClient.updateToken(this.state.token);\n              console.log('Token updated after expiration (from voiceClient)');\n            });\n          }\n        });\n        voiceClient.on('incoming', (connection) => {\n          console.log(\n            'PC: INCOMING event fired from ' + connection.parameters.From\n          );\n          this.setState({ incomingCall: connection });\n          this.setCallConnection(connection);\n          connection.on('reject', (connection) => {\n            // when incoming call gets rejected from CallCanvas, update state\n            this.setState({\n              incomingCall: null\n            });\n          });\n        });\n        voiceClient.on('cancel', (connection) => {\n          console.log('PC: CANCEL event fired');\n          this.setState({\n            incomingCall: null\n          });\n        });\n\n        voiceClient.on('connect', (connection) => {\n          console.log('PC: CONNECT event fired');\n          this.setState({ incomingCall: null }); // cleanup the incoming call state and let the component handle this natively\n        });\n\n        voiceClient.on('disconnect', (connection) => {\n          console.log('PC: DISCONNECT event fired');\n          this.setCallDisplay('');\n          this.setCallStartTime(null);\n          this.setCallTypingPN(true);\n          this.setCallNextKeyReset(false);\n        });\n\n        console.log('voiceClient is initialized');\n        this.setState({ voiceClient });\n\n        // initialize Chat client\n        TwilioChat.Client.create(token).then((chatClient) => {\n          this.setState({ chatClient });\n          chatClient.getSubscribedChannels().then((paginator) => {\n            let chatChannelList = {};\n            for (let i = 0; i < paginator.items.length; i++) {\n              const channel = paginator.items[i];\n              chatChannelList[channel.uniqueName] = channel;\n            }\n            console.log('chatClient is initialized');\n\n            this.setState({ chatChannelList });\n          });\n          chatClient.on('channelRemoved', (channel) => {\n            if (this.state.chatChannelList !== null) {\n              this.setState({\n                chatChannelList: update(this.state.chatChannelList, {\n                  $unset: [channel.uniqueName]\n                }),\n                msgUnreadsCache: update(this.state.msgUnreadsCache, {\n                  $unset: [channel.uniqueName]\n                }),\n                msgCache: update(this.state.msgCache, {\n                  $unset: [channel.uniqueName]\n                }),\n                msgPgtrCache: update(this.state.msgPgtrCache, {\n                  $unset: [channel.uniqueName]\n                })\n              });\n            }\n          });\n          chatClient.on('channelAdded', (channel) => {\n            if (this.state.chatChannelList !== null) {\n              this.setState({\n                chatChannelList: update(this.state.chatChannelList, {\n                  $merge: { [channel.uniqueName]: channel }\n                }),\n                msgCache: update(this.state.msgCache, {\n                  [channel.uniqueName]: { $set: undefined }\n                })\n              });\n            }\n          });\n          chatClient.on('channelUpdated', ({ channel, updateReasons }) => {\n            if (\n              this.state.chatChannelList !== null &&\n              updateReasons.includes('lastMessage')\n            ) {\n              this.setState({\n                chatChannelList: update(this.state.chatChannelList, {\n                  [channel.uniqueName]: { $set: channel }\n                })\n              });\n            }\n          });\n          chatClient.on('tokenAboutToExpire', () => {\n            this.getToken().then(() => {\n              this.state.chatClient.updateToken(this.state.token);\n              this.state.voiceClient.updateToken(this.state.token);\n              console.log('Token updated before expiration');\n            });\n          });\n          chatClient.on('tokenExpired', () => {\n            this.getToken().then(() => {\n              this.state.chatClient.updateToken(this.state.token);\n              this.state.voiceClient.updateToken(this.state.token);\n              console.log('Token updated after expiration (from chatClient)');\n            });\n          });\n        });\n      });\n    }\n  };\n\n  setChannel = (selectedChannel) => {\n    this.setState({ selectedChannel });\n  };\n\n  componentDidMount() {\n    this.initClients();\n  }\n\n  componentDidUpdate() {}\n\n  componentWillUnmount() {\n    if (this.state.chatClient) {\n      this.state.chatClient.removeAllListeners('channelAdded');\n      this.state.chatClient.removeAllListeners('channelUpdated');\n    }\n    if (this.state.voiceClient) {\n      this.state.voiceClient.removeAllListeners('ready');\n      this.state.voiceClient.removeAllListeners('error');\n    }\n  }\n\n  render() {\n    if (this.state.displayError) {\n      return (\n        <ViewPort>\n          <ModalMessage\n            msg={'Error occurred: ' + this.state.displayError}\n            img=\"alert\"\n          />\n        </ViewPort>\n      );\n    } else if (\n      // if the initial login attempt hasn't bee made yet, don't show anything\n      // (to avoid UI redraws with login form flashing brieafly before client load)\n      this.state.authorized === false &&\n      this.state.authCounter === 0\n    ) {\n      return <ViewPort></ViewPort>;\n    } else if (\n      // if the initial login attempt failed, show a login form\n      this.state.authorized === false &&\n      this.state.authCounter <= maxAuthAttempts\n    ) {\n      return (\n        <ViewPort>\n          <AuthForm setSecret={this.setSecret} errMsg={this.state.authError} />\n        </ViewPort>\n      );\n    } else if (\n      // if the max number of attempts was exceeded, show error to discourage\n      // repeated logins\n      this.state.authorized === false &&\n      this.state.authCounter > maxAuthAttempts\n    ) {\n      return (\n        <ViewPort>\n          <ModalMessage msg=\"Authorization failed\" img=\"auth_fail\" />\n        </ViewPort>\n      );\n    } else {\n      return (\n        <React.StrictMode>\n          <ViewPort>\n            <ChannelSwitcher\n              setChannel={this.setChannel}\n              selectedChannel={this.state.selectedChannel}\n              incomingCall={this.state.incomingCall}\n              msgUnreadsCache={this.state.msgUnreadsCache}\n            />\n            <ChannelContent\n              msgUnreadsCache={this.state.msgUnreadsCache}\n              setUnreadsCache={this.setUnreadsCache}\n              setUnreadMsgs={this.setUnreadMsgs}\n              msgCache={this.state.msgCache}\n              msgPgtrCache={this.state.msgPgtrCache}\n              addMsgCachePage={this.addMsgCachePage}\n              setMsgCachePage={this.setMsgCachePage}\n              addMsgCacheMsg={this.addMsgCacheMsg}\n              setCallDisplay={this.setCallDisplay}\n              callDisplay={this.state.callDisplay}\n              setCallConnection={this.setCallConnection}\n              getCallConnection={this.getCallConnection}\n              setCallStartTime={this.setCallStartTime}\n              getCallStartTime={this.getCallStartTime}\n              setCallNextKeyReset={this.setCallNextKeyReset}\n              getCallNextKeyReset={this.getCallNextKeyReset}\n              setCallTypingPN={this.setCallTypingPN}\n              getCallTypingPN={this.getCallTypingPN}\n              selectedChannel={this.state.selectedChannel}\n              secret={this.state.secret}\n              client={\n                this.state.selectedChannel === 'sms'\n                  ? this.state.chatClient\n                  : this.state.voiceClient\n              }\n              channelList={\n                this.state.selectedChannel === 'sms'\n                  ? this.state.chatChannelList\n                  : null\n              }\n              incomingCall={this.state.incomingCall}\n            />\n          </ViewPort>\n        </React.StrictMode>\n      );\n    }\n  }\n}\n\nconst ViewPort = styled.div`\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  align-items: stretch;\n  max-width: 400px;\n`;\n"]},"metadata":{},"sourceType":"module"}