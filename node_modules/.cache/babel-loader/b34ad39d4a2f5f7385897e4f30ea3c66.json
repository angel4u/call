{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Twilsock = exports.TwilsockClient = exports.TelemetryEvents = void 0;\n\nconst events_1 = require(\"events\");\n\nconst logger_1 = require(\"./logger\");\n\nconst configuration_1 = require(\"./configuration\");\n\nconst twilsock_1 = require(\"./twilsock\");\n\nconst packetinterface_1 = require(\"./packetinterface\");\n\nconst websocketchannel_1 = require(\"./websocketchannel\");\n\nconst registrations_1 = require(\"./services/registrations\");\n\nconst upstream_1 = require(\"./services/upstream\");\n\nconst deferred_1 = require(\"./deferred\");\n\nconst twilsockerror_1 = require(\"./error/twilsockerror\");\n\nconst offlinestorage_1 = require(\"./offlinestorage\");\n\nconst tokenStorage_1 = require(\"./tokenStorage\");\n\nconst telemetrytracker_1 = require(\"./services/telemetrytracker\");\n\nclass TelemetryEvents {}\n\nexports.TelemetryEvents = TelemetryEvents;\nTelemetryEvents.TWILSOCK_CONNECT = 'twilsock.sdk.connect'; // establish WebSocket connection (with WebSocket handshake finished)\n\nTelemetryEvents.TWILSOCK_INIT = 'twilsock.sdk.init'; // send \"init\" message and receive reply\n\n/**\n * @alias Twilsock\n * @classdesc Client library for the Twilsock service\n * It allows to recevie service-generated updates as well as bi-directional transport\n * @fires Twilsock#message\n * @fires Twilsock#connected\n * @fires Twilsock#disconnected\n * @fires Twilsock#tokenAboutToExpire\n * @fires Twilsock#stateChanged\n * @fires Twilsock#connectionError\n */\n\nclass TwilsockClient extends events_1.EventEmitter {\n  /**\n   * @param {string} token Twilio access token\n   * @param {string} productId Product identifier. Should be the same as a grant name in token\n   */\n  constructor(token, productId, options = {}) {\n    super();\n    this.offlineStorageDeferred = new deferred_1.Deferred();\n    options.continuationToken = options.continuationToken ? options.continuationToken : tokenStorage_1.TokenStorage.getStoredToken(productId);\n    let config = this.config = new configuration_1.Configuration(token, productId, options);\n    logger_1.log.setLevel(config.logLevel);\n    let websocket = new websocketchannel_1.WebSocketChannel(config.url);\n    let transport = options.transport ? options.transport : new packetinterface_1.PacketInterface(websocket, config);\n    this.channel = options.channel ? options.channel : new twilsock_1.TwilsockImpl(websocket, transport, config);\n    this.registrations = options.registrations ? options.registrations : new registrations_1.Registrations(transport);\n    this.upstream = new upstream_1.Upstream(transport, this.channel, config); // Send telemetry only when connected and initialised\n\n    this.telemetryTracker = new telemetrytracker_1.TelemetryTracker(config, transport);\n    this.channel.on('initialized', () => this.telemetryTracker.canSendTelemetry = true);\n    websocket.on('disconnected', () => this.telemetryTracker.canSendTelemetry = false);\n    this.registrations.on('registered', id => this.emit('registered', id));\n    this.channel.on('message', (type, message) => setTimeout(() => this.emit('message', type, message), 0));\n    this.channel.on('stateChanged', state => setTimeout(() => this.emit('stateChanged', state), 0));\n    this.channel.on('connectionError', connectionError => setTimeout(() => this.emit('connectionError', connectionError), 0));\n    this.channel.on('tokenAboutToExpire', () => setTimeout(() => this.emit('tokenAboutToExpire'), 0));\n    this.channel.on('tokenExpired', () => setTimeout(() => this.emit('tokenExpired'), 0));\n    this.channel.on('connected', () => this.registrations.updateRegistrations());\n    this.channel.on('connected', () => this.upstream.sendPendingMessages());\n    this.channel.on('connected', () => setTimeout(() => this.emit('connected'), 0)); // Twilsock telemetry events\n\n    this.channel.on('beforeConnect', () => this.telemetryTracker.addPartialEvent(new telemetrytracker_1.TelemetryEventDescription('Establish WebSocket connection', '', new Date()), TelemetryEvents.TWILSOCK_CONNECT, telemetrytracker_1.TelemetryPoint.Start));\n    this.channel.on('connected', () => this.telemetryTracker.addPartialEvent(new telemetrytracker_1.TelemetryEventDescription('Establish WebSocket connection', '', new Date(), new Date()), TelemetryEvents.TWILSOCK_CONNECT, telemetrytracker_1.TelemetryPoint.End));\n    this.channel.on('beforeSendInit', () => this.telemetryTracker.addPartialEvent(new telemetrytracker_1.TelemetryEventDescription('Send Twilsock init', '', new Date()), TelemetryEvents.TWILSOCK_INIT, telemetrytracker_1.TelemetryPoint.Start));\n    this.channel.on('initialized', () => this.telemetryTracker.addPartialEvent(new telemetrytracker_1.TelemetryEventDescription('Send Twilsock init', 'Succeeded', new Date(), new Date()), TelemetryEvents.TWILSOCK_INIT, telemetrytracker_1.TelemetryPoint.End));\n    this.channel.on('sendInitFailed', () => this.telemetryTracker.addPartialEvent(new telemetrytracker_1.TelemetryEventDescription('Send Twilsock init', 'Failed', new Date(), new Date()), TelemetryEvents.TWILSOCK_INIT, telemetrytracker_1.TelemetryPoint.End));\n    this.channel.on('initialized', initReply => {\n      this.handleStorageId(productId, initReply);\n      tokenStorage_1.TokenStorage.storeToken(initReply.continuationToken, productId);\n      setTimeout(() => this.emit('initialized', initReply), 0);\n    });\n    this.channel.on('disconnected', () => setTimeout(() => this.emit('disconnected'), 0));\n    this.channel.on('disconnected', () => this.upstream.rejectPendingMessages());\n    this.channel.on('disconnected', () => this.offlineStorageDeferred.fail(new twilsockerror_1.TwilsockError('Client disconnected')));\n    this.offlineStorageDeferred.promise.catch(() => {});\n  }\n\n  emit(event, ...args) {\n    logger_1.log.debug(`Emitting ${event.toString()}(${args.map(a => JSON.stringify(a)).join(', ')})`);\n    return super.emit(event, ...args);\n  }\n\n  handleStorageId(productId, initReply) {\n    if (!initReply.offlineStorage) {\n      this.offlineStorageDeferred.fail(new twilsockerror_1.TwilsockError('No offline storage id'));\n    } else if (initReply.offlineStorage.hasOwnProperty(productId)) {\n      try {\n        this.offlineStorageDeferred.set(offlinestorage_1.OfflineProductStorage.create(initReply.offlineStorage[productId]));\n        logger_1.log.debug(`Offline storage for '${productId}' product: ${JSON.stringify(initReply.offlineStorage[productId])}.`);\n      } catch (e) {\n        this.offlineStorageDeferred.fail(new twilsockerror_1.TwilsockError(`Failed to parse offline storage for ${productId} ${JSON.stringify(initReply.offlineStorage[productId])}. ${e}.`));\n      }\n    } else {\n      this.offlineStorageDeferred.fail(new twilsockerror_1.TwilsockError(`No offline storage id for '${productId}' product: ${JSON.stringify(initReply.offlineStorage)}`));\n    }\n  }\n  /**\n   * Get offline storage ID\n   * @returns {Promise}\n   */\n\n\n  storageId() {\n    return this.offlineStorageDeferred.promise;\n  }\n  /**\n   * Indicates if twilsock is connected now\n   * @returns {Boolean}\n   */\n\n\n  get isConnected() {\n    return this.channel.isConnected;\n  }\n  /**\n   * Current state\n   * @returns {String}\n   */\n\n\n  get state() {\n    return this.channel.state;\n  }\n  /**\n   * Update token\n   * @param {String} token\n   * @returns {Promise}\n   */\n\n\n  async updateToken(token) {\n    logger_1.log.trace(`updating token '${token}'`);\n\n    if (this.config.token === token) {\n      return;\n    }\n\n    this.config.updateToken(token);\n    return this.channel.updateToken(token);\n  }\n  /**\n   * Updates notification context.\n   * This method shouldn't be used anyone except twilio notifications library\n   * @param contextId id of notification context\n   * @param context value of notification context\n   * @private\n   */\n\n\n  setNotificationsContext(contextId, context) {\n    this.registrations.setNotificationsContext(contextId, context);\n  }\n  /**\n   * Remove notification context.\n   * This method shouldn't be used anyone except twilio notifications library\n   * @param contextId id of notification context\n   * @private\n   */\n\n\n  removeNotificationsContext(contextId) {\n    this.registrations.removeNotificationsContext(contextId);\n  }\n  /**\n   * Connect to the server\n   * @fires Twilsock#connected\n   * @public\n   * @returns {void}\n   */\n\n\n  connect() {\n    return this.channel.connect();\n  }\n  /**\n   * Disconnect from the server\n   * @fires Twilsock#disconnected\n   * @public\n   * @returns {Promise}\n   */\n\n\n  disconnect() {\n    this.telemetryTracker.sendTelemetry(telemetrytracker_1.EventSendingLimitation.AnyEventsIncludingUnfinished);\n    return this.channel.disconnect();\n  }\n  /**\n   * Get HTTP request to upstream service\n   * @param {string} url Upstream service url\n   * @param {headers} headers Set of custom headers\n   * @returns {Promise}\n   */\n\n\n  get(url, headers) {\n    this.telemetryTracker.sendTelemetry(telemetrytracker_1.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment\n\n    return this.upstream.send('GET', url, headers);\n  }\n  /**\n   * Post HTTP request to upstream service\n   * @param {string} url Upstream service url\n   * @param {headers} headers Set of custom headers\n   * @param {body} body Body to send\n   * @returns {Promise}\n   */\n\n\n  post(url, headers, body) {\n    this.telemetryTracker.sendTelemetry(telemetrytracker_1.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment\n\n    return this.upstream.send('POST', url, headers, body);\n  }\n  /**\n   * Put HTTP request to upstream service\n   * @param {string} url Upstream service url\n   * @param {headers} headers Set of custom headers\n   * @param {body} body Body to send\n   * @returns {Promise}\n   */\n\n\n  put(url, headers, body) {\n    this.telemetryTracker.sendTelemetry(telemetrytracker_1.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment\n\n    return this.upstream.send('PUT', url, headers, body);\n  }\n  /**\n   * Delete HTTP request to upstream service\n   * @param {string} url Upstream service url\n   * @param {headers} headers Set of custom headers\n   * @returns {Promise}\n   */\n\n\n  delete(url, headers) {\n    this.telemetryTracker.sendTelemetry(telemetrytracker_1.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment\n\n    return this.upstream.send('DELETE', url, headers);\n  }\n  /**\n   * Submits internal telemetry event. Not to be used for any customer and/or sensitive data.\n   * @param {TelemetryEventDescription} event Event details.\n   * @returns {void}\n   */\n\n\n  addTelemetryEvent(event) {\n    this.telemetryTracker.addTelemetryEvent(event);\n    this.telemetryTracker.sendTelemetryIfMinimalPortionCollected(); // send telemetry if need\n  }\n  /**\n   * Submits internal telemetry event. Not to be used for any customer and/or sensitive data.\n   * @param {TelemetryEventDescription} event Event details.\n   * @param {string} eventKey Unique event key.\n   * @param {TelemetryPoint} point Is this partial event for start or end of measurement.\n   * @returns {void}\n   */\n\n\n  addPartialTelemetryEvent(event, eventKey, point) {\n    this.telemetryTracker.addPartialEvent(event, eventKey, point);\n\n    if (point === telemetrytracker_1.TelemetryPoint.End) {\n      // this telemetry event is complete, so minimal portion could become ready to send\n      this.telemetryTracker.sendTelemetryIfMinimalPortionCollected(); // send telemetry if need\n    }\n  }\n\n}\n\nexports.TwilsockClient = TwilsockClient;\nexports.Twilsock = TwilsockClient;\n/**\n * Twilsock destination address descriptor\n * @typedef {Object} Twilsock#Address\n * @property {String} method - HTTP method. (POST, PUT, etc)\n * @property {String} host - host name without path. (e.g. my.company.com)\n * @property {String} path - path on the host (e.g. /my/app/to/call.php)\n */\n\n/**\n * Twilsock upstream message\n * @typedef {Object} Twilsock#Message\n * @property {Twilsock#Address} to - destination address\n * @property {Object} headers - HTTP headers\n * @property {Object} body - Body\n */\n\n/**\n * Fired when new message received\n * @param {Twilsock#Message} message\n * @event Twilsock#message\n */\n\n/**\n * Fired when socket connected\n * @param {String} URI of endpoint\n * @event Twilsock#connected\n */\n\n/**\n * Fired when socket disconnected\n * @event Twilsock#disconnected\n */\n\n/**\n * Fired when token is about to expire and should be updated\n * @event Twilsock#tokenAboutToExpire\n */\n\n/**\n* Fired when socket connected\n* @param {('connecting'|'connected'|'rejected'|'disconnecting'|'disconnected')} state - general twilsock state\n* @event Twilsock#stateChanged\n*/\n\n/**\n * Fired when connection is interrupted by unexpected reason\n * @type {Object}\n * @property {Boolean} terminal - twilsock will stop connection attempts\n * @property {String} message - root cause\n * @property {Number} [httpStatusCode] - http status code if available\n * @property {Number} [errorCode] - Twilio public error code if available\n * @event Twilsock#connectionError\n */","map":{"version":3,"sources":["/root/twilio-phone-client/node_modules/twilsock/lib/client.js"],"names":["Object","defineProperty","exports","value","Twilsock","TwilsockClient","TelemetryEvents","events_1","require","logger_1","configuration_1","twilsock_1","packetinterface_1","websocketchannel_1","registrations_1","upstream_1","deferred_1","twilsockerror_1","offlinestorage_1","tokenStorage_1","telemetrytracker_1","TWILSOCK_CONNECT","TWILSOCK_INIT","EventEmitter","constructor","token","productId","options","offlineStorageDeferred","Deferred","continuationToken","TokenStorage","getStoredToken","config","Configuration","log","setLevel","logLevel","websocket","WebSocketChannel","url","transport","PacketInterface","channel","TwilsockImpl","registrations","Registrations","upstream","Upstream","telemetryTracker","TelemetryTracker","on","canSendTelemetry","id","emit","type","message","setTimeout","state","connectionError","updateRegistrations","sendPendingMessages","addPartialEvent","TelemetryEventDescription","Date","TelemetryPoint","Start","End","initReply","handleStorageId","storeToken","rejectPendingMessages","fail","TwilsockError","promise","catch","event","args","debug","toString","map","a","JSON","stringify","join","offlineStorage","hasOwnProperty","set","OfflineProductStorage","create","e","storageId","isConnected","updateToken","trace","setNotificationsContext","contextId","context","removeNotificationsContext","connect","disconnect","sendTelemetry","EventSendingLimitation","AnyEventsIncludingUnfinished","get","headers","AnyEvents","send","post","body","put","delete","addTelemetryEvent","sendTelemetryIfMinimalPortionCollected","addPartialTelemetryEvent","eventKey","point"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Twilsock = exports.TwilsockClient = exports.TelemetryEvents = void 0;\nconst events_1 = require(\"events\");\nconst logger_1 = require(\"./logger\");\nconst configuration_1 = require(\"./configuration\");\nconst twilsock_1 = require(\"./twilsock\");\nconst packetinterface_1 = require(\"./packetinterface\");\nconst websocketchannel_1 = require(\"./websocketchannel\");\nconst registrations_1 = require(\"./services/registrations\");\nconst upstream_1 = require(\"./services/upstream\");\nconst deferred_1 = require(\"./deferred\");\nconst twilsockerror_1 = require(\"./error/twilsockerror\");\nconst offlinestorage_1 = require(\"./offlinestorage\");\nconst tokenStorage_1 = require(\"./tokenStorage\");\nconst telemetrytracker_1 = require(\"./services/telemetrytracker\");\nclass TelemetryEvents {\n}\nexports.TelemetryEvents = TelemetryEvents;\nTelemetryEvents.TWILSOCK_CONNECT = 'twilsock.sdk.connect'; // establish WebSocket connection (with WebSocket handshake finished)\nTelemetryEvents.TWILSOCK_INIT = 'twilsock.sdk.init'; // send \"init\" message and receive reply\n/**\n * @alias Twilsock\n * @classdesc Client library for the Twilsock service\n * It allows to recevie service-generated updates as well as bi-directional transport\n * @fires Twilsock#message\n * @fires Twilsock#connected\n * @fires Twilsock#disconnected\n * @fires Twilsock#tokenAboutToExpire\n * @fires Twilsock#stateChanged\n * @fires Twilsock#connectionError\n */\nclass TwilsockClient extends events_1.EventEmitter {\n    /**\n     * @param {string} token Twilio access token\n     * @param {string} productId Product identifier. Should be the same as a grant name in token\n     */\n    constructor(token, productId, options = {}) {\n        super();\n        this.offlineStorageDeferred = new deferred_1.Deferred();\n        options.continuationToken = options.continuationToken ? options.continuationToken : tokenStorage_1.TokenStorage.getStoredToken(productId);\n        let config = this.config = new configuration_1.Configuration(token, productId, options);\n        logger_1.log.setLevel(config.logLevel);\n        let websocket = new websocketchannel_1.WebSocketChannel(config.url);\n        let transport = options.transport\n            ? options.transport\n            : new packetinterface_1.PacketInterface(websocket, config);\n        this.channel = options.channel\n            ? options.channel\n            : new twilsock_1.TwilsockImpl(websocket, transport, config);\n        this.registrations = options.registrations\n            ? options.registrations\n            : new registrations_1.Registrations(transport);\n        this.upstream = new upstream_1.Upstream(transport, this.channel, config);\n        // Send telemetry only when connected and initialised\n        this.telemetryTracker = new telemetrytracker_1.TelemetryTracker(config, transport);\n        this.channel.on('initialized', () => this.telemetryTracker.canSendTelemetry = true);\n        websocket.on('disconnected', () => this.telemetryTracker.canSendTelemetry = false);\n        this.registrations.on('registered', (id) => this.emit('registered', id));\n        this.channel.on('message', (type, message) => setTimeout(() => this.emit('message', type, message), 0));\n        this.channel.on('stateChanged', state => setTimeout(() => this.emit('stateChanged', state), 0));\n        this.channel.on('connectionError', (connectionError) => setTimeout(() => this.emit('connectionError', connectionError), 0));\n        this.channel.on('tokenAboutToExpire', () => setTimeout(() => this.emit('tokenAboutToExpire'), 0));\n        this.channel.on('tokenExpired', () => setTimeout(() => this.emit('tokenExpired'), 0));\n        this.channel.on('connected', () => this.registrations.updateRegistrations());\n        this.channel.on('connected', () => this.upstream.sendPendingMessages());\n        this.channel.on('connected', () => setTimeout(() => this.emit('connected'), 0));\n        // Twilsock telemetry events\n        this.channel.on('beforeConnect', () => this.telemetryTracker.addPartialEvent(new telemetrytracker_1.TelemetryEventDescription('Establish WebSocket connection', '', new Date()), TelemetryEvents.TWILSOCK_CONNECT, telemetrytracker_1.TelemetryPoint.Start));\n        this.channel.on('connected', () => this.telemetryTracker.addPartialEvent(new telemetrytracker_1.TelemetryEventDescription('Establish WebSocket connection', '', new Date(), new Date()), TelemetryEvents.TWILSOCK_CONNECT, telemetrytracker_1.TelemetryPoint.End));\n        this.channel.on('beforeSendInit', () => this.telemetryTracker.addPartialEvent(new telemetrytracker_1.TelemetryEventDescription('Send Twilsock init', '', new Date()), TelemetryEvents.TWILSOCK_INIT, telemetrytracker_1.TelemetryPoint.Start));\n        this.channel.on('initialized', () => this.telemetryTracker.addPartialEvent(new telemetrytracker_1.TelemetryEventDescription('Send Twilsock init', 'Succeeded', new Date(), new Date()), TelemetryEvents.TWILSOCK_INIT, telemetrytracker_1.TelemetryPoint.End));\n        this.channel.on('sendInitFailed', () => this.telemetryTracker.addPartialEvent(new telemetrytracker_1.TelemetryEventDescription('Send Twilsock init', 'Failed', new Date(), new Date()), TelemetryEvents.TWILSOCK_INIT, telemetrytracker_1.TelemetryPoint.End));\n        this.channel.on('initialized', (initReply) => {\n            this.handleStorageId(productId, initReply);\n            tokenStorage_1.TokenStorage.storeToken(initReply.continuationToken, productId);\n            setTimeout(() => this.emit('initialized', initReply), 0);\n        });\n        this.channel.on('disconnected', () => setTimeout(() => this.emit('disconnected'), 0));\n        this.channel.on('disconnected', () => this.upstream.rejectPendingMessages());\n        this.channel.on('disconnected', () => this.offlineStorageDeferred.fail(new twilsockerror_1.TwilsockError('Client disconnected')));\n        this.offlineStorageDeferred.promise.catch(() => { });\n    }\n    emit(event, ...args) {\n        logger_1.log.debug(`Emitting ${event.toString()}(${args.map(a => JSON.stringify(a)).join(', ')})`);\n        return super.emit(event, ...args);\n    }\n    handleStorageId(productId, initReply) {\n        if (!initReply.offlineStorage) {\n            this.offlineStorageDeferred.fail(new twilsockerror_1.TwilsockError('No offline storage id'));\n        }\n        else if (initReply.offlineStorage.hasOwnProperty(productId)) {\n            try {\n                this.offlineStorageDeferred.set(offlinestorage_1.OfflineProductStorage.create(initReply.offlineStorage[productId]));\n                logger_1.log.debug(`Offline storage for '${productId}' product: ${JSON.stringify(initReply.offlineStorage[productId])}.`);\n            }\n            catch (e) {\n                this.offlineStorageDeferred.fail(new twilsockerror_1.TwilsockError(`Failed to parse offline storage for ${productId} ${JSON.stringify(initReply.offlineStorage[productId])}. ${e}.`));\n            }\n        }\n        else {\n            this.offlineStorageDeferred.fail(new twilsockerror_1.TwilsockError(`No offline storage id for '${productId}' product: ${JSON.stringify(initReply.offlineStorage)}`));\n        }\n    }\n    /**\n     * Get offline storage ID\n     * @returns {Promise}\n     */\n    storageId() {\n        return this.offlineStorageDeferred.promise;\n    }\n    /**\n     * Indicates if twilsock is connected now\n     * @returns {Boolean}\n     */\n    get isConnected() {\n        return this.channel.isConnected;\n    }\n    /**\n     * Current state\n     * @returns {String}\n     */\n    get state() {\n        return this.channel.state;\n    }\n    /**\n     * Update token\n     * @param {String} token\n     * @returns {Promise}\n     */\n    async updateToken(token) {\n        logger_1.log.trace(`updating token '${token}'`);\n        if (this.config.token === token) {\n            return;\n        }\n        this.config.updateToken(token);\n        return this.channel.updateToken(token);\n    }\n    /**\n     * Updates notification context.\n     * This method shouldn't be used anyone except twilio notifications library\n     * @param contextId id of notification context\n     * @param context value of notification context\n     * @private\n     */\n    setNotificationsContext(contextId, context) {\n        this.registrations.setNotificationsContext(contextId, context);\n    }\n    /**\n     * Remove notification context.\n     * This method shouldn't be used anyone except twilio notifications library\n     * @param contextId id of notification context\n     * @private\n     */\n    removeNotificationsContext(contextId) {\n        this.registrations.removeNotificationsContext(contextId);\n    }\n    /**\n     * Connect to the server\n     * @fires Twilsock#connected\n     * @public\n     * @returns {void}\n     */\n    connect() {\n        return this.channel.connect();\n    }\n    /**\n     * Disconnect from the server\n     * @fires Twilsock#disconnected\n     * @public\n     * @returns {Promise}\n     */\n    disconnect() {\n        this.telemetryTracker.sendTelemetry(telemetrytracker_1.EventSendingLimitation.AnyEventsIncludingUnfinished);\n        return this.channel.disconnect();\n    }\n    /**\n     * Get HTTP request to upstream service\n     * @param {string} url Upstream service url\n     * @param {headers} headers Set of custom headers\n     * @returns {Promise}\n     */\n    get(url, headers) {\n        this.telemetryTracker.sendTelemetry(telemetrytracker_1.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment\n        return this.upstream.send('GET', url, headers);\n    }\n    /**\n     * Post HTTP request to upstream service\n     * @param {string} url Upstream service url\n     * @param {headers} headers Set of custom headers\n     * @param {body} body Body to send\n     * @returns {Promise}\n     */\n    post(url, headers, body) {\n        this.telemetryTracker.sendTelemetry(telemetrytracker_1.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment\n        return this.upstream.send('POST', url, headers, body);\n    }\n    /**\n     * Put HTTP request to upstream service\n     * @param {string} url Upstream service url\n     * @param {headers} headers Set of custom headers\n     * @param {body} body Body to send\n     * @returns {Promise}\n     */\n    put(url, headers, body) {\n        this.telemetryTracker.sendTelemetry(telemetrytracker_1.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment\n        return this.upstream.send('PUT', url, headers, body);\n    }\n    /**\n     * Delete HTTP request to upstream service\n     * @param {string} url Upstream service url\n     * @param {headers} headers Set of custom headers\n     * @returns {Promise}\n     */\n    delete(url, headers) {\n        this.telemetryTracker.sendTelemetry(telemetrytracker_1.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment\n        return this.upstream.send('DELETE', url, headers);\n    }\n    /**\n     * Submits internal telemetry event. Not to be used for any customer and/or sensitive data.\n     * @param {TelemetryEventDescription} event Event details.\n     * @returns {void}\n     */\n    addTelemetryEvent(event) {\n        this.telemetryTracker.addTelemetryEvent(event);\n        this.telemetryTracker.sendTelemetryIfMinimalPortionCollected(); // send telemetry if need\n    }\n    /**\n     * Submits internal telemetry event. Not to be used for any customer and/or sensitive data.\n     * @param {TelemetryEventDescription} event Event details.\n     * @param {string} eventKey Unique event key.\n     * @param {TelemetryPoint} point Is this partial event for start or end of measurement.\n     * @returns {void}\n     */\n    addPartialTelemetryEvent(event, eventKey, point) {\n        this.telemetryTracker.addPartialEvent(event, eventKey, point);\n        if (point === telemetrytracker_1.TelemetryPoint.End) {\n            // this telemetry event is complete, so minimal portion could become ready to send\n            this.telemetryTracker.sendTelemetryIfMinimalPortionCollected(); // send telemetry if need\n        }\n    }\n}\nexports.TwilsockClient = TwilsockClient;\nexports.Twilsock = TwilsockClient;\n/**\n * Twilsock destination address descriptor\n * @typedef {Object} Twilsock#Address\n * @property {String} method - HTTP method. (POST, PUT, etc)\n * @property {String} host - host name without path. (e.g. my.company.com)\n * @property {String} path - path on the host (e.g. /my/app/to/call.php)\n */\n/**\n * Twilsock upstream message\n * @typedef {Object} Twilsock#Message\n * @property {Twilsock#Address} to - destination address\n * @property {Object} headers - HTTP headers\n * @property {Object} body - Body\n */\n/**\n * Fired when new message received\n * @param {Twilsock#Message} message\n * @event Twilsock#message\n */\n/**\n * Fired when socket connected\n * @param {String} URI of endpoint\n * @event Twilsock#connected\n */\n/**\n * Fired when socket disconnected\n * @event Twilsock#disconnected\n */\n/**\n * Fired when token is about to expire and should be updated\n * @event Twilsock#tokenAboutToExpire\n */\n/**\n* Fired when socket connected\n* @param {('connecting'|'connected'|'rejected'|'disconnecting'|'disconnected')} state - general twilsock state\n* @event Twilsock#stateChanged\n*/\n/**\n * Fired when connection is interrupted by unexpected reason\n * @type {Object}\n * @property {Boolean} terminal - twilsock will stop connection attempts\n * @property {String} message - root cause\n * @property {Number} [httpStatusCode] - http status code if available\n * @property {Number} [errorCode] - Twilio public error code if available\n * @event Twilsock#connectionError\n */\n"]},"metadata":{},"sourceType":"script"}