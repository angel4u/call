{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar util = require('../util');\n\nvar ptToFixedBitrateAudioCodecName = {\n  0: 'PCMU',\n  8: 'PCMA'\n};\nvar defaultOpusId = 111;\nvar BITRATE_MAX = 510000;\nvar BITRATE_MIN = 6000;\n\nfunction getPreferredCodecInfo(sdp) {\n  var _ref = /a=rtpmap:(\\d+) (\\S+)/m.exec(sdp) || [null, '', ''],\n      _ref2 = _slicedToArray(_ref, 3),\n      codecId = _ref2[1],\n      codecName = _ref2[2];\n\n  var regex = new RegExp('a=fmtp:' + codecId + ' (\\\\S+)', 'm');\n\n  var _ref3 = regex.exec(sdp) || [null, ''],\n      _ref4 = _slicedToArray(_ref3, 2),\n      codecParams = _ref4[1];\n\n  return {\n    codecName: codecName,\n    codecParams: codecParams\n  };\n}\n\nfunction setIceAggressiveNomination(sdp) {\n  // This only works on Chrome. We don't want any side effects on other browsers\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=1024096\n  // https://issues.corp.twilio.com/browse/CLIENT-6911\n  if (!util.isChrome(window, window.navigator)) {\n    return sdp;\n  }\n\n  return sdp.split('\\n').filter(function (line) {\n    return line.indexOf('a=ice-lite') === -1;\n  }).join('\\n');\n}\n\nfunction setMaxAverageBitrate(sdp, maxAverageBitrate) {\n  if (typeof maxAverageBitrate !== 'number' || maxAverageBitrate < BITRATE_MIN || maxAverageBitrate > BITRATE_MAX) {\n    return sdp;\n  }\n\n  var matches = /a=rtpmap:(\\d+) opus/m.exec(sdp);\n  var opusId = matches && matches.length ? matches[1] : defaultOpusId;\n  var regex = new RegExp('a=fmtp:' + opusId);\n  var lines = sdp.split('\\n').map(function (line) {\n    return regex.test(line) ? line + (';maxaveragebitrate=' + maxAverageBitrate) : line;\n  });\n  return lines.join('\\n');\n}\n/**\n * Return a new SDP string with the re-ordered codec preferences.\n * @param {string} sdp\n * @param {Array<AudioCodec>} preferredCodecs - If empty, the existing order\n *   of audio codecs is preserved\n * @returns {string} Updated SDP string\n */\n\n\nfunction setCodecPreferences(sdp, preferredCodecs) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    // Codec preferences should not be applied to m=application sections.\n    if (!/^m=(audio|video)/.test(section)) {\n      return section;\n    }\n\n    var kind = section.match(/^m=(audio|video)/)[1];\n    var codecMap = createCodecMapForMediaSection(section);\n    var payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);\n    var newSection = setPayloadTypesInMediaSection(payloadTypes, section);\n    var pcmaPayloadTypes = codecMap.get('pcma') || [];\n    var pcmuPayloadTypes = codecMap.get('pcmu') || [];\n    var fixedBitratePayloadTypes = kind === 'audio' ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes)) : new Set();\n    return fixedBitratePayloadTypes.has(payloadTypes[0]) ? newSection.replace(/\\r\\nb=(AS|TIAS):([0-9]+)/g, '') : newSection;\n  })).join('\\r\\n');\n}\n/**\n * Get the m= sections of a particular kind and direction from an sdp.\n * @param {string} sdp - SDP string\n * @param {string} [kind] - Pattern for matching kind\n * @param {string} [direction] - Pattern for matching direction\n * @returns {Array<string>} mediaSections\n */\n\n\nfunction getMediaSections(sdp, kind, direction) {\n  return sdp.replace(/\\r\\n\\r\\n$/, '\\r\\n').split('\\r\\nm=').slice(1).map(function (mediaSection) {\n    return 'm=' + mediaSection;\n  }).filter(function (mediaSection) {\n    var kindPattern = new RegExp('m=' + (kind || '.*'), 'gm');\n    var directionPattern = new RegExp('a=' + (direction || '.*'), 'gm');\n    return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\n  });\n}\n/**\n * Create a Codec Map for the given m= section.\n * @param {string} section - The given m= section\n * @returns {Map<Codec, Array<PT>>}\n */\n\n\nfunction createCodecMapForMediaSection(section) {\n  return Array.from(createPtToCodecName(section)).reduce(function (codecMap, pair) {\n    var pt = pair[0];\n    var codecName = pair[1];\n    var pts = codecMap.get(codecName) || [];\n    return codecMap.set(codecName, pts.concat(pt));\n  }, new Map());\n}\n/**\n * Create the reordered Codec Payload Types based on the preferred Codec Names.\n * @param {Map<Codec, Array<PT>>} codecMap - Codec Map\n * @param {Array<Codec>} preferredCodecs - Preferred Codec Names\n * @returns {Array<PT>} Reordered Payload Types\n */\n\n\nfunction getReorderedPayloadTypes(codecMap, preferredCodecs) {\n  preferredCodecs = preferredCodecs.map(function (codecName) {\n    return codecName.toLowerCase();\n  });\n  var preferredPayloadTypes = util.flatMap(preferredCodecs, function (codecName) {\n    return codecMap.get(codecName) || [];\n  });\n  var remainingCodecs = util.difference(Array.from(codecMap.keys()), preferredCodecs);\n  var remainingPayloadTypes = util.flatMap(remainingCodecs, function (codecName) {\n    return codecMap.get(codecName);\n  });\n  return preferredPayloadTypes.concat(remainingPayloadTypes);\n}\n/**\n * Set the given Codec Payload Types in the first line of the given m= section.\n * @param {Array<PT>} payloadTypes - Payload Types\n * @param {string} section - Given m= section\n * @returns {string} - Updated m= section\n */\n\n\nfunction setPayloadTypesInMediaSection(payloadTypes, section) {\n  var lines = section.split('\\r\\n');\n  var mLine = lines[0];\n  var otherLines = lines.slice(1);\n  mLine = mLine.replace(/([0-9]+\\s?)+$/, payloadTypes.join(' '));\n  return [mLine].concat(otherLines).join('\\r\\n');\n}\n/**\n * Create a Map from PTs to codec names for the given m= section.\n * @param {string} mediaSection - The given m= section.\n * @returns {Map<PT, Codec>} ptToCodecName\n */\n\n\nfunction createPtToCodecName(mediaSection) {\n  return getPayloadTypesInMediaSection(mediaSection).reduce(function (ptToCodecName, pt) {\n    var rtpmapPattern = new RegExp('a=rtpmap:' + pt + ' ([^/]+)');\n    var matches = mediaSection.match(rtpmapPattern);\n    var codecName = matches ? matches[1].toLowerCase() : ptToFixedBitrateAudioCodecName[pt] ? ptToFixedBitrateAudioCodecName[pt].toLowerCase() : '';\n    return ptToCodecName.set(pt, codecName);\n  }, new Map());\n}\n/**\n * Get the Codec Payload Types present in the first line of the given m= section\n * @param {string} section - The m= section\n * @returns {Array<PT>} Payload Types\n */\n\n\nfunction getPayloadTypesInMediaSection(section) {\n  var mLine = section.split('\\r\\n')[0]; // In \"m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>\",\n  // the regex matches <port> and the PayloadTypes.\n\n  var matches = mLine.match(/([0-9]+)/g); // This should not happen, but in case there are no PayloadTypes in\n  // the m= line, return an empty array.\n\n  if (!matches) {\n    return [];\n  } // Since only the PayloadTypes are needed, we discard the <port>.\n\n\n  return matches.slice(1).map(function (match) {\n    return parseInt(match, 10);\n  });\n}\n\nmodule.exports = {\n  getPreferredCodecInfo: getPreferredCodecInfo,\n  setCodecPreferences: setCodecPreferences,\n  setIceAggressiveNomination: setIceAggressiveNomination,\n  setMaxAverageBitrate: setMaxAverageBitrate\n};","map":{"version":3,"sources":["/root/twilio-phone-client/node_modules/twilio-client/es5/twilio/rtc/sdp.js"],"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","Object","TypeError","util","require","ptToFixedBitrateAudioCodecName","defaultOpusId","BITRATE_MAX","BITRATE_MIN","getPreferredCodecInfo","sdp","_ref","exec","_ref2","codecId","codecName","regex","RegExp","_ref3","_ref4","codecParams","setIceAggressiveNomination","isChrome","window","navigator","split","filter","line","indexOf","join","setMaxAverageBitrate","maxAverageBitrate","matches","opusId","lines","map","test","setCodecPreferences","preferredCodecs","mediaSections","getMediaSections","session","concat","section","kind","match","codecMap","createCodecMapForMediaSection","payloadTypes","getReorderedPayloadTypes","newSection","setPayloadTypesInMediaSection","pcmaPayloadTypes","get","pcmuPayloadTypes","fixedBitratePayloadTypes","Set","has","replace","direction","slice","mediaSection","kindPattern","directionPattern","from","createPtToCodecName","reduce","pair","pt","pts","set","Map","toLowerCase","preferredPayloadTypes","flatMap","remainingCodecs","difference","keys","remainingPayloadTypes","mLine","otherLines","getPayloadTypesInMediaSection","ptToCodecName","rtpmapPattern","parseInt","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar util = require('../util');\n\nvar ptToFixedBitrateAudioCodecName = {\n  0: 'PCMU',\n  8: 'PCMA'\n};\n\nvar defaultOpusId = 111;\nvar BITRATE_MAX = 510000;\nvar BITRATE_MIN = 6000;\n\nfunction getPreferredCodecInfo(sdp) {\n  var _ref = /a=rtpmap:(\\d+) (\\S+)/m.exec(sdp) || [null, '', ''],\n      _ref2 = _slicedToArray(_ref, 3),\n      codecId = _ref2[1],\n      codecName = _ref2[2];\n\n  var regex = new RegExp('a=fmtp:' + codecId + ' (\\\\S+)', 'm');\n\n  var _ref3 = regex.exec(sdp) || [null, ''],\n      _ref4 = _slicedToArray(_ref3, 2),\n      codecParams = _ref4[1];\n\n  return { codecName: codecName, codecParams: codecParams };\n}\n\nfunction setIceAggressiveNomination(sdp) {\n  // This only works on Chrome. We don't want any side effects on other browsers\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=1024096\n  // https://issues.corp.twilio.com/browse/CLIENT-6911\n  if (!util.isChrome(window, window.navigator)) {\n    return sdp;\n  }\n\n  return sdp.split('\\n').filter(function (line) {\n    return line.indexOf('a=ice-lite') === -1;\n  }).join('\\n');\n}\n\nfunction setMaxAverageBitrate(sdp, maxAverageBitrate) {\n  if (typeof maxAverageBitrate !== 'number' || maxAverageBitrate < BITRATE_MIN || maxAverageBitrate > BITRATE_MAX) {\n    return sdp;\n  }\n\n  var matches = /a=rtpmap:(\\d+) opus/m.exec(sdp);\n  var opusId = matches && matches.length ? matches[1] : defaultOpusId;\n  var regex = new RegExp('a=fmtp:' + opusId);\n  var lines = sdp.split('\\n').map(function (line) {\n    return regex.test(line) ? line + (';maxaveragebitrate=' + maxAverageBitrate) : line;\n  });\n\n  return lines.join('\\n');\n}\n\n/**\n * Return a new SDP string with the re-ordered codec preferences.\n * @param {string} sdp\n * @param {Array<AudioCodec>} preferredCodecs - If empty, the existing order\n *   of audio codecs is preserved\n * @returns {string} Updated SDP string\n */\nfunction setCodecPreferences(sdp, preferredCodecs) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    // Codec preferences should not be applied to m=application sections.\n    if (!/^m=(audio|video)/.test(section)) {\n      return section;\n    }\n    var kind = section.match(/^m=(audio|video)/)[1];\n    var codecMap = createCodecMapForMediaSection(section);\n    var payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);\n    var newSection = setPayloadTypesInMediaSection(payloadTypes, section);\n\n    var pcmaPayloadTypes = codecMap.get('pcma') || [];\n    var pcmuPayloadTypes = codecMap.get('pcmu') || [];\n    var fixedBitratePayloadTypes = kind === 'audio' ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes)) : new Set();\n\n    return fixedBitratePayloadTypes.has(payloadTypes[0]) ? newSection.replace(/\\r\\nb=(AS|TIAS):([0-9]+)/g, '') : newSection;\n  })).join('\\r\\n');\n}\n\n/**\n * Get the m= sections of a particular kind and direction from an sdp.\n * @param {string} sdp - SDP string\n * @param {string} [kind] - Pattern for matching kind\n * @param {string} [direction] - Pattern for matching direction\n * @returns {Array<string>} mediaSections\n */\nfunction getMediaSections(sdp, kind, direction) {\n  return sdp.replace(/\\r\\n\\r\\n$/, '\\r\\n').split('\\r\\nm=').slice(1).map(function (mediaSection) {\n    return 'm=' + mediaSection;\n  }).filter(function (mediaSection) {\n    var kindPattern = new RegExp('m=' + (kind || '.*'), 'gm');\n    var directionPattern = new RegExp('a=' + (direction || '.*'), 'gm');\n    return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\n  });\n}\n\n/**\n * Create a Codec Map for the given m= section.\n * @param {string} section - The given m= section\n * @returns {Map<Codec, Array<PT>>}\n */\nfunction createCodecMapForMediaSection(section) {\n  return Array.from(createPtToCodecName(section)).reduce(function (codecMap, pair) {\n    var pt = pair[0];\n    var codecName = pair[1];\n    var pts = codecMap.get(codecName) || [];\n    return codecMap.set(codecName, pts.concat(pt));\n  }, new Map());\n}\n\n/**\n * Create the reordered Codec Payload Types based on the preferred Codec Names.\n * @param {Map<Codec, Array<PT>>} codecMap - Codec Map\n * @param {Array<Codec>} preferredCodecs - Preferred Codec Names\n * @returns {Array<PT>} Reordered Payload Types\n */\nfunction getReorderedPayloadTypes(codecMap, preferredCodecs) {\n  preferredCodecs = preferredCodecs.map(function (codecName) {\n    return codecName.toLowerCase();\n  });\n\n  var preferredPayloadTypes = util.flatMap(preferredCodecs, function (codecName) {\n    return codecMap.get(codecName) || [];\n  });\n\n  var remainingCodecs = util.difference(Array.from(codecMap.keys()), preferredCodecs);\n  var remainingPayloadTypes = util.flatMap(remainingCodecs, function (codecName) {\n    return codecMap.get(codecName);\n  });\n\n  return preferredPayloadTypes.concat(remainingPayloadTypes);\n}\n\n/**\n * Set the given Codec Payload Types in the first line of the given m= section.\n * @param {Array<PT>} payloadTypes - Payload Types\n * @param {string} section - Given m= section\n * @returns {string} - Updated m= section\n */\nfunction setPayloadTypesInMediaSection(payloadTypes, section) {\n  var lines = section.split('\\r\\n');\n  var mLine = lines[0];\n  var otherLines = lines.slice(1);\n  mLine = mLine.replace(/([0-9]+\\s?)+$/, payloadTypes.join(' '));\n  return [mLine].concat(otherLines).join('\\r\\n');\n}\n\n/**\n * Create a Map from PTs to codec names for the given m= section.\n * @param {string} mediaSection - The given m= section.\n * @returns {Map<PT, Codec>} ptToCodecName\n */\nfunction createPtToCodecName(mediaSection) {\n  return getPayloadTypesInMediaSection(mediaSection).reduce(function (ptToCodecName, pt) {\n    var rtpmapPattern = new RegExp('a=rtpmap:' + pt + ' ([^/]+)');\n    var matches = mediaSection.match(rtpmapPattern);\n    var codecName = matches ? matches[1].toLowerCase() : ptToFixedBitrateAudioCodecName[pt] ? ptToFixedBitrateAudioCodecName[pt].toLowerCase() : '';\n    return ptToCodecName.set(pt, codecName);\n  }, new Map());\n}\n\n/**\n * Get the Codec Payload Types present in the first line of the given m= section\n * @param {string} section - The m= section\n * @returns {Array<PT>} Payload Types\n */\nfunction getPayloadTypesInMediaSection(section) {\n  var mLine = section.split('\\r\\n')[0];\n\n  // In \"m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>\",\n  // the regex matches <port> and the PayloadTypes.\n  var matches = mLine.match(/([0-9]+)/g);\n\n  // This should not happen, but in case there are no PayloadTypes in\n  // the m= line, return an empty array.\n  if (!matches) {\n    return [];\n  }\n\n  // Since only the PayloadTypes are needed, we discard the <port>.\n  return matches.slice(1).map(function (match) {\n    return parseInt(match, 10);\n  });\n}\n\nmodule.exports = {\n  getPreferredCodecInfo: getPreferredCodecInfo,\n  setCodecPreferences: setCodecPreferences,\n  setIceAggressiveNomination: setIceAggressiveNomination,\n  setMaxAverageBitrate: setMaxAverageBitrate\n};"]},"metadata":{},"sourceType":"script"}