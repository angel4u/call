{"ast":null,"code":"import _taggedTemplateLiteral from \"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";\nimport _classCallCheck from \"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/esm/inherits\";\n\nvar _jsxFileName = \"/root/twilio-phone-client/src/components/MsgCanvas.js\",\n    _templateObject;\n\nimport React, { Component } from 'react';\nimport styled from 'styled-components';\nimport MsgContactList from './MsgContactList';\nimport MsgContactAdd from './MsgContactAdd';\nimport MsgList from './MsgList';\nimport MsgComposer from './MsgComposer';\nimport Spinner from './Spinner';\nimport MsgContactHeader from './MsgContactHeader';\nvar msgsPerPage = 30;\n\nvar CanvasMsg = /*#__PURE__*/function (_Component) {\n  _inherits(CanvasMsg, _Component);\n\n  function CanvasMsg(props) {\n    var _this;\n\n    _classCallCheck(this, CanvasMsg);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CanvasMsg).call(this, props));\n\n    _this.selectContact = function (selectedContact) {\n      _this.setState({\n        selectedContact: selectedContact\n      });\n\n      if (selectedContact !== null) {\n        _this.fetchMsgsForContact(selectedContact); // async fetch data for selected contact\n\n\n        _this.props.client.getChannelByUniqueName(selectedContact).then(function (channel) {\n          // mark all messages as read\n          channel.setAllMessagesConsumed().then(function () {\n            // when done, update cache as well\n            _this.props.setUnreadsCache(selectedContact, 0);\n          });\n        });\n      }\n    };\n\n    _this.deleteThread = function (contact) {\n      _this.props.client.getChannelByUniqueName(contact).then(function (channel) {\n        // mark all messages as read\n        channel.delete();\n        _this.fetchTracker[contact] = false;\n        delete _this.msgAddedHandlerTracker[contact];\n      });\n    };\n\n    _this.fetchAnotherPage = function () {\n      return new Promise(function (resolve, reject) {\n        var contact = _this.state.selectedContact;\n\n        if (contact === 'new') {\n          return;\n        }\n\n        var paginator = _this.props.msgPgtrCache[contact];\n\n        if (!paginator.hasPrevPage) {\n          reject('No more messages.');\n        } else {\n          paginator.prevPage().then(function (paginator) {\n            var messages = [];\n            paginator.items.forEach(function (msg) {\n              messages.push(msg);\n            });\n\n            _this.props.addMsgCachePage(contact, messages, paginator);\n\n            resolve();\n          });\n        }\n      });\n    };\n\n    _this.msgAddedHandler = function (contact, msg) {\n      _this.props.addMsgCacheMsg(contact, msg);\n\n      if ( // if we're the originator of the message, it means we've read it\n      // (this ensures messages originating from this client don't count as unread)\n      msg.state.author === 'us' || // or same thing if user has the thread the message belongs to currently opened\n      contact === _this.state.selectedContact) {\n        _this.props.channelList[contact].updateLastConsumedMessageIndex(msg.state.index).then(function () {\n          _this.props.setUnreadMsgs(_this.props.channelList[contact], contact);\n        });\n      } else {\n        _this.props.setUnreadMsgs(_this.props.channelList[contact], contact);\n      }\n    };\n\n    _this.fetchMsgsForContact = function (contact) {\n      if (contact === 'new') {\n        return;\n      }\n\n      if (_this.props.msgCache[contact] === undefined && !_this.fetchTracker[contact]) {\n        _this.fetchTracker[contact] = true; // prevent double-fetching\n\n        _this.props.client.getChannelByUniqueName(contact).then(function (channel) {\n          // first fetch existing messages\n          channel.getMessages(msgsPerPage).then(function (paginator) {\n            var messages = [];\n            paginator.items.forEach(function (msg) {\n              messages.push(msg);\n            });\n\n            _this.props.setMsgCachePage(contact, messages, paginator);\n\n            _this.props.setUnreadMsgs(channel, contact);\n          }); // then subscribe for receiving new messages\n\n          if (!_this.msgAddedHandlerTracker[contact]) {\n            _this.msgAddedHandlerTracker[contact] = true;\n            channel.on('messageAdded', _this.msgAddedHandler.bind(null, contact));\n          }\n        });\n      }\n    };\n\n    _this.updateNewPhoneNumber = function (e) {\n      if (e && e.target) {\n        _this.setState({\n          newPhoneNumber: e.target.value\n        });\n      } else if (e === '') {\n        // for resets after sending message in MsgComposer\n        _this.setState({\n          newPhoneNumber: ''\n        });\n      }\n    };\n\n    _this.msgAddedHandlerTracker = {};\n    _this.fetchTracker = {};\n    _this.state = {\n      selectedContact: null,\n      newPhoneNumber: ''\n    };\n    return _this;\n  }\n\n  _createClass(CanvasMsg, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      if (this.props.channelList) {\n        Object.keys(this.props.channelList).forEach(function (contact) {\n          _this2.fetchMsgsForContact(contact);\n        });\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var _this3 = this;\n\n      if (this.props.channelList) {\n        Object.keys(this.props.channelList).forEach(function (contact) {\n          _this3.fetchMsgsForContact(contact);\n        });\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var _this4 = this;\n\n      // remove all 'messageAdded' event listeners\n      Object.keys(this.msgAddedHandlerTracker).forEach(function (contact) {\n        _this4.props.client.getChannelByUniqueName(contact).then(function (channel) {\n          channel.removeAllListeners('messageAdded');\n        });\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (this.state.selectedContact) {\n        return /*#__PURE__*/React.createElement(Canvas, {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 155,\n            columnNumber: 9\n          }\n        }, /*#__PURE__*/React.createElement(MsgContactHeader, {\n          key: \"msgContactHeader\",\n          back: this.selectContact.bind(null, null),\n          selectedContact: this.state.selectedContact,\n          newPhoneNumber: this.state.newPhoneNumber,\n          updateNewPhoneNumber: this.updateNewPhoneNumber,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 156,\n            columnNumber: 11\n          }\n        }), /*#__PURE__*/React.createElement(MsgList, {\n          key: \"msgList\",\n          messages: this.props.msgCache[this.state.selectedContact],\n          fetchAnotherPage: this.fetchAnotherPage,\n          selectedContact: this.state.selectedContact,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 163,\n            columnNumber: 11\n          }\n        }), /*#__PURE__*/React.createElement(MsgComposer, {\n          key: \"msgComposer\",\n          secret: this.props.secret,\n          selectedContact: this.state.selectedContact,\n          selectContact: this.selectContact,\n          newPhoneNumber: this.state.newPhoneNumber,\n          updateNewPhoneNumber: this.updateNewPhoneNumber,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 169,\n            columnNumber: 11\n          }\n        }));\n      } else {\n        if (this.props.channelList === null) {\n          return /*#__PURE__*/React.createElement(Canvas, {\n            __self: this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 182,\n              columnNumber: 11\n            }\n          }, /*#__PURE__*/React.createElement(Spinner, {\n            text: \"Loading contacts...\",\n            __self: this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 183,\n              columnNumber: 13\n            }\n          }));\n        } else {\n          return /*#__PURE__*/React.createElement(Canvas, {\n            __self: this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 188,\n              columnNumber: 11\n            }\n          }, /*#__PURE__*/React.createElement(MsgContactAdd, {\n            key: \"msgContactAdd\",\n            selectContact: this.selectContact,\n            __self: this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 189,\n              columnNumber: 13\n            }\n          }), /*#__PURE__*/React.createElement(MsgContactList, {\n            key: \"msgContactList\",\n            msgUnreadsCache: this.props.msgUnreadsCache,\n            client: this.props.client,\n            channelList: this.props.channelList,\n            selectContact: this.selectContact,\n            deleteThread: this.deleteThread,\n            msgCache: this.props.msgCache,\n            unreadsCache: this.props.unreadsCache,\n            __self: this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 193,\n              columnNumber: 13\n            }\n          }));\n        }\n      }\n    }\n  }]);\n\n  return CanvasMsg;\n}(Component);\n\nexport { CanvasMsg as default };\nvar Canvas = styled.div(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n  flex-grow: 1;\\n\\n  display: flex;\\n  flex-direction: column;\\n  flex-wrap: nowrap;\\n  align-items: stretch;\\n  height: 100vh;\\n  max-width: 440px;\\n  position: relative;\\n  overflow-x: hidden;\\n\"])));","map":{"version":3,"sources":["/root/twilio-phone-client/src/components/MsgCanvas.js"],"names":["React","Component","styled","MsgContactList","MsgContactAdd","MsgList","MsgComposer","Spinner","MsgContactHeader","msgsPerPage","CanvasMsg","props","selectContact","selectedContact","setState","fetchMsgsForContact","client","getChannelByUniqueName","then","channel","setAllMessagesConsumed","setUnreadsCache","deleteThread","contact","delete","fetchTracker","msgAddedHandlerTracker","fetchAnotherPage","Promise","resolve","reject","state","paginator","msgPgtrCache","hasPrevPage","prevPage","messages","items","forEach","msg","push","addMsgCachePage","msgAddedHandler","addMsgCacheMsg","author","channelList","updateLastConsumedMessageIndex","index","setUnreadMsgs","msgCache","undefined","getMessages","setMsgCachePage","on","bind","updateNewPhoneNumber","e","target","newPhoneNumber","value","Object","keys","removeAllListeners","secret","msgUnreadsCache","unreadsCache","Canvas","div"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport styled from 'styled-components';\n\nimport MsgContactList from './MsgContactList';\nimport MsgContactAdd from './MsgContactAdd';\nimport MsgList from './MsgList';\nimport MsgComposer from './MsgComposer';\nimport Spinner from './Spinner';\nimport MsgContactHeader from './MsgContactHeader';\n\nconst msgsPerPage = 30;\n\nexport default class CanvasMsg extends Component {\n  constructor(props) {\n    super(props);\n    this.msgAddedHandlerTracker = {};\n    this.fetchTracker = {};\n    this.state = {\n      selectedContact: null,\n      newPhoneNumber: ''\n    };\n  }\n\n  selectContact = (selectedContact) => {\n    this.setState({ selectedContact });\n    if (selectedContact !== null) {\n      this.fetchMsgsForContact(selectedContact); // async fetch data for selected contact\n      this.props.client\n        .getChannelByUniqueName(selectedContact)\n        .then((channel) => {\n          // mark all messages as read\n          channel.setAllMessagesConsumed().then(() => {\n            // when done, update cache as well\n            this.props.setUnreadsCache(selectedContact, 0);\n          });\n        });\n    }\n  };\n\n  deleteThread = (contact) => {\n    this.props.client.getChannelByUniqueName(contact).then((channel) => {\n      // mark all messages as read\n      channel.delete();\n      this.fetchTracker[contact] = false;\n      delete this.msgAddedHandlerTracker[contact];\n    });\n  };\n\n  fetchAnotherPage = () => {\n    return new Promise((resolve, reject) => {\n      const contact = this.state.selectedContact;\n      if (contact === 'new') {\n        return;\n      }\n      const paginator = this.props.msgPgtrCache[contact];\n      if (!paginator.hasPrevPage) {\n        reject('No more messages.');\n      } else {\n        paginator.prevPage().then((paginator) => {\n          let messages = [];\n          paginator.items.forEach((msg) => {\n            messages.push(msg);\n          });\n          this.props.addMsgCachePage(contact, messages, paginator);\n          resolve();\n        });\n      }\n    });\n  };\n\n  componentDidMount() {\n    if (this.props.channelList) {\n      Object.keys(this.props.channelList).forEach((contact) => {\n        this.fetchMsgsForContact(contact);\n      });\n    }\n  }\n\n  componentDidUpdate() {\n    if (this.props.channelList) {\n      Object.keys(this.props.channelList).forEach((contact) => {\n        this.fetchMsgsForContact(contact);\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    // remove all 'messageAdded' event listeners\n    Object.keys(this.msgAddedHandlerTracker).forEach((contact) => {\n      this.props.client.getChannelByUniqueName(contact).then((channel) => {\n        channel.removeAllListeners('messageAdded');\n      });\n    });\n  }\n\n  msgAddedHandler = (contact, msg) => {\n    this.props.addMsgCacheMsg(contact, msg);\n    if (\n      // if we're the originator of the message, it means we've read it\n      // (this ensures messages originating from this client don't count as unread)\n      msg.state.author === 'us' ||\n      // or same thing if user has the thread the message belongs to currently opened\n      contact === this.state.selectedContact\n    ) {\n      this.props.channelList[contact]\n        .updateLastConsumedMessageIndex(msg.state.index)\n        .then(() => {\n          this.props.setUnreadMsgs(this.props.channelList[contact], contact);\n        });\n    } else {\n      this.props.setUnreadMsgs(this.props.channelList[contact], contact);\n    }\n  };\n\n  fetchMsgsForContact = (contact) => {\n    if (contact === 'new') {\n      return;\n    }\n    if (\n      this.props.msgCache[contact] === undefined &&\n      !this.fetchTracker[contact]\n    ) {\n      this.fetchTracker[contact] = true; // prevent double-fetching\n      this.props.client.getChannelByUniqueName(contact).then((channel) => {\n        // first fetch existing messages\n        channel.getMessages(msgsPerPage).then((paginator) => {\n          let messages = [];\n          paginator.items.forEach((msg) => {\n            messages.push(msg);\n          });\n          this.props.setMsgCachePage(contact, messages, paginator);\n          this.props.setUnreadMsgs(channel, contact);\n        });\n        // then subscribe for receiving new messages\n        if (!this.msgAddedHandlerTracker[contact]) {\n          this.msgAddedHandlerTracker[contact] = true;\n          channel.on('messageAdded', this.msgAddedHandler.bind(null, contact));\n        }\n      });\n    }\n  };\n\n  updateNewPhoneNumber = (e) => {\n    if (e && e.target) {\n      this.setState({ newPhoneNumber: e.target.value });\n    } else if (e === '') {\n      // for resets after sending message in MsgComposer\n      this.setState({ newPhoneNumber: '' });\n    }\n  };\n\n  render() {\n    if (this.state.selectedContact) {\n      return (\n        <Canvas>\n          <MsgContactHeader\n            key=\"msgContactHeader\"\n            back={this.selectContact.bind(null, null)}\n            selectedContact={this.state.selectedContact}\n            newPhoneNumber={this.state.newPhoneNumber}\n            updateNewPhoneNumber={this.updateNewPhoneNumber}\n          />\n          <MsgList\n            key=\"msgList\"\n            messages={this.props.msgCache[this.state.selectedContact]}\n            fetchAnotherPage={this.fetchAnotherPage}\n            selectedContact={this.state.selectedContact}\n          />\n          <MsgComposer\n            key=\"msgComposer\"\n            secret={this.props.secret}\n            selectedContact={this.state.selectedContact}\n            selectContact={this.selectContact}\n            newPhoneNumber={this.state.newPhoneNumber}\n            updateNewPhoneNumber={this.updateNewPhoneNumber}\n          />\n        </Canvas>\n      );\n    } else {\n      if (this.props.channelList === null) {\n        return (\n          <Canvas>\n            <Spinner text=\"Loading contacts...\" />\n          </Canvas>\n        );\n      } else {\n        return (\n          <Canvas>\n            <MsgContactAdd\n              key=\"msgContactAdd\"\n              selectContact={this.selectContact}\n            />\n            <MsgContactList\n              key=\"msgContactList\"\n              msgUnreadsCache={this.props.msgUnreadsCache}\n              client={this.props.client}\n              channelList={this.props.channelList}\n              selectContact={this.selectContact}\n              deleteThread={this.deleteThread}\n              msgCache={this.props.msgCache}\n              unreadsCache={this.props.unreadsCache}\n            />\n          </Canvas>\n        );\n      }\n    }\n  }\n}\n\nconst Canvas = styled.div`\n  flex-grow: 1;\n\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  align-items: stretch;\n  height: 100vh;\n  max-width: 440px;\n  position: relative;\n  overflow-x: hidden;\n`;\n"]},"metadata":{},"sourceType":"module"}