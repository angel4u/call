{"ast":null,"code":"\"use strict\";\n\nvar _assertThisInitialized = require(\"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _get = require(\"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _regeneratorRuntime = require(\"/root/twilio-phone-client/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SyncDocumentImpl = exports.SyncDocument = void 0;\n\nvar syncerror_1 = require(\"./utils/syncerror\");\n\nvar sanitize_1 = require(\"./utils/sanitize\");\n\nvar logger_1 = require(\"./utils/logger\");\n\nvar entity_1 = require(\"./entity\");\n\nvar mergingqueue_1 = require(\"./mergingqueue\");\n\nvar closeable_1 = require(\"./closeable\");\n\nvar SyncDocumentImpl = /*#__PURE__*/function (_entity_1$SyncEntity) {\n  _inherits(SyncDocumentImpl, _entity_1$SyncEntity);\n\n  var _super = _createSuper(SyncDocumentImpl);\n\n  /**\n   * @private\n   */\n  function SyncDocumentImpl(services, descriptor, removalHandler) {\n    var _this;\n\n    _classCallCheck(this, SyncDocumentImpl);\n\n    _this = _super.call(this, services, removalHandler);\n    _this.isDeleted = false;\n\n    var updateRequestReducer = function updateRequestReducer(acc, input) {\n      return typeof input.ttl === 'number' ? {\n        ttl: input.ttl\n      } : acc;\n    };\n\n    _this.updateMergingQueue = new mergingqueue_1.MergingQueue(updateRequestReducer);\n    _this.descriptor = descriptor;\n    _this.descriptor.data = _this.descriptor.data || {};\n    _this.descriptor.date_updated = new Date(_this.descriptor.date_updated);\n    return _this;\n  } // private props\n\n\n  _createClass(SyncDocumentImpl, [{\n    key: \"_update\",\n\n    /**\n     * Update data entity with new data\n     * @private\n     */\n    value: function _update(update) {\n      update.date_created = new Date(update.date_created);\n\n      switch (update.type) {\n        case 'document_updated':\n          if (update.id > this.lastEventId) {\n            this.descriptor.last_event_id = update.id;\n            this.descriptor.revision = update.document_revision;\n            this.descriptor.date_updated = update.date_created;\n            this.descriptor.data = update.document_data;\n            this.broadcastEventToListeners('updated', {\n              value: update.document_data,\n              isLocal: false\n            });\n            this.services.storage.update(this.type, this.sid, this.uniqueName, {\n              last_event_id: update.id,\n              revision: update.document_revision,\n              date_updated: update.date_created,\n              data: update.document_data\n            });\n          } else {\n            logger_1.default.trace('Document update skipped, current:', this.lastEventId, ', remote:', update.id);\n          }\n\n          break;\n\n        case 'document_removed':\n          this.onRemoved(false);\n          break;\n      }\n    }\n  }, {\n    key: \"set\",\n    value: function () {\n      var _set = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(value, metadataUpdates) {\n        var _this2 = this;\n\n        var input;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                input = metadataUpdates || {};\n                sanitize_1.validateOptionalTtl(input.ttl);\n                return _context.abrupt(\"return\", this.updateMergingQueue.squashAndAdd(input, function (input) {\n                  return _this2._setUnconditionally(value, input.ttl);\n                }));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function set(_x, _x2) {\n        return _set.apply(this, arguments);\n      }\n\n      return set;\n    }()\n  }, {\n    key: \"mutate\",\n    value: function () {\n      var _mutate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(mutator, metadataUpdates) {\n        var _this3 = this;\n\n        var input;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                input = metadataUpdates || {};\n                sanitize_1.validateOptionalTtl(input.ttl);\n                return _context2.abrupt(\"return\", this.updateMergingQueue.add(input, function (input) {\n                  return _this3._setWithIfMatch(mutator, input.ttl);\n                }));\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function mutate(_x3, _x4) {\n        return _mutate.apply(this, arguments);\n      }\n\n      return mutate;\n    }()\n  }, {\n    key: \"update\",\n    value: function () {\n      var _update2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(obj, metadataUpdates) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.mutate(function (remote) {\n                  return Object.assign(remote, obj);\n                }, metadataUpdates));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function update(_x5, _x6) {\n        return _update2.apply(this, arguments);\n      }\n\n      return update;\n    }()\n  }, {\n    key: \"setTtl\",\n    value: function () {\n      var _setTtl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(ttl) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                sanitize_1.validateMandatoryTtl(ttl);\n                _context4.next = 3;\n                return this._postUpdateToServer({\n                  ttl: ttl\n                });\n\n              case 3:\n                response = _context4.sent;\n                this.descriptor.date_expires = response.date_expires;\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function setTtl(_x7) {\n        return _setTtl.apply(this, arguments);\n      }\n\n      return setTtl;\n    }()\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_setUnconditionally\",\n    value: function () {\n      var _setUnconditionally2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(value, ttl) {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this._postUpdateToServer({\n                  data: value,\n                  revision: undefined,\n                  ttl: ttl\n                });\n\n              case 2:\n                result = _context5.sent;\n\n                this._handleSuccessfulUpdateResult(result);\n\n                return _context5.abrupt(\"return\", this.value);\n\n              case 5:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _setUnconditionally(_x8, _x9) {\n        return _setUnconditionally2.apply(this, arguments);\n      }\n\n      return _setUnconditionally;\n    }()\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_setWithIfMatch\",\n    value: function () {\n      var _setWithIfMatch2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(mutatorFunction, ttl) {\n        var data, revision, result;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                data = mutatorFunction(sanitize_1.deepClone(this.value));\n\n                if (!data) {\n                  _context6.next = 22;\n                  break;\n                }\n\n                revision = this.revision;\n                _context6.prev = 3;\n                _context6.next = 6;\n                return this._postUpdateToServer({\n                  data: data,\n                  revision: revision,\n                  ttl: ttl\n                });\n\n              case 6:\n                result = _context6.sent;\n\n                this._handleSuccessfulUpdateResult(result);\n\n                return _context6.abrupt(\"return\", this.value);\n\n              case 11:\n                _context6.prev = 11;\n                _context6.t0 = _context6[\"catch\"](3);\n\n                if (!(_context6.t0.status === 412)) {\n                  _context6.next = 19;\n                  break;\n                }\n\n                _context6.next = 16;\n                return this._softSync();\n\n              case 16:\n                return _context6.abrupt(\"return\", this._setWithIfMatch(mutatorFunction));\n\n              case 19:\n                throw _context6.t0;\n\n              case 20:\n                _context6.next = 23;\n                break;\n\n              case 22:\n                return _context6.abrupt(\"return\", this.value);\n\n              case 23:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[3, 11]]);\n      }));\n\n      function _setWithIfMatch(_x10, _x11) {\n        return _setWithIfMatch2.apply(this, arguments);\n      }\n\n      return _setWithIfMatch;\n    }()\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_handleSuccessfulUpdateResult\",\n    value: function _handleSuccessfulUpdateResult(result) {\n      if (result.last_event_id > this.descriptor.last_event_id) {\n        // Ignore returned value if we already got a newer one\n        this.descriptor.revision = result.revision;\n        this.descriptor.data = result.data;\n        this.descriptor.last_event_id = result.last_event_id;\n        this.descriptor.date_expires = result.date_expires;\n        this.descriptor.date_updated = new Date(result.date_updated);\n        this.services.storage.update(this.type, this.sid, this.uniqueName, {\n          last_event_id: result.last_event_id,\n          revision: result.revision,\n          date_updated: result.date_updated,\n          data: result.data\n        });\n        this.broadcastEventToListeners('updated', {\n          value: this.value,\n          isLocal: true\n        });\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_postUpdateToServer\",\n    value: function () {\n      var _postUpdateToServer2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(request) {\n        var requestBody, ifMatch, response;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (this.isDeleted) {\n                  _context7.next = 17;\n                  break;\n                }\n\n                requestBody = {\n                  data: request.data\n                };\n\n                if (request.ttl !== undefined) {\n                  requestBody.ttl = request.ttl;\n                }\n\n                ifMatch = request.revision;\n                _context7.prev = 4;\n                _context7.next = 7;\n                return this.services.network.post(this.uri, requestBody, ifMatch);\n\n              case 7:\n                response = _context7.sent;\n                return _context7.abrupt(\"return\", {\n                  revision: response.body.revision,\n                  data: request.data,\n                  last_event_id: response.body.last_event_id,\n                  date_updated: response.body.date_updated,\n                  date_expires: response.body.date_expires\n                });\n\n              case 11:\n                _context7.prev = 11;\n                _context7.t0 = _context7[\"catch\"](4);\n\n                if (_context7.t0.status === 404) {\n                  this.onRemoved(false);\n                }\n\n                throw _context7.t0;\n\n              case 15:\n                _context7.next = 18;\n                break;\n\n              case 17:\n                return _context7.abrupt(\"return\", Promise.reject(new syncerror_1.SyncError('The Document has been removed', 404, 54100)));\n\n              case 18:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[4, 11]]);\n      }));\n\n      function _postUpdateToServer(_x12) {\n        return _postUpdateToServer2.apply(this, arguments);\n      }\n\n      return _postUpdateToServer;\n    }()\n    /**\n     * Get new data from server\n     * @private\n     */\n\n  }, {\n    key: \"_softSync\",\n    value: function () {\n      var _softSync2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var _this4 = this;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                return _context8.abrupt(\"return\", this.services.network.get(this.uri).then(function (response) {\n                  var event = {\n                    type: 'document_updated',\n                    id: response.body.last_event_id,\n                    document_revision: response.body.revision,\n                    document_data: response.body.data,\n                    date_created: response.body.date_updated\n                  };\n\n                  _this4._update(event);\n\n                  return _this4;\n                }).catch(function (err) {\n                  if (err.status === 404) {\n                    _this4.onRemoved(false);\n                  } else {\n                    logger_1.default.error(\"Can't get updates for \".concat(_this4.sid, \":\"), err);\n                  }\n                }));\n\n              case 1:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function _softSync() {\n        return _softSync2.apply(this, arguments);\n      }\n\n      return _softSync;\n    }()\n  }, {\n    key: \"onRemoved\",\n    value: function onRemoved(locally) {\n      if (this.isDeleted) {\n        return;\n      } else {\n        this.isDeleted = true;\n\n        this._unsubscribe();\n\n        this.removalHandler(this.type, this.sid, this.uniqueName);\n        this.broadcastEventToListeners('removed', {\n          isLocal: locally\n        });\n      }\n    }\n  }, {\n    key: \"removeDocument\",\n    value: function () {\n      var _removeDocument = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (this.isDeleted) {\n                  _context9.next = 6;\n                  break;\n                }\n\n                _context9.next = 3;\n                return this.services.network.delete(this.uri);\n\n              case 3:\n                this.onRemoved(true);\n                _context9.next = 7;\n                break;\n\n              case 6:\n                return _context9.abrupt(\"return\", Promise.reject(new syncerror_1.SyncError('The Document has been removed', 404, 54100)));\n\n              case 7:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function removeDocument() {\n        return _removeDocument.apply(this, arguments);\n      }\n\n      return removeDocument;\n    }()\n  }, {\n    key: \"uri\",\n    get: function get() {\n      return this.descriptor.url;\n    }\n  }, {\n    key: \"revision\",\n    get: function get() {\n      return this.descriptor.revision;\n    }\n  }, {\n    key: \"lastEventId\",\n    get: function get() {\n      return this.descriptor.last_event_id;\n    }\n  }, {\n    key: \"dateExpires\",\n    get: function get() {\n      return this.descriptor.date_expires;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return 'document';\n    } // below properties are specific to Insights only\n\n  }, {\n    key: \"indexName\",\n    get: function get() {\n      return undefined;\n    }\n  }, {\n    key: \"queryString\",\n    get: function get() {\n      return undefined;\n    } // public props, documented along with class description\n\n  }, {\n    key: \"sid\",\n    get: function get() {\n      return this.descriptor.sid;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.descriptor.data;\n    }\n  }, {\n    key: \"dateUpdated\",\n    get: function get() {\n      return this.descriptor.date_updated;\n    }\n  }, {\n    key: \"uniqueName\",\n    get: function get() {\n      return this.descriptor.unique_name || null;\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'document';\n    }\n  }]);\n\n  return SyncDocumentImpl;\n}(entity_1.SyncEntity);\n\nexports.SyncDocumentImpl = SyncDocumentImpl;\n/**\n * @class\n * @alias Document\n * @classdesc Represents a Sync Document, the contents of which is a single JSON object.\n * Use the {@link Client#document} method to obtain a reference to a Sync Document.\n * @property {String} sid The immutable identifier of this document, assigned by the system.\n * @property {String} [uniqueName=null] An optional immutable identifier that may be assigned by the programmer\n * to this document during creation. Globally unique among other Documents.\n * @property {Date} dateUpdated Date when the Document was last updated.\n * @property {Object} value The contents of this document.\n *\n * @fires Document#removed\n * @fires Document#updated\n */\n\nvar SyncDocument = /*#__PURE__*/function (_closeable_1$default) {\n  _inherits(SyncDocument, _closeable_1$default);\n\n  var _super2 = _createSuper(SyncDocument);\n\n  function SyncDocument(syncDocumentImpl) {\n    var _this5;\n\n    _classCallCheck(this, SyncDocument);\n\n    _this5 = _super2.call(this);\n    _this5.syncDocumentImpl = syncDocumentImpl;\n\n    _this5.syncDocumentImpl.attach(_assertThisInitialized(_this5));\n\n    return _this5;\n  } // private props\n\n\n  _createClass(SyncDocument, [{\n    key: \"set\",\n\n    /**\n     * Assign new contents to this document. The current value will be overwritten.\n     * @param {Object} value The new contents to assign.\n     * @param {Document#Metadata} [metadataUpdates] New document metadata.\n     * @returns {Promise<Object>} A promise resolving to the new value of the document.\n     * @public\n     * @example\n     * // Say, the Document value is { name: 'John Smith', age: 34 }\n     * document.set({ name: 'Barbara Oaks' }, { ttl: 86400 })\n     *   .then(function(newValue) {\n     *     // Now the Document value is { name: 'Barbara Oaks' }\n     *     console.log('Document set() successful, new value:', newValue);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Document set() failed', error);\n     *   });\n     */\n    value: function () {\n      var _set2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(value, metadataUpdates) {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context10.abrupt(\"return\", this.syncDocumentImpl.set(value, metadataUpdates));\n\n              case 2:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function set(_x13, _x14) {\n        return _set2.apply(this, arguments);\n      }\n\n      return set;\n    }()\n    /**\n     * Schedules a modification to this document that will apply a mutation function.\n     * @param {Document~Mutator} mutator A function that outputs a new value based on the existing value.\n     * May be called multiple times, particularly if this Document is modified concurrently by remote code.\n     * If the mutation ultimately succeeds, the Document will have made the particular transition described\n     * by this function.\n     * @param {Document#Metadata} [metadataUpdates] New document metadata.\n     * @return {Promise<Object>} Resolves with the most recent Document state, whether the output of a\n     *    successful mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>).\n     * @public\n     * @example\n     * var mutatorFunction = function(currentValue) {\n     *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\n     *     return currentValue;\n     * };\n     * document.mutate(mutatorFunction, { ttl: 86400 }))\n     *   .then(function(newValue) {\n     *     console.log('Document mutate() successful, new value:', newValue);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Document mutate() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"mutate\",\n    value: function () {\n      var _mutate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(mutator, metadataUpdates) {\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context11.abrupt(\"return\", this.syncDocumentImpl.mutate(mutator, metadataUpdates));\n\n              case 2:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function mutate(_x15, _x16) {\n        return _mutate2.apply(this, arguments);\n      }\n\n      return mutate;\n    }()\n    /**\n     * Modify a document by appending new fields (or by overwriting existing ones) with the values from the provided Object.\n     * This is equivalent to\n     * <pre>\n     * document.mutate(function(currentValue) {\n     *   return Object.assign(currentValue, obj));\n     * });\n     * </pre>\n     * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.\n     * @param {Document#Metadata} [metadataUpdates] New document metadata.\n     * @return {Promise<Object>} A promise resolving to the new value of the document.\n     * @public\n     * @example\n     * // Say, the Document value is { name: 'John Smith' }\n     * document.update({ age: 34 }, { ttl: 86400 })\n     *   .then(function(newValue) {\n     *     // Now the Document value is { name: 'John Smith', age: 34 }\n     *     console.log('Document update() successful, new value:', newValue);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Document update() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"update\",\n    value: function () {\n      var _update3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(obj, metadataUpdates) {\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context12.abrupt(\"return\", this.syncDocumentImpl.update(obj, metadataUpdates));\n\n              case 2:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function update(_x17, _x18) {\n        return _update3.apply(this, arguments);\n      }\n\n      return update;\n    }()\n    /**\n     * Update the time-to-live of the document.\n     * @param {Number} ttl Specifies the time-to-live in seconds after which the document is subject to automatic deletion. The value 0 means infinity.\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n     * @public\n     * @example\n     * document.setTtl(3600)\n     *   .then(function() {\n     *     console.log('Document setTtl() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Document setTtl() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"setTtl\",\n    value: function () {\n      var _setTtl2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(ttl) {\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context13.abrupt(\"return\", this.syncDocumentImpl.setTtl(ttl));\n\n              case 2:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function setTtl(_x19) {\n        return _setTtl2.apply(this, arguments);\n      }\n\n      return setTtl;\n    }()\n    /**\n     * Delete a document.\n     * @return {Promise<void>} A promise which resolves if (and only if) the document is ultimately deleted.\n     * @public\n     * @example\n     * document.removeDocument()\n     *   .then(function() {\n     *     console.log('Document removeDocument() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Document removeDocument() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"removeDocument\",\n    value: function () {\n      var _removeDocument2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context14.abrupt(\"return\", this.syncDocumentImpl.removeDocument());\n\n              case 2:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function removeDocument() {\n        return _removeDocument2.apply(this, arguments);\n      }\n\n      return removeDocument;\n    }()\n    /**\n     * Conclude work with the document instance and remove all event listeners attached to it.\n     * Any subsequent operation on this object will be rejected with error.\n     * Other local copies of this document will continue operating and receiving events normally.\n     * @public\n     * @example\n     * document.close();\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      _get(_getPrototypeOf(SyncDocument.prototype), \"close\", this).call(this);\n\n      this.syncDocumentImpl.detach(this.listenerUuid);\n    }\n  }, {\n    key: \"uri\",\n    get: function get() {\n      return this.syncDocumentImpl.uri;\n    }\n  }, {\n    key: \"revision\",\n    get: function get() {\n      return this.syncDocumentImpl.revision;\n    }\n  }, {\n    key: \"lastEventId\",\n    get: function get() {\n      return this.syncDocumentImpl.lastEventId;\n    }\n  }, {\n    key: \"dateExpires\",\n    get: function get() {\n      return this.syncDocumentImpl.dateExpires;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return SyncDocumentImpl.type;\n    } // public props, documented along with class description\n\n  }, {\n    key: \"sid\",\n    get: function get() {\n      return this.syncDocumentImpl.sid;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.syncDocumentImpl.value;\n    }\n  }, {\n    key: \"dateUpdated\",\n    get: function get() {\n      return this.syncDocumentImpl.dateUpdated;\n    }\n  }, {\n    key: \"uniqueName\",\n    get: function get() {\n      return this.syncDocumentImpl.uniqueName;\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return SyncDocumentImpl.type;\n    }\n  }]);\n\n  return SyncDocument;\n}(closeable_1.default);\n\nexports.SyncDocument = SyncDocument;\nexports.default = SyncDocument;\n/**\n * Contains Document metadata.\n * @typedef {Object} Document#Metadata\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the document is subject to automatic deletion.\n * The value 0 means infinity.\n */\n\n/**\n * Applies a transformation to the document value.\n * @callback Document~Mutator\n * @param {Object} currentValue The current value of the document in the cloud.\n * @return {Object} The desired new value for the document or <code>null</code> to gracefully cancel the mutation.\n */\n\n/**\n * Fired when the document is removed, whether the remover was local or remote.\n * @event Document#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if document was removed by local actor, 'false' otherwise.\n * @example\n * document.on('removed', function(args) {\n *   console.log('Document ' + document.sid + ' was removed');\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when the document's contents have changed, whether the updater was local or remote.\n * @event Document#updated\n * @param {Object} args Arguments provided with the event.\n * @param {Object} args.value A snapshot of the document's new contents.\n * @param {Boolean} args.isLocal Equals 'true' if document was updated by local actor, 'false' otherwise.\n * @example\n * document.on('updated', function(args) {\n *   console.log('Document ' + document.sid + ' was updated');\n *   console.log('args.value: ', args.value);\n *   console.log('args.isLocal: ', args.isLocal);\n * });\n */","map":{"version":3,"sources":["/root/twilio-phone-client/node_modules/twilio-sync/lib/syncdocument.js"],"names":["Object","defineProperty","exports","value","SyncDocumentImpl","SyncDocument","syncerror_1","require","sanitize_1","logger_1","entity_1","mergingqueue_1","closeable_1","services","descriptor","removalHandler","isDeleted","updateRequestReducer","acc","input","ttl","updateMergingQueue","MergingQueue","data","date_updated","Date","update","date_created","type","id","lastEventId","last_event_id","revision","document_revision","document_data","broadcastEventToListeners","isLocal","storage","sid","uniqueName","default","trace","onRemoved","metadataUpdates","validateOptionalTtl","squashAndAdd","_setUnconditionally","mutator","add","_setWithIfMatch","obj","mutate","remote","assign","validateMandatoryTtl","_postUpdateToServer","response","date_expires","undefined","result","_handleSuccessfulUpdateResult","mutatorFunction","deepClone","status","_softSync","request","requestBody","ifMatch","network","post","uri","body","Promise","reject","SyncError","get","then","event","_update","catch","err","error","locally","_unsubscribe","delete","url","unique_name","SyncEntity","syncDocumentImpl","attach","ensureNotClosed","set","setTtl","removeDocument","detach","listenerUuid","dateExpires","dateUpdated"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,gBAAR,GAA2BF,OAAO,CAACG,YAAR,GAAuB,KAAK,CAAvD;;AACA,IAAMC,WAAW,GAAGC,OAAO,CAAC,mBAAD,CAA3B;;AACA,IAAMC,UAAU,GAAGD,OAAO,CAAC,kBAAD,CAA1B;;AACA,IAAME,QAAQ,GAAGF,OAAO,CAAC,gBAAD,CAAxB;;AACA,IAAMG,QAAQ,GAAGH,OAAO,CAAC,UAAD,CAAxB;;AACA,IAAMI,cAAc,GAAGJ,OAAO,CAAC,gBAAD,CAA9B;;AACA,IAAMK,WAAW,GAAGL,OAAO,CAAC,aAAD,CAA3B;;IACMH,gB;;;;;AACF;AACJ;AACA;AACI,4BAAYS,QAAZ,EAAsBC,UAAtB,EAAkCC,cAAlC,EAAkD;AAAA;;AAAA;;AAC9C,8BAAMF,QAAN,EAAgBE,cAAhB;AACA,UAAKC,SAAL,GAAiB,KAAjB;;AACA,QAAMC,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACC,GAAD,EAAMC,KAAN;AAAA,aAAiB,OAAOA,KAAK,CAACC,GAAb,KAAqB,QAAtB,GAAkC;AAAEA,QAAAA,GAAG,EAAED,KAAK,CAACC;AAAb,OAAlC,GACvCF,GADuB;AAAA,KAA7B;;AAEA,UAAKG,kBAAL,GAA0B,IAAIV,cAAc,CAACW,YAAnB,CAAgCL,oBAAhC,CAA1B;AACA,UAAKH,UAAL,GAAkBA,UAAlB;AACA,UAAKA,UAAL,CAAgBS,IAAhB,GAAuB,MAAKT,UAAL,CAAgBS,IAAhB,IAAwB,EAA/C;AACA,UAAKT,UAAL,CAAgBU,YAAhB,GAA+B,IAAIC,IAAJ,CAAS,MAAKX,UAAL,CAAgBU,YAAzB,CAA/B;AAR8C;AASjD,G,CACD;;;;;;AAuCA;AACJ;AACA;AACA;4BACYE,M,EAAQ;AACZA,MAAAA,MAAM,CAACC,YAAP,GAAsB,IAAIF,IAAJ,CAASC,MAAM,CAACC,YAAhB,CAAtB;;AACA,cAAQD,MAAM,CAACE,IAAf;AACI,aAAK,kBAAL;AACI,cAAIF,MAAM,CAACG,EAAP,GAAY,KAAKC,WAArB,EAAkC;AAC9B,iBAAKhB,UAAL,CAAgBiB,aAAhB,GAAgCL,MAAM,CAACG,EAAvC;AACA,iBAAKf,UAAL,CAAgBkB,QAAhB,GAA2BN,MAAM,CAACO,iBAAlC;AACA,iBAAKnB,UAAL,CAAgBU,YAAhB,GAA+BE,MAAM,CAACC,YAAtC;AACA,iBAAKb,UAAL,CAAgBS,IAAhB,GAAuBG,MAAM,CAACQ,aAA9B;AACA,iBAAKC,yBAAL,CAA+B,SAA/B,EAA0C;AAAEhC,cAAAA,KAAK,EAAEuB,MAAM,CAACQ,aAAhB;AAA+BE,cAAAA,OAAO,EAAE;AAAxC,aAA1C;AACA,iBAAKvB,QAAL,CAAcwB,OAAd,CAAsBX,MAAtB,CAA6B,KAAKE,IAAlC,EAAwC,KAAKU,GAA7C,EAAkD,KAAKC,UAAvD,EAAmE;AAC/DR,cAAAA,aAAa,EAAEL,MAAM,CAACG,EADyC;AAE/DG,cAAAA,QAAQ,EAAEN,MAAM,CAACO,iBAF8C;AAG/DT,cAAAA,YAAY,EAAEE,MAAM,CAACC,YAH0C;AAI/DJ,cAAAA,IAAI,EAAEG,MAAM,CAACQ;AAJkD,aAAnE;AAMH,WAZD,MAaK;AACDzB,YAAAA,QAAQ,CAAC+B,OAAT,CAAiBC,KAAjB,CAAuB,mCAAvB,EAA4D,KAAKX,WAAjE,EAA8E,WAA9E,EAA2FJ,MAAM,CAACG,EAAlG;AACH;;AACD;;AACJ,aAAK,kBAAL;AACI,eAAKa,SAAL,CAAe,KAAf;AACA;AArBR;AAuBH;;;;2FACSvC,K,EAAOwC,e;;;;;;;;AACPxB,gBAAAA,K,GAAQwB,eAAe,IAAI,E;AACjCnC,gBAAAA,UAAU,CAACoC,mBAAX,CAA+BzB,KAAK,CAACC,GAArC;iDACO,KAAKC,kBAAL,CAAwBwB,YAAxB,CAAqC1B,KAArC,EAA4C,UAAAA,KAAK;AAAA,yBAAI,MAAI,CAAC2B,mBAAL,CAAyB3C,KAAzB,EAAgCgB,KAAK,CAACC,GAAtC,CAAJ;AAAA,iBAAjD,C;;;;;;;;;;;;;;;;;;;+FAEE2B,O,EAASJ,e;;;;;;;;AACZxB,gBAAAA,K,GAAQwB,eAAe,IAAI,E;AACjCnC,gBAAAA,UAAU,CAACoC,mBAAX,CAA+BzB,KAAK,CAACC,GAArC;kDACO,KAAKC,kBAAL,CAAwB2B,GAAxB,CAA4B7B,KAA5B,EAAmC,UAAAA,KAAK;AAAA,yBAAI,MAAI,CAAC8B,eAAL,CAAqBF,OAArB,EAA8B5B,KAAK,CAACC,GAApC,CAAJ;AAAA,iBAAxC,C;;;;;;;;;;;;;;;;;;;gGAEE8B,G,EAAKP,e;;;;;kDACP,KAAKQ,MAAL,CAAY,UAAAC,MAAM;AAAA,yBAAIpD,MAAM,CAACqD,MAAP,CAAcD,MAAd,EAAsBF,GAAtB,CAAJ;AAAA,iBAAlB,EAAkDP,eAAlD,C;;;;;;;;;;;;;;;;;;;+FAEEvB,G;;;;;;AACTZ,gBAAAA,UAAU,CAAC8C,oBAAX,CAAgClC,GAAhC;;uBACuB,KAAKmC,mBAAL,CAAyB;AAAEnC,kBAAAA,GAAG,EAAHA;AAAF,iBAAzB,C;;;AAAjBoC,gBAAAA,Q;AACN,qBAAK1C,UAAL,CAAgB2C,YAAhB,GAA+BD,QAAQ,CAACC,YAAxC;;;;;;;;;;;;;;;;AAEJ;AACJ;AACA;;;;;4GAC8BtD,K,EAAOiB,G;;;;;;;uBACV,KAAKmC,mBAAL,CAAyB;AAAEhC,kBAAAA,IAAI,EAAEpB,KAAR;AAAe6B,kBAAAA,QAAQ,EAAE0B,SAAzB;AAAoCtC,kBAAAA,GAAG,EAAHA;AAApC,iBAAzB,C;;;AAAfuC,gBAAAA,M;;AACJ,qBAAKC,6BAAL,CAAmCD,MAAnC;;kDACO,KAAKxD,K;;;;;;;;;;;;;;;;AAEhB;AACJ;AACA;;;;;wGAC0B0D,e,EAAiBzC,G;;;;;;AAC/BG,gBAAAA,I,GAAOsC,eAAe,CAACrD,UAAU,CAACsD,SAAX,CAAqB,KAAK3D,KAA1B,CAAD,C;;qBACtBoB,I;;;;;AACIS,gBAAAA,Q,GAAW,KAAKA,Q;;;uBAEG,KAAKuB,mBAAL,CAAyB;AAAEhC,kBAAAA,IAAI,EAAJA,IAAF;AAAQS,kBAAAA,QAAQ,EAARA,QAAR;AAAkBZ,kBAAAA,GAAG,EAAHA;AAAlB,iBAAzB,C;;;AAAfuC,gBAAAA,M;;AACJ,qBAAKC,6BAAL,CAAmCD,MAAnC;;kDACO,KAAKxD,K;;;;;;sBAGR,aAAM4D,MAAN,KAAiB,G;;;;;;uBACX,KAAKC,SAAL,E;;;kDACC,KAAKf,eAAL,CAAqBY,eAArB,C;;;;;;;;;;kDAQR,KAAK1D,K;;;;;;;;;;;;;;;;AAGpB;AACJ;AACA;;;;kDACkCwD,M,EAAQ;AAClC,UAAIA,MAAM,CAAC5B,aAAP,GAAuB,KAAKjB,UAAL,CAAgBiB,aAA3C,EAA0D;AACtD;AACA,aAAKjB,UAAL,CAAgBkB,QAAhB,GAA2B2B,MAAM,CAAC3B,QAAlC;AACA,aAAKlB,UAAL,CAAgBS,IAAhB,GAAuBoC,MAAM,CAACpC,IAA9B;AACA,aAAKT,UAAL,CAAgBiB,aAAhB,GAAgC4B,MAAM,CAAC5B,aAAvC;AACA,aAAKjB,UAAL,CAAgB2C,YAAhB,GAA+BE,MAAM,CAACF,YAAtC;AACA,aAAK3C,UAAL,CAAgBU,YAAhB,GAA+B,IAAIC,IAAJ,CAASkC,MAAM,CAACnC,YAAhB,CAA/B;AACA,aAAKX,QAAL,CAAcwB,OAAd,CAAsBX,MAAtB,CAA6B,KAAKE,IAAlC,EAAwC,KAAKU,GAA7C,EAAkD,KAAKC,UAAvD,EAAmE;AAC/DR,UAAAA,aAAa,EAAE4B,MAAM,CAAC5B,aADyC;AAE/DC,UAAAA,QAAQ,EAAE2B,MAAM,CAAC3B,QAF8C;AAG/DR,UAAAA,YAAY,EAAEmC,MAAM,CAACnC,YAH0C;AAI/DD,UAAAA,IAAI,EAAEoC,MAAM,CAACpC;AAJkD,SAAnE;AAMA,aAAKY,yBAAL,CAA+B,SAA/B,EAA0C;AAAEhC,UAAAA,KAAK,EAAE,KAAKA,KAAd;AAAqBiC,UAAAA,OAAO,EAAE;AAA9B,SAA1C;AACH;AACJ;AACD;AACJ;AACA;;;;;4GAC8B6B,O;;;;;;oBACjB,KAAKjD,S;;;;;AACAkD,gBAAAA,W,GAAc;AAChB3C,kBAAAA,IAAI,EAAE0C,OAAO,CAAC1C;AADE,iB;;AAGpB,oBAAI0C,OAAO,CAAC7C,GAAR,KAAgBsC,SAApB,EAA+B;AAC3BQ,kBAAAA,WAAW,CAAC9C,GAAZ,GAAkB6C,OAAO,CAAC7C,GAA1B;AACH;;AACK+C,gBAAAA,O,GAAUF,OAAO,CAACjC,Q;;;uBAEG,KAAKnB,QAAL,CAAcuD,OAAd,CAAsBC,IAAtB,CAA2B,KAAKC,GAAhC,EAAqCJ,WAArC,EAAkDC,OAAlD,C;;;AAAjBX,gBAAAA,Q;kDACC;AACHxB,kBAAAA,QAAQ,EAAEwB,QAAQ,CAACe,IAAT,CAAcvC,QADrB;AAEHT,kBAAAA,IAAI,EAAE0C,OAAO,CAAC1C,IAFX;AAGHQ,kBAAAA,aAAa,EAAEyB,QAAQ,CAACe,IAAT,CAAcxC,aAH1B;AAIHP,kBAAAA,YAAY,EAAEgC,QAAQ,CAACe,IAAT,CAAc/C,YAJzB;AAKHiC,kBAAAA,YAAY,EAAED,QAAQ,CAACe,IAAT,CAAcd;AALzB,iB;;;;;;AASP,oBAAI,aAAMM,MAAN,KAAiB,GAArB,EAA0B;AACtB,uBAAKrB,SAAL,CAAe,KAAf;AACH;;;;;;;;;kDAKE8B,OAAO,CAACC,MAAR,CAAe,IAAInE,WAAW,CAACoE,SAAhB,CAA0B,+BAA1B,EAA2D,GAA3D,EAAgE,KAAhE,CAAf,C;;;;;;;;;;;;;;;;AAGf;AACJ;AACA;AACA;;;;;;;;;;;;kDAEe,KAAK7D,QAAL,CAAcuD,OAAd,CAAsBO,GAAtB,CAA0B,KAAKL,GAA/B,EACFM,IADE,CACG,UAAApB,QAAQ,EAAI;AAClB,sBAAMqB,KAAK,GAAG;AACVjD,oBAAAA,IAAI,EAAE,kBADI;AAEVC,oBAAAA,EAAE,EAAE2B,QAAQ,CAACe,IAAT,CAAcxC,aAFR;AAGVE,oBAAAA,iBAAiB,EAAEuB,QAAQ,CAACe,IAAT,CAAcvC,QAHvB;AAIVE,oBAAAA,aAAa,EAAEsB,QAAQ,CAACe,IAAT,CAAchD,IAJnB;AAKVI,oBAAAA,YAAY,EAAE6B,QAAQ,CAACe,IAAT,CAAc/C;AALlB,mBAAd;;AAOA,kBAAA,MAAI,CAACsD,OAAL,CAAaD,KAAb;;AACA,yBAAO,MAAP;AACH,iBAXM,EAYFE,KAZE,CAYI,UAAAC,GAAG,EAAI;AACd,sBAAIA,GAAG,CAACjB,MAAJ,KAAe,GAAnB,EAAwB;AACpB,oBAAA,MAAI,CAACrB,SAAL,CAAe,KAAf;AACH,mBAFD,MAGK;AACDjC,oBAAAA,QAAQ,CAAC+B,OAAT,CAAiByC,KAAjB,iCAAgD,MAAI,CAAC3C,GAArD,QAA6D0C,GAA7D;AACH;AACJ,iBAnBM,C;;;;;;;;;;;;;;;;;;8BAqBDE,O,EAAS;AACf,UAAI,KAAKlE,SAAT,EAAoB;AAChB;AACH,OAFD,MAGK;AACD,aAAKA,SAAL,GAAiB,IAAjB;;AACA,aAAKmE,YAAL;;AACA,aAAKpE,cAAL,CAAoB,KAAKa,IAAzB,EAA+B,KAAKU,GAApC,EAAyC,KAAKC,UAA9C;AACA,aAAKJ,yBAAL,CAA+B,SAA/B,EAA0C;AAAEC,UAAAA,OAAO,EAAE8C;AAAX,SAA1C;AACH;AACJ;;;;;;;;;oBAEQ,KAAKlE,S;;;;;;uBACA,KAAKH,QAAL,CAAcuD,OAAd,CAAsBgB,MAAtB,CAA6B,KAAKd,GAAlC,C;;;AACN,qBAAK5B,SAAL,CAAe,IAAf;;;;;kDAGO8B,OAAO,CAACC,MAAR,CAAe,IAAInE,WAAW,CAACoE,SAAhB,CAA0B,+BAA1B,EAA2D,GAA3D,EAAgE,KAAhE,CAAf,C;;;;;;;;;;;;;;;;;;wBAxNL;AACN,aAAO,KAAK5D,UAAL,CAAgBuE,GAAvB;AACH;;;wBACc;AACX,aAAO,KAAKvE,UAAL,CAAgBkB,QAAvB;AACH;;;wBACiB;AACd,aAAO,KAAKlB,UAAL,CAAgBiB,aAAvB;AACH;;;wBACiB;AACd,aAAO,KAAKjB,UAAL,CAAgB2C,YAAvB;AACH;;;wBAIU;AACP,aAAO,UAAP;AACH,K,CACD;;;;wBACgB;AACZ,aAAOC,SAAP;AACH;;;wBACiB;AACd,aAAOA,SAAP;AACH,K,CACD;;;;wBACU;AACN,aAAO,KAAK5C,UAAL,CAAgBwB,GAAvB;AACH;;;wBACW;AACR,aAAO,KAAKxB,UAAL,CAAgBS,IAAvB;AACH;;;wBACiB;AACd,aAAO,KAAKT,UAAL,CAAgBU,YAAvB;AACH;;;wBACgB;AACb,aAAO,KAAKV,UAAL,CAAgBwE,WAAhB,IAA+B,IAAtC;AACH;;;wBAzBiB;AACd,aAAO,UAAP;AACH;;;;EA7B0B5E,QAAQ,CAAC6E,U;;AA2OxCrF,OAAO,CAACE,gBAAR,GAA2BA,gBAA3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACMC,Y;;;;;AACF,wBAAYmF,gBAAZ,EAA8B;AAAA;;AAAA;;AAC1B;AACA,WAAKA,gBAAL,GAAwBA,gBAAxB;;AACA,WAAKA,gBAAL,CAAsBC,MAAtB;;AAH0B;AAI7B,G,CACD;;;;;;AAgCA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;8FACctF,K,EAAOwC,e;;;;;AACb,qBAAK+C,eAAL;mDACO,KAAKF,gBAAL,CAAsBG,GAAtB,CAA0BxF,KAA1B,EAAiCwC,eAAjC,C;;;;;;;;;;;;;;;;AAEX;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;iGACiBI,O,EAASJ,e;;;;;AAClB,qBAAK+C,eAAL;mDACO,KAAKF,gBAAL,CAAsBrC,MAAtB,CAA6BJ,OAA7B,EAAsCJ,eAAtC,C;;;;;;;;;;;;;;;;AAEX;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;iGACiBO,G,EAAKP,e;;;;;AACd,qBAAK+C,eAAL;mDACO,KAAKF,gBAAL,CAAsB9D,MAAtB,CAA6BwB,GAA7B,EAAkCP,eAAlC,C;;;;;;;;;;;;;;;;AAEX;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;iGACiBvB,G;;;;;AACT,qBAAKsE,eAAL;mDACO,KAAKF,gBAAL,CAAsBI,MAAtB,CAA6BxE,GAA7B,C;;;;;;;;;;;;;;;;AAEX;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAEQ,qBAAKsE,eAAL;mDACO,KAAKF,gBAAL,CAAsBK,cAAtB,E;;;;;;;;;;;;;;;;AAEX;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;;4BACY;AACJ;;AACA,WAAKL,gBAAL,CAAsBM,MAAtB,CAA6B,KAAKC,YAAlC;AACH;;;wBAxJS;AACN,aAAO,KAAKP,gBAAL,CAAsBlB,GAA7B;AACH;;;wBACc;AACX,aAAO,KAAKkB,gBAAL,CAAsBxD,QAA7B;AACH;;;wBACiB;AACd,aAAO,KAAKwD,gBAAL,CAAsB1D,WAA7B;AACH;;;wBACiB;AACd,aAAO,KAAK0D,gBAAL,CAAsBQ,WAA7B;AACH;;;wBAIU;AACP,aAAO5F,gBAAgB,CAACwB,IAAxB;AACH,K,CACD;;;;wBACU;AACN,aAAO,KAAK4D,gBAAL,CAAsBlD,GAA7B;AACH;;;wBACW;AACR,aAAO,KAAKkD,gBAAL,CAAsBrF,KAA7B;AACH;;;wBACiB;AACd,aAAO,KAAKqF,gBAAL,CAAsBS,WAA7B;AACH;;;wBACgB;AACb,aAAO,KAAKT,gBAAL,CAAsBjD,UAA7B;AACH;;;wBAlBiB;AACd,aAAOnC,gBAAgB,CAACwB,IAAxB;AACH;;;;EArBsBhB,WAAW,CAAC4B,O;;AAiKvCtC,OAAO,CAACG,YAAR,GAAuBA,YAAvB;AACAH,OAAO,CAACsC,OAAR,GAAkBnC,YAAlB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SyncDocumentImpl = exports.SyncDocument = void 0;\nconst syncerror_1 = require(\"./utils/syncerror\");\nconst sanitize_1 = require(\"./utils/sanitize\");\nconst logger_1 = require(\"./utils/logger\");\nconst entity_1 = require(\"./entity\");\nconst mergingqueue_1 = require(\"./mergingqueue\");\nconst closeable_1 = require(\"./closeable\");\nclass SyncDocumentImpl extends entity_1.SyncEntity {\n    /**\n     * @private\n     */\n    constructor(services, descriptor, removalHandler) {\n        super(services, removalHandler);\n        this.isDeleted = false;\n        const updateRequestReducer = (acc, input) => (typeof input.ttl === 'number') ? { ttl: input.ttl }\n            : acc;\n        this.updateMergingQueue = new mergingqueue_1.MergingQueue(updateRequestReducer);\n        this.descriptor = descriptor;\n        this.descriptor.data = this.descriptor.data || {};\n        this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n    }\n    // private props\n    get uri() {\n        return this.descriptor.url;\n    }\n    get revision() {\n        return this.descriptor.revision;\n    }\n    get lastEventId() {\n        return this.descriptor.last_event_id;\n    }\n    get dateExpires() {\n        return this.descriptor.date_expires;\n    }\n    static get type() {\n        return 'document';\n    }\n    get type() {\n        return 'document';\n    }\n    // below properties are specific to Insights only\n    get indexName() {\n        return undefined;\n    }\n    get queryString() {\n        return undefined;\n    }\n    // public props, documented along with class description\n    get sid() {\n        return this.descriptor.sid;\n    }\n    get value() {\n        return this.descriptor.data;\n    }\n    get dateUpdated() {\n        return this.descriptor.date_updated;\n    }\n    get uniqueName() {\n        return this.descriptor.unique_name || null;\n    }\n    /**\n     * Update data entity with new data\n     * @private\n     */\n    _update(update) {\n        update.date_created = new Date(update.date_created);\n        switch (update.type) {\n            case 'document_updated':\n                if (update.id > this.lastEventId) {\n                    this.descriptor.last_event_id = update.id;\n                    this.descriptor.revision = update.document_revision;\n                    this.descriptor.date_updated = update.date_created;\n                    this.descriptor.data = update.document_data;\n                    this.broadcastEventToListeners('updated', { value: update.document_data, isLocal: false });\n                    this.services.storage.update(this.type, this.sid, this.uniqueName, {\n                        last_event_id: update.id,\n                        revision: update.document_revision,\n                        date_updated: update.date_created,\n                        data: update.document_data\n                    });\n                }\n                else {\n                    logger_1.default.trace('Document update skipped, current:', this.lastEventId, ', remote:', update.id);\n                }\n                break;\n            case 'document_removed':\n                this.onRemoved(false);\n                break;\n        }\n    }\n    async set(value, metadataUpdates) {\n        const input = metadataUpdates || {};\n        sanitize_1.validateOptionalTtl(input.ttl);\n        return this.updateMergingQueue.squashAndAdd(input, input => this._setUnconditionally(value, input.ttl));\n    }\n    async mutate(mutator, metadataUpdates) {\n        const input = metadataUpdates || {};\n        sanitize_1.validateOptionalTtl(input.ttl);\n        return this.updateMergingQueue.add(input, input => this._setWithIfMatch(mutator, input.ttl));\n    }\n    async update(obj, metadataUpdates) {\n        return this.mutate(remote => Object.assign(remote, obj), metadataUpdates);\n    }\n    async setTtl(ttl) {\n        sanitize_1.validateMandatoryTtl(ttl);\n        const response = await this._postUpdateToServer({ ttl });\n        this.descriptor.date_expires = response.date_expires;\n    }\n    /**\n     * @private\n     */\n    async _setUnconditionally(value, ttl) {\n        let result = await this._postUpdateToServer({ data: value, revision: undefined, ttl });\n        this._handleSuccessfulUpdateResult(result);\n        return this.value;\n    }\n    /**\n     * @private\n     */\n    async _setWithIfMatch(mutatorFunction, ttl) {\n        let data = mutatorFunction(sanitize_1.deepClone(this.value));\n        if (data) {\n            let revision = this.revision;\n            try {\n                let result = await this._postUpdateToServer({ data, revision, ttl });\n                this._handleSuccessfulUpdateResult(result);\n                return this.value;\n            }\n            catch (error) {\n                if (error.status === 412) {\n                    await this._softSync();\n                    return this._setWithIfMatch(mutatorFunction);\n                }\n                else {\n                    throw error;\n                }\n            }\n        }\n        else {\n            return this.value;\n        }\n    }\n    /**\n     * @private\n     */\n    _handleSuccessfulUpdateResult(result) {\n        if (result.last_event_id > this.descriptor.last_event_id) {\n            // Ignore returned value if we already got a newer one\n            this.descriptor.revision = result.revision;\n            this.descriptor.data = result.data;\n            this.descriptor.last_event_id = result.last_event_id;\n            this.descriptor.date_expires = result.date_expires;\n            this.descriptor.date_updated = new Date(result.date_updated);\n            this.services.storage.update(this.type, this.sid, this.uniqueName, {\n                last_event_id: result.last_event_id,\n                revision: result.revision,\n                date_updated: result.date_updated,\n                data: result.data\n            });\n            this.broadcastEventToListeners('updated', { value: this.value, isLocal: true });\n        }\n    }\n    /**\n     * @private\n     */\n    async _postUpdateToServer(request) {\n        if (!this.isDeleted) {\n            const requestBody = {\n                data: request.data\n            };\n            if (request.ttl !== undefined) {\n                requestBody.ttl = request.ttl;\n            }\n            const ifMatch = request.revision;\n            try {\n                const response = await this.services.network.post(this.uri, requestBody, ifMatch);\n                return {\n                    revision: response.body.revision,\n                    data: request.data,\n                    last_event_id: response.body.last_event_id,\n                    date_updated: response.body.date_updated,\n                    date_expires: response.body.date_expires\n                };\n            }\n            catch (error) {\n                if (error.status === 404) {\n                    this.onRemoved(false);\n                }\n                throw error;\n            }\n        }\n        else {\n            return Promise.reject(new syncerror_1.SyncError('The Document has been removed', 404, 54100));\n        }\n    }\n    /**\n     * Get new data from server\n     * @private\n     */\n    async _softSync() {\n        return this.services.network.get(this.uri)\n            .then(response => {\n            const event = {\n                type: 'document_updated',\n                id: response.body.last_event_id,\n                document_revision: response.body.revision,\n                document_data: response.body.data,\n                date_created: response.body.date_updated\n            };\n            this._update(event);\n            return this;\n        })\n            .catch(err => {\n            if (err.status === 404) {\n                this.onRemoved(false);\n            }\n            else {\n                logger_1.default.error(`Can't get updates for ${this.sid}:`, err);\n            }\n        });\n    }\n    onRemoved(locally) {\n        if (this.isDeleted) {\n            return;\n        }\n        else {\n            this.isDeleted = true;\n            this._unsubscribe();\n            this.removalHandler(this.type, this.sid, this.uniqueName);\n            this.broadcastEventToListeners('removed', { isLocal: locally });\n        }\n    }\n    async removeDocument() {\n        if (!this.isDeleted) {\n            await this.services.network.delete(this.uri);\n            this.onRemoved(true);\n        }\n        else {\n            return Promise.reject(new syncerror_1.SyncError('The Document has been removed', 404, 54100));\n        }\n    }\n}\nexports.SyncDocumentImpl = SyncDocumentImpl;\n/**\n * @class\n * @alias Document\n * @classdesc Represents a Sync Document, the contents of which is a single JSON object.\n * Use the {@link Client#document} method to obtain a reference to a Sync Document.\n * @property {String} sid The immutable identifier of this document, assigned by the system.\n * @property {String} [uniqueName=null] An optional immutable identifier that may be assigned by the programmer\n * to this document during creation. Globally unique among other Documents.\n * @property {Date} dateUpdated Date when the Document was last updated.\n * @property {Object} value The contents of this document.\n *\n * @fires Document#removed\n * @fires Document#updated\n */\nclass SyncDocument extends closeable_1.default {\n    constructor(syncDocumentImpl) {\n        super();\n        this.syncDocumentImpl = syncDocumentImpl;\n        this.syncDocumentImpl.attach(this);\n    }\n    // private props\n    get uri() {\n        return this.syncDocumentImpl.uri;\n    }\n    get revision() {\n        return this.syncDocumentImpl.revision;\n    }\n    get lastEventId() {\n        return this.syncDocumentImpl.lastEventId;\n    }\n    get dateExpires() {\n        return this.syncDocumentImpl.dateExpires;\n    }\n    static get type() {\n        return SyncDocumentImpl.type;\n    }\n    get type() {\n        return SyncDocumentImpl.type;\n    }\n    // public props, documented along with class description\n    get sid() {\n        return this.syncDocumentImpl.sid;\n    }\n    get value() {\n        return this.syncDocumentImpl.value;\n    }\n    get dateUpdated() {\n        return this.syncDocumentImpl.dateUpdated;\n    }\n    get uniqueName() {\n        return this.syncDocumentImpl.uniqueName;\n    }\n    /**\n     * Assign new contents to this document. The current value will be overwritten.\n     * @param {Object} value The new contents to assign.\n     * @param {Document#Metadata} [metadataUpdates] New document metadata.\n     * @returns {Promise<Object>} A promise resolving to the new value of the document.\n     * @public\n     * @example\n     * // Say, the Document value is { name: 'John Smith', age: 34 }\n     * document.set({ name: 'Barbara Oaks' }, { ttl: 86400 })\n     *   .then(function(newValue) {\n     *     // Now the Document value is { name: 'Barbara Oaks' }\n     *     console.log('Document set() successful, new value:', newValue);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Document set() failed', error);\n     *   });\n     */\n    async set(value, metadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncDocumentImpl.set(value, metadataUpdates);\n    }\n    /**\n     * Schedules a modification to this document that will apply a mutation function.\n     * @param {Document~Mutator} mutator A function that outputs a new value based on the existing value.\n     * May be called multiple times, particularly if this Document is modified concurrently by remote code.\n     * If the mutation ultimately succeeds, the Document will have made the particular transition described\n     * by this function.\n     * @param {Document#Metadata} [metadataUpdates] New document metadata.\n     * @return {Promise<Object>} Resolves with the most recent Document state, whether the output of a\n     *    successful mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>).\n     * @public\n     * @example\n     * var mutatorFunction = function(currentValue) {\n     *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\n     *     return currentValue;\n     * };\n     * document.mutate(mutatorFunction, { ttl: 86400 }))\n     *   .then(function(newValue) {\n     *     console.log('Document mutate() successful, new value:', newValue);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Document mutate() failed', error);\n     *   });\n     */\n    async mutate(mutator, metadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncDocumentImpl.mutate(mutator, metadataUpdates);\n    }\n    /**\n     * Modify a document by appending new fields (or by overwriting existing ones) with the values from the provided Object.\n     * This is equivalent to\n     * <pre>\n     * document.mutate(function(currentValue) {\n     *   return Object.assign(currentValue, obj));\n     * });\n     * </pre>\n     * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.\n     * @param {Document#Metadata} [metadataUpdates] New document metadata.\n     * @return {Promise<Object>} A promise resolving to the new value of the document.\n     * @public\n     * @example\n     * // Say, the Document value is { name: 'John Smith' }\n     * document.update({ age: 34 }, { ttl: 86400 })\n     *   .then(function(newValue) {\n     *     // Now the Document value is { name: 'John Smith', age: 34 }\n     *     console.log('Document update() successful, new value:', newValue);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Document update() failed', error);\n     *   });\n     */\n    async update(obj, metadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncDocumentImpl.update(obj, metadataUpdates);\n    }\n    /**\n     * Update the time-to-live of the document.\n     * @param {Number} ttl Specifies the time-to-live in seconds after which the document is subject to automatic deletion. The value 0 means infinity.\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n     * @public\n     * @example\n     * document.setTtl(3600)\n     *   .then(function() {\n     *     console.log('Document setTtl() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Document setTtl() failed', error);\n     *   });\n     */\n    async setTtl(ttl) {\n        this.ensureNotClosed();\n        return this.syncDocumentImpl.setTtl(ttl);\n    }\n    /**\n     * Delete a document.\n     * @return {Promise<void>} A promise which resolves if (and only if) the document is ultimately deleted.\n     * @public\n     * @example\n     * document.removeDocument()\n     *   .then(function() {\n     *     console.log('Document removeDocument() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Document removeDocument() failed', error);\n     *   });\n     */\n    async removeDocument() {\n        this.ensureNotClosed();\n        return this.syncDocumentImpl.removeDocument();\n    }\n    /**\n     * Conclude work with the document instance and remove all event listeners attached to it.\n     * Any subsequent operation on this object will be rejected with error.\n     * Other local copies of this document will continue operating and receiving events normally.\n     * @public\n     * @example\n     * document.close();\n     */\n    close() {\n        super.close();\n        this.syncDocumentImpl.detach(this.listenerUuid);\n    }\n}\nexports.SyncDocument = SyncDocument;\nexports.default = SyncDocument;\n/**\n * Contains Document metadata.\n * @typedef {Object} Document#Metadata\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the document is subject to automatic deletion.\n * The value 0 means infinity.\n */\n/**\n * Applies a transformation to the document value.\n * @callback Document~Mutator\n * @param {Object} currentValue The current value of the document in the cloud.\n * @return {Object} The desired new value for the document or <code>null</code> to gracefully cancel the mutation.\n */\n/**\n * Fired when the document is removed, whether the remover was local or remote.\n * @event Document#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if document was removed by local actor, 'false' otherwise.\n * @example\n * document.on('removed', function(args) {\n *   console.log('Document ' + document.sid + ' was removed');\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n/**\n * Fired when the document's contents have changed, whether the updater was local or remote.\n * @event Document#updated\n * @param {Object} args Arguments provided with the event.\n * @param {Object} args.value A snapshot of the document's new contents.\n * @param {Boolean} args.isLocal Equals 'true' if document was updated by local actor, 'false' otherwise.\n * @example\n * document.on('updated', function(args) {\n *   console.log('Document ' + document.sid + ' was updated');\n *   console.log('args.value: ', args.value);\n *   console.log('args.isLocal: ', args.isLocal);\n * });\n */\n"]},"metadata":{},"sourceType":"script"}