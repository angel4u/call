{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @packageDocumentation\n * @module Voice\n */\n\nvar events_1 = require(\"events\");\n\nvar errors_1 = require(\"./errors\");\n\nvar log_1 = require(\"./log\");\n\nvar outputdevicecollection_1 = require(\"./outputdevicecollection\");\n\nvar defaultMediaDevices = require(\"./shims/mediadevices\");\n\nvar util_1 = require(\"./util\");\n\nvar MediaDeviceInfoShim = require('./shims/mediadeviceinfo');\n/**\n * Aliases for audio kinds, used for labelling.\n * @private\n */\n\n\nvar kindAliases = {\n  audioinput: 'Audio Input',\n  audiooutput: 'Audio Output'\n};\n/**\n * Provides input and output audio-based functionality in one convenient class.\n * @publicapi\n */\n\nvar AudioHelper =\n/** @class */\nfunction (_super) {\n  __extends(AudioHelper, _super);\n  /**\n   * @constructor\n   * @private\n   * @param onActiveOutputsChanged - A callback to be called when the user changes the active output devices.\n   * @param onActiveInputChanged - A callback to be called when the user changes the active input device.\n   * @param getUserMedia - The getUserMedia method to use.\n   * @param [options]\n   */\n\n\n  function AudioHelper(onActiveOutputsChanged, onActiveInputChanged, getUserMedia, options) {\n    var _this = _super.call(this) || this;\n    /**\n     * A Map of all audio input devices currently available to the browser by their device ID.\n     */\n\n\n    _this.availableInputDevices = new Map();\n    /**\n     * A Map of all audio output devices currently available to the browser by their device ID.\n     */\n\n    _this.availableOutputDevices = new Map();\n    /**\n     * The currently set audio constraints set by setAudioConstraints().\n     */\n\n    _this._audioConstraints = null;\n    /**\n     * The current input device.\n     */\n\n    _this._inputDevice = null;\n    /**\n     * The current input stream.\n     */\n\n    _this._inputStream = null;\n    /**\n     * Whether the {@link AudioHelper} is currently polling the input stream's volume.\n     */\n\n    _this._isPollingInputVolume = false;\n    /**\n     * An instance of Logger to use.\n     */\n\n    _this._log = log_1.default.getInstance();\n    /**\n     * A record of unknown devices (Devices without labels)\n     */\n\n    _this._unknownDeviceIndexes = {\n      audioinput: {},\n      audiooutput: {}\n    };\n    /**\n     * Remove an input device from inputs\n     * @param lostDevice\n     * @returns Whether the device was active\n     */\n\n    _this._removeLostInput = function (lostDevice) {\n      if (!_this.inputDevice || _this.inputDevice.deviceId !== lostDevice.deviceId) {\n        return false;\n      }\n\n      _this._replaceStream(null);\n\n      _this._inputDevice = null;\n\n      _this._maybeStopPollingVolume();\n\n      var defaultDevice = _this.availableInputDevices.get('default') || Array.from(_this.availableInputDevices.values())[0];\n\n      if (defaultDevice) {\n        _this.setInputDevice(defaultDevice.deviceId);\n      }\n\n      return true;\n    };\n    /**\n     * Remove an input device from outputs\n     * @param lostDevice\n     * @returns Whether the device was active\n     */\n\n\n    _this._removeLostOutput = function (lostDevice) {\n      var wasSpeakerLost = _this.speakerDevices.delete(lostDevice);\n\n      var wasRingtoneLost = _this.ringtoneDevices.delete(lostDevice);\n\n      return wasSpeakerLost || wasRingtoneLost;\n    };\n    /**\n     * Update the available input and output devices\n     */\n\n\n    _this._updateAvailableDevices = function () {\n      if (!_this._mediaDevices) {\n        return Promise.reject('Enumeration not supported');\n      }\n\n      return _this._mediaDevices.enumerateDevices().then(function (devices) {\n        _this._updateDevices(devices.filter(function (d) {\n          return d.kind === 'audiooutput';\n        }), _this.availableOutputDevices, _this._removeLostOutput);\n\n        _this._updateDevices(devices.filter(function (d) {\n          return d.kind === 'audioinput';\n        }), _this.availableInputDevices, _this._removeLostInput);\n\n        var defaultDevice = _this.availableOutputDevices.get('default') || Array.from(_this.availableOutputDevices.values())[0];\n        [_this.speakerDevices, _this.ringtoneDevices].forEach(function (outputDevices) {\n          if (!outputDevices.get().size && _this.availableOutputDevices.size && _this.isOutputSelectionSupported) {\n            outputDevices.set(defaultDevice.deviceId).catch(function (reason) {\n              _this._log.warn(\"Unable to set audio output devices. \" + reason);\n            });\n          }\n        });\n      });\n    };\n\n    options = Object.assign({\n      AudioContext: typeof AudioContext !== 'undefined' && AudioContext,\n      setSinkId: typeof HTMLAudioElement !== 'undefined' && HTMLAudioElement.prototype.setSinkId\n    }, options);\n    _this._getUserMedia = getUserMedia;\n    _this._mediaDevices = options.mediaDevices || defaultMediaDevices;\n    _this._onActiveInputChanged = onActiveInputChanged;\n    var isAudioContextSupported = !!(options.AudioContext || options.audioContext);\n    var isEnumerationSupported = !!(_this._mediaDevices && _this._mediaDevices.enumerateDevices);\n    var isSetSinkSupported = typeof options.setSinkId === 'function';\n    _this.isOutputSelectionSupported = isEnumerationSupported && isSetSinkSupported;\n    _this.isVolumeSupported = isAudioContextSupported;\n\n    if (options.enabledSounds) {\n      _this._addEnabledSounds(options.enabledSounds);\n    }\n\n    if (_this.isVolumeSupported) {\n      _this._audioContext = options.audioContext || options.AudioContext && new options.AudioContext();\n\n      if (_this._audioContext) {\n        _this._inputVolumeAnalyser = _this._audioContext.createAnalyser();\n        _this._inputVolumeAnalyser.fftSize = 32;\n        _this._inputVolumeAnalyser.smoothingTimeConstant = 0.3;\n      }\n    }\n\n    _this.ringtoneDevices = new outputdevicecollection_1.default('ringtone', _this.availableOutputDevices, onActiveOutputsChanged, _this.isOutputSelectionSupported);\n    _this.speakerDevices = new outputdevicecollection_1.default('speaker', _this.availableOutputDevices, onActiveOutputsChanged, _this.isOutputSelectionSupported);\n\n    _this.addListener('newListener', function (eventName) {\n      if (eventName === 'inputVolume') {\n        _this._maybeStartPollingVolume();\n      }\n    });\n\n    _this.addListener('removeListener', function (eventName) {\n      if (eventName === 'inputVolume') {\n        _this._maybeStopPollingVolume();\n      }\n    });\n\n    _this.once('newListener', function () {\n      // NOTE (rrowland): Ideally we would only check isEnumerationSupported here, but\n      //   in at least one browser version (Tested in FF48) enumerateDevices actually\n      //   returns bad data for the listed devices. Instead, we check for\n      //   isOutputSelectionSupported to avoid these quirks that may negatively affect customers.\n      if (!_this.isOutputSelectionSupported) {\n        _this._log.warn('Warning: This browser does not support audio output selection.');\n      }\n\n      if (!_this.isVolumeSupported) {\n        _this._log.warn(\"Warning: This browser does not support Twilio's volume indicator feature.\");\n      }\n    });\n\n    if (isEnumerationSupported) {\n      _this._initializeEnumeration();\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(AudioHelper.prototype, \"audioConstraints\", {\n    /**\n     * The currently set audio constraints set by setAudioConstraints(). Starts as null.\n     */\n    get: function () {\n      return this._audioConstraints;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AudioHelper.prototype, \"inputDevice\", {\n    /**\n     * The active input device. Having no inputDevice specified by `setInputDevice()`\n     * will disable input selection related functionality.\n     */\n    get: function () {\n      return this._inputDevice;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AudioHelper.prototype, \"inputStream\", {\n    /**\n     * The current input stream.\n     */\n    get: function () {\n      return this._inputStream;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Start polling volume if it's supported and there's an input stream to poll.\n   * @private\n   */\n\n  AudioHelper.prototype._maybeStartPollingVolume = function () {\n    var _this = this;\n\n    if (!this.isVolumeSupported || !this._inputStream) {\n      return;\n    }\n\n    this._updateVolumeSource();\n\n    if (this._isPollingInputVolume || !this._inputVolumeAnalyser) {\n      return;\n    }\n\n    var bufferLength = this._inputVolumeAnalyser.frequencyBinCount;\n    var buffer = new Uint8Array(bufferLength);\n    this._isPollingInputVolume = true;\n\n    var emitVolume = function () {\n      if (!_this._isPollingInputVolume) {\n        return;\n      }\n\n      if (_this._inputVolumeAnalyser) {\n        _this._inputVolumeAnalyser.getByteFrequencyData(buffer);\n\n        var inputVolume = util_1.average(buffer);\n\n        _this.emit('inputVolume', inputVolume / 255);\n      }\n\n      requestAnimationFrame(emitVolume);\n    };\n\n    requestAnimationFrame(emitVolume);\n  };\n  /**\n   * Stop polling volume if it's currently polling and there are no listeners.\n   * @private\n   */\n\n\n  AudioHelper.prototype._maybeStopPollingVolume = function () {\n    if (!this.isVolumeSupported) {\n      return;\n    }\n\n    if (!this._isPollingInputVolume || this._inputStream && this.listenerCount('inputVolume')) {\n      return;\n    }\n\n    if (this._inputVolumeSource) {\n      this._inputVolumeSource.disconnect();\n\n      delete this._inputVolumeSource;\n    }\n\n    this._isPollingInputVolume = false;\n  };\n  /**\n   * Unbind the listeners from mediaDevices.\n   * @private\n   */\n\n\n  AudioHelper.prototype._unbind = function () {\n    if (!this._mediaDevices) {\n      throw new errors_1.NotSupportedError('Enumeration is not supported');\n    }\n\n    if (this._mediaDevices.removeEventListener) {\n      this._mediaDevices.removeEventListener('devicechange', this._updateAvailableDevices);\n\n      this._mediaDevices.removeEventListener('deviceinfochange', this._updateAvailableDevices);\n    }\n  };\n  /**\n   * Set the MediaTrackConstraints to be applied on every getUserMedia call for new input\n   * device audio. Any deviceId specified here will be ignored. Instead, device IDs should\n   * be specified using {@link AudioHelper#setInputDevice}. The returned Promise resolves\n   * when the media is successfully reacquired, or immediately if no input device is set.\n   * @param audioConstraints - The MediaTrackConstraints to apply.\n   */\n\n\n  AudioHelper.prototype.setAudioConstraints = function (audioConstraints) {\n    this._audioConstraints = Object.assign({}, audioConstraints);\n    delete this._audioConstraints.deviceId;\n    return this.inputDevice ? this._setInputDevice(this.inputDevice.deviceId, true) : Promise.resolve();\n  };\n  /**\n   * Replace the current input device with a new device by ID.\n   * @param deviceId - An ID of a device to replace the existing\n   *   input device with.\n   */\n\n\n  AudioHelper.prototype.setInputDevice = function (deviceId) {\n    return !util_1.isFirefox() ? this._setInputDevice(deviceId, false) : Promise.reject(new errors_1.NotSupportedError('Firefox does not currently support opening multiple ' + 'audio input tracks simultaneously, even across different tabs. As a result, ' + 'Device.audio.setInputDevice is disabled on Firefox until support is added.\\n' + 'Related BugZilla thread: https://bugzilla.mozilla.org/show_bug.cgi?id=1299324'));\n  };\n  /**\n   * Unset the MediaTrackConstraints to be applied on every getUserMedia call for new input\n   * device audio. The returned Promise resolves when the media is successfully reacquired,\n   * or immediately if no input device is set.\n   */\n\n\n  AudioHelper.prototype.unsetAudioConstraints = function () {\n    this._audioConstraints = null;\n    return this.inputDevice ? this._setInputDevice(this.inputDevice.deviceId, true) : Promise.resolve();\n  };\n  /**\n   * Unset the input device, stopping the tracks. This should only be called when not in a connection, and\n   *   will not allow removal of the input device during a live call.\n   */\n\n\n  AudioHelper.prototype.unsetInputDevice = function () {\n    var _this = this;\n\n    if (!this.inputDevice) {\n      return Promise.resolve();\n    }\n\n    return this._onActiveInputChanged(null).then(function () {\n      _this._replaceStream(null);\n\n      _this._inputDevice = null;\n\n      _this._maybeStopPollingVolume();\n    });\n  };\n  /**\n   * Merge the passed enabledSounds into {@link AudioHelper}. Currently used to merge the deprecated\n   *   Device.sounds object onto the new {@link AudioHelper} interface. Mutates\n   *   by reference, sharing state between {@link Device} and {@link AudioHelper}.\n   * @param enabledSounds - The initial sound settings to merge.\n   * @private\n   */\n\n\n  AudioHelper.prototype._addEnabledSounds = function (enabledSounds) {\n    var _this = this;\n\n    function setValue(key, value) {\n      if (typeof value !== 'undefined') {\n        enabledSounds[key] = value;\n      }\n\n      return enabledSounds[key];\n    }\n\n    Object.keys(enabledSounds).forEach(function (key) {\n      _this[key] = setValue.bind(null, key);\n    });\n  };\n  /**\n   * Get the index of an un-labeled Device.\n   * @param mediaDeviceInfo\n   * @returns The index of the passed MediaDeviceInfo\n   */\n\n\n  AudioHelper.prototype._getUnknownDeviceIndex = function (mediaDeviceInfo) {\n    var id = mediaDeviceInfo.deviceId;\n    var kind = mediaDeviceInfo.kind;\n    var index = this._unknownDeviceIndexes[kind][id];\n\n    if (!index) {\n      index = Object.keys(this._unknownDeviceIndexes[kind]).length + 1;\n      this._unknownDeviceIndexes[kind][id] = index;\n    }\n\n    return index;\n  };\n  /**\n   * Initialize output device enumeration.\n   */\n\n\n  AudioHelper.prototype._initializeEnumeration = function () {\n    var _this = this;\n\n    if (!this._mediaDevices) {\n      throw new errors_1.NotSupportedError('Enumeration is not supported');\n    }\n\n    if (this._mediaDevices.addEventListener) {\n      this._mediaDevices.addEventListener('devicechange', this._updateAvailableDevices);\n\n      this._mediaDevices.addEventListener('deviceinfochange', this._updateAvailableDevices);\n    }\n\n    this._updateAvailableDevices().then(function () {\n      if (!_this.isOutputSelectionSupported) {\n        return;\n      }\n\n      Promise.all([_this.speakerDevices.set('default'), _this.ringtoneDevices.set('default')]).catch(function (reason) {\n        _this._log.warn(\"Warning: Unable to set audio output devices. \" + reason);\n      });\n    });\n  };\n  /**\n   * Stop the tracks on the current input stream before replacing it with the passed stream.\n   * @param stream - The new stream\n   */\n\n\n  AudioHelper.prototype._replaceStream = function (stream) {\n    if (this._inputStream) {\n      this._inputStream.getTracks().forEach(function (track) {\n        track.stop();\n      });\n    }\n\n    this._inputStream = stream;\n  };\n  /**\n   * Replace the current input device with a new device by ID.\n   * @param deviceId - An ID of a device to replace the existing\n   *   input device with.\n   * @param forceGetUserMedia - If true, getUserMedia will be called even if\n   *   the specified device is already active.\n   */\n\n\n  AudioHelper.prototype._setInputDevice = function (deviceId, forceGetUserMedia) {\n    var _this = this;\n\n    if (typeof deviceId !== 'string') {\n      return Promise.reject(new errors_1.InvalidArgumentError('Must specify the device to set'));\n    }\n\n    var device = this.availableInputDevices.get(deviceId);\n\n    if (!device) {\n      return Promise.reject(new errors_1.InvalidArgumentError(\"Device not found: \" + deviceId));\n    }\n\n    if (this._inputDevice && this._inputDevice.deviceId === deviceId && this._inputStream) {\n      if (!forceGetUserMedia) {\n        return Promise.resolve();\n      } // If the currently active track is still in readyState `live`, gUM may return the same track\n      // rather than returning a fresh track.\n\n\n      this._inputStream.getTracks().forEach(function (track) {\n        track.stop();\n      });\n    }\n\n    var constraints = {\n      audio: Object.assign({\n        deviceId: {\n          exact: deviceId\n        }\n      }, this.audioConstraints)\n    };\n    return this._getUserMedia(constraints).then(function (stream) {\n      return _this._onActiveInputChanged(stream).then(function () {\n        _this._replaceStream(stream);\n\n        _this._inputDevice = device;\n\n        _this._maybeStartPollingVolume();\n      });\n    });\n  };\n  /**\n   * Update a set of devices.\n   * @param updatedDevices - An updated list of available Devices\n   * @param availableDevices - The previous list of available Devices\n   * @param removeLostDevice - The method to call if a previously available Device is\n   *   no longer available.\n   */\n\n\n  AudioHelper.prototype._updateDevices = function (updatedDevices, availableDevices, removeLostDevice) {\n    var _this = this;\n\n    var updatedDeviceIds = updatedDevices.map(function (d) {\n      return d.deviceId;\n    });\n    var knownDeviceIds = Array.from(availableDevices.values()).map(function (d) {\n      return d.deviceId;\n    });\n    var lostActiveDevices = []; // Remove lost devices\n\n    var lostDeviceIds = util_1.difference(knownDeviceIds, updatedDeviceIds);\n    lostDeviceIds.forEach(function (lostDeviceId) {\n      var lostDevice = availableDevices.get(lostDeviceId);\n\n      if (lostDevice) {\n        availableDevices.delete(lostDeviceId);\n\n        if (removeLostDevice(lostDevice)) {\n          lostActiveDevices.push(lostDevice);\n        }\n      }\n    }); // Add any new devices, or devices with updated labels\n\n    var deviceChanged = false;\n    updatedDevices.forEach(function (newDevice) {\n      var existingDevice = availableDevices.get(newDevice.deviceId);\n\n      var newMediaDeviceInfo = _this._wrapMediaDeviceInfo(newDevice);\n\n      if (!existingDevice || existingDevice.label !== newMediaDeviceInfo.label) {\n        availableDevices.set(newDevice.deviceId, newMediaDeviceInfo);\n        deviceChanged = true;\n      }\n    });\n\n    if (deviceChanged || lostDeviceIds.length) {\n      // Force a new gUM in case the underlying tracks of the active stream have changed. One\n      //   reason this might happen is when `default` is selected and set to a USB device,\n      //   then that device is unplugged or plugged back in. We can't check for the 'ended'\n      //   event or readyState because it is asynchronous and may take upwards of 5 seconds,\n      //   in my testing. (rrowland)\n      if (this.inputDevice !== null && this.inputDevice.deviceId === 'default') {\n        this._log.warn(\"Calling getUserMedia after device change to ensure that the           tracks of the active device (default) have not gone stale.\");\n\n        this._setInputDevice(this.inputDevice.deviceId, true);\n      }\n\n      this.emit('deviceChange', lostActiveDevices);\n    }\n  };\n  /**\n   * Disconnect the old input volume source, and create and connect a new one with the current\n   * input stream.\n   */\n\n\n  AudioHelper.prototype._updateVolumeSource = function () {\n    if (!this._inputStream || !this._audioContext || !this._inputVolumeAnalyser) {\n      return;\n    }\n\n    if (this._inputVolumeSource) {\n      this._inputVolumeSource.disconnect();\n    }\n\n    this._inputVolumeSource = this._audioContext.createMediaStreamSource(this._inputStream);\n\n    this._inputVolumeSource.connect(this._inputVolumeAnalyser);\n  };\n  /**\n   * Convert a MediaDeviceInfo to a IMediaDeviceInfoShim.\n   * @param mediaDeviceInfo - The info to convert\n   * @returns The converted shim\n   */\n\n\n  AudioHelper.prototype._wrapMediaDeviceInfo = function (mediaDeviceInfo) {\n    var options = {\n      deviceId: mediaDeviceInfo.deviceId,\n      groupId: mediaDeviceInfo.groupId,\n      kind: mediaDeviceInfo.kind,\n      label: mediaDeviceInfo.label\n    };\n\n    if (!options.label) {\n      if (options.deviceId === 'default') {\n        options.label = 'Default';\n      } else {\n        var index = this._getUnknownDeviceIndex(mediaDeviceInfo);\n\n        options.label = \"Unknown \" + kindAliases[options.kind] + \" Device \" + index;\n      }\n    }\n\n    return new MediaDeviceInfoShim(options);\n  };\n\n  return AudioHelper;\n}(events_1.EventEmitter);\n\n(function (AudioHelper) {})(AudioHelper || (AudioHelper = {}));\n\nexports.default = AudioHelper;","map":{"version":3,"sources":["../../lib/twilio/audiohelper.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n */\nimport { EventEmitter } from 'events';\nimport Device from './device';\nimport { InvalidArgumentError, NotSupportedError } from './errors';\nimport Log from './log';\nimport OutputDeviceCollection from './outputdevicecollection';\nimport * as defaultMediaDevices from './shims/mediadevices';\nimport { average, difference, isFirefox } from './util';\n\nconst MediaDeviceInfoShim = require('./shims/mediadeviceinfo');\n\n/**\n * Aliases for audio kinds, used for labelling.\n * @private\n */\nconst kindAliases: Record<string, string> = {\n  audioinput: 'Audio Input',\n  audiooutput: 'Audio Output',\n};\n\n/**\n * Provides input and output audio-based functionality in one convenient class.\n * @publicapi\n */\nclass AudioHelper extends EventEmitter {\n  /**\n   * The currently set audio constraints set by setAudioConstraints(). Starts as null.\n   */\n  get audioConstraints(): MediaTrackConstraints | null { return this._audioConstraints; }\n\n  /**\n   * A Map of all audio input devices currently available to the browser by their device ID.\n   */\n  availableInputDevices: Map<string, MediaDeviceInfo> = new Map();\n\n  /**\n   * A Map of all audio output devices currently available to the browser by their device ID.\n   */\n  availableOutputDevices: Map<string, MediaDeviceInfo> = new Map();\n\n  /**\n   * The active input device. Having no inputDevice specified by `setInputDevice()`\n   * will disable input selection related functionality.\n   */\n  get inputDevice(): MediaDeviceInfo | null { return this._inputDevice; }\n\n  /**\n   * The current input stream.\n   */\n  get inputStream(): MediaStream | null { return this._inputStream; }\n\n  /**\n   * False if the browser does not support `HTMLAudioElement.setSinkId()` or\n   * `MediaDevices.enumerateDevices()` and Twilio cannot facilitate output selection functionality.\n   */\n  isOutputSelectionSupported: boolean;\n\n  /**\n   * False if the browser does not support AudioContext and Twilio can not analyse the volume\n   * in real-time.\n   */\n  isVolumeSupported: boolean;\n\n  /**\n   * The current set of output devices that incoming ringtone audio is routed through.\n   * These are the sounds that may play while the user is away from the machine or not wearing\n   * their headset. It is important that this audio is heard. If all specified\n   * devices lost, this Set will revert to contain only the \"default\" device.\n   */\n  ringtoneDevices: OutputDeviceCollection;\n\n  /**\n   * The current set of output devices that call audio (`[voice, outgoing, disconnect, dtmf]`)\n   * is routed through. These are the sounds that are initiated by the user, or played while\n   * the user is otherwise present at the endpoint. If all specified devices are lost,\n   * this Set will revert to contain only the \"default\" device.\n   */\n  speakerDevices: OutputDeviceCollection;\n\n  /**\n   * The currently set audio constraints set by setAudioConstraints().\n   */\n  private _audioConstraints: MediaTrackConstraints | null = null;\n\n  /**\n   * An AudioContext to use.\n   */\n  private _audioContext?: AudioContext;\n\n  /**\n   * The `getUserMedia()` function to use.\n   */\n  private _getUserMedia: (constraints: MediaStreamConstraints) => Promise<MediaStream>;\n\n  /**\n   * The current input device.\n   */\n  private _inputDevice: MediaDeviceInfo | null = null;\n\n  /**\n   * The current input stream.\n   */\n  private _inputStream: MediaStream | null = null;\n\n  /**\n   * An AnalyserNode to use for input volume.\n   */\n  private _inputVolumeAnalyser?: AnalyserNode;\n\n  /**\n   * An MediaStreamSource to use for input volume.\n   */\n  private _inputVolumeSource?: MediaStreamAudioSourceNode;\n\n  /**\n   * Whether the {@link AudioHelper} is currently polling the input stream's volume.\n   */\n  private _isPollingInputVolume: boolean = false;\n\n  /**\n   * An instance of Logger to use.\n   */\n  private _log: Log = Log.getInstance();\n\n  /**\n   * The MediaDevices instance to use.\n   */\n  private _mediaDevices: AudioHelper.MediaDevicesLike | null;\n\n  /**\n   * Called with the new input stream when the active input is changed.\n   */\n  private _onActiveInputChanged: (stream: MediaStream | null) => Promise<void>;\n\n  /**\n   * A record of unknown devices (Devices without labels)\n   */\n  private _unknownDeviceIndexes: Record<string, Record<string, number>> = {\n    audioinput: { },\n    audiooutput: { },\n  };\n\n  /**\n   * @constructor\n   * @private\n   * @param onActiveOutputsChanged - A callback to be called when the user changes the active output devices.\n   * @param onActiveInputChanged - A callback to be called when the user changes the active input device.\n   * @param getUserMedia - The getUserMedia method to use.\n   * @param [options]\n   */\n  constructor(onActiveOutputsChanged: (type: 'ringtone' | 'speaker', outputIds: string[]) => Promise<void>,\n              onActiveInputChanged: (stream: MediaStream | null) => Promise<void>,\n              getUserMedia: (constraints: MediaStreamConstraints) => Promise<MediaStream>,\n              options?: AudioHelper.Options) {\n    super();\n\n    options = Object.assign({\n      AudioContext: typeof AudioContext !== 'undefined' && AudioContext,\n      setSinkId: typeof HTMLAudioElement !== 'undefined' && (HTMLAudioElement.prototype as any).setSinkId,\n    }, options);\n\n    this._getUserMedia = getUserMedia;\n    this._mediaDevices = options.mediaDevices || defaultMediaDevices;\n    this._onActiveInputChanged = onActiveInputChanged;\n\n    const isAudioContextSupported: boolean = !!(options.AudioContext || options.audioContext);\n    const isEnumerationSupported: boolean = !!(this._mediaDevices && this._mediaDevices.enumerateDevices);\n    const isSetSinkSupported: boolean = typeof options.setSinkId === 'function';\n    this.isOutputSelectionSupported = isEnumerationSupported && isSetSinkSupported;\n    this.isVolumeSupported = isAudioContextSupported;\n\n    if (options.enabledSounds) {\n      this._addEnabledSounds(options.enabledSounds);\n    }\n\n    if (this.isVolumeSupported) {\n      this._audioContext = options.audioContext || options.AudioContext && new options.AudioContext();\n      if (this._audioContext) {\n        this._inputVolumeAnalyser = this._audioContext.createAnalyser();\n        this._inputVolumeAnalyser.fftSize = 32;\n        this._inputVolumeAnalyser.smoothingTimeConstant = 0.3;\n      }\n    }\n\n    this.ringtoneDevices = new OutputDeviceCollection('ringtone',\n      this.availableOutputDevices, onActiveOutputsChanged, this.isOutputSelectionSupported);\n    this.speakerDevices = new OutputDeviceCollection('speaker',\n      this.availableOutputDevices, onActiveOutputsChanged, this.isOutputSelectionSupported);\n\n    this.addListener('newListener', (eventName: string) => {\n      if (eventName === 'inputVolume') {\n        this._maybeStartPollingVolume();\n      }\n    });\n\n    this.addListener('removeListener', (eventName: string) => {\n      if (eventName === 'inputVolume') {\n        this._maybeStopPollingVolume();\n      }\n    });\n\n    this.once('newListener', () => {\n      // NOTE (rrowland): Ideally we would only check isEnumerationSupported here, but\n      //   in at least one browser version (Tested in FF48) enumerateDevices actually\n      //   returns bad data for the listed devices. Instead, we check for\n      //   isOutputSelectionSupported to avoid these quirks that may negatively affect customers.\n      if (!this.isOutputSelectionSupported) {\n        this._log.warn('Warning: This browser does not support audio output selection.');\n      }\n\n      if (!this.isVolumeSupported) {\n        this._log.warn(`Warning: This browser does not support Twilio's volume indicator feature.`);\n      }\n    });\n\n    if (isEnumerationSupported) {\n      this._initializeEnumeration();\n    }\n  }\n\n  /**\n   * Start polling volume if it's supported and there's an input stream to poll.\n   * @private\n   */\n  _maybeStartPollingVolume(): void {\n    if (!this.isVolumeSupported || !this._inputStream) { return; }\n\n    this._updateVolumeSource();\n\n    if (this._isPollingInputVolume || !this._inputVolumeAnalyser) { return; }\n\n    const bufferLength: number = this._inputVolumeAnalyser.frequencyBinCount;\n    const buffer: Uint8Array = new Uint8Array(bufferLength);\n\n    this._isPollingInputVolume = true;\n\n    const emitVolume = (): void => {\n      if (!this._isPollingInputVolume) { return; }\n\n      if (this._inputVolumeAnalyser) {\n        this._inputVolumeAnalyser.getByteFrequencyData(buffer);\n        const inputVolume: number = average(buffer);\n\n        this.emit('inputVolume', inputVolume / 255);\n      }\n\n      requestAnimationFrame(emitVolume);\n    };\n\n    requestAnimationFrame(emitVolume);\n  }\n\n  /**\n   * Stop polling volume if it's currently polling and there are no listeners.\n   * @private\n   */\n  _maybeStopPollingVolume(): void {\n    if (!this.isVolumeSupported) { return; }\n\n    if (!this._isPollingInputVolume || (this._inputStream && this.listenerCount('inputVolume'))) {\n      return;\n    }\n\n    if (this._inputVolumeSource) {\n      this._inputVolumeSource.disconnect();\n      delete this._inputVolumeSource;\n    }\n\n    this._isPollingInputVolume = false;\n  }\n\n  /**\n   * Unbind the listeners from mediaDevices.\n   * @private\n   */\n  _unbind(): void {\n    if (!this._mediaDevices) {\n      throw new NotSupportedError('Enumeration is not supported');\n    }\n\n    if (this._mediaDevices.removeEventListener) {\n      this._mediaDevices.removeEventListener('devicechange', this._updateAvailableDevices);\n      this._mediaDevices.removeEventListener('deviceinfochange', this._updateAvailableDevices);\n    }\n  }\n\n  /**\n   * Set the MediaTrackConstraints to be applied on every getUserMedia call for new input\n   * device audio. Any deviceId specified here will be ignored. Instead, device IDs should\n   * be specified using {@link AudioHelper#setInputDevice}. The returned Promise resolves\n   * when the media is successfully reacquired, or immediately if no input device is set.\n   * @param audioConstraints - The MediaTrackConstraints to apply.\n   */\n  setAudioConstraints(audioConstraints: MediaTrackConstraints): Promise<void> {\n    this._audioConstraints = Object.assign({ }, audioConstraints);\n    delete this._audioConstraints.deviceId;\n\n    return this.inputDevice\n      ? this._setInputDevice(this.inputDevice.deviceId, true)\n      : Promise.resolve();\n  }\n\n  /**\n   * Replace the current input device with a new device by ID.\n   * @param deviceId - An ID of a device to replace the existing\n   *   input device with.\n   */\n  setInputDevice(deviceId: string): Promise<void> {\n    return !isFirefox()\n      ? this._setInputDevice(deviceId, false)\n      : Promise.reject(new NotSupportedError('Firefox does not currently support opening multiple ' +\n        'audio input tracks simultaneously, even across different tabs. As a result, ' +\n        'Device.audio.setInputDevice is disabled on Firefox until support is added.\\n' +\n        'Related BugZilla thread: https://bugzilla.mozilla.org/show_bug.cgi?id=1299324'));\n  }\n\n  /**\n   * Unset the MediaTrackConstraints to be applied on every getUserMedia call for new input\n   * device audio. The returned Promise resolves when the media is successfully reacquired,\n   * or immediately if no input device is set.\n   */\n  unsetAudioConstraints(): Promise<void> {\n    this._audioConstraints = null;\n    return this.inputDevice\n      ? this._setInputDevice(this.inputDevice.deviceId, true)\n      : Promise.resolve();\n  }\n\n  /**\n   * Unset the input device, stopping the tracks. This should only be called when not in a connection, and\n   *   will not allow removal of the input device during a live call.\n   */\n  unsetInputDevice(): Promise<void> {\n    if (!this.inputDevice) { return Promise.resolve(); }\n\n    return this._onActiveInputChanged(null).then(() => {\n      this._replaceStream(null);\n      this._inputDevice = null;\n      this._maybeStopPollingVolume();\n    });\n  }\n\n  /**\n   * Merge the passed enabledSounds into {@link AudioHelper}. Currently used to merge the deprecated\n   *   Device.sounds object onto the new {@link AudioHelper} interface. Mutates\n   *   by reference, sharing state between {@link Device} and {@link AudioHelper}.\n   * @param enabledSounds - The initial sound settings to merge.\n   * @private\n   */\n  private _addEnabledSounds(enabledSounds: { [name: string]: boolean }) {\n    function setValue(key: Device.ToggleableSound, value: boolean) {\n      if (typeof value !== 'undefined') {\n        enabledSounds[key] = value;\n      }\n\n      return enabledSounds[key];\n    }\n\n    Object.keys(enabledSounds).forEach(key => {\n      (this as any)[key] = setValue.bind(null, key);\n    });\n  }\n\n  /**\n   * Get the index of an un-labeled Device.\n   * @param mediaDeviceInfo\n   * @returns The index of the passed MediaDeviceInfo\n   */\n  private _getUnknownDeviceIndex(mediaDeviceInfo: MediaDeviceInfo): number {\n    const id: string = mediaDeviceInfo.deviceId;\n    const kind: string = mediaDeviceInfo.kind;\n\n    let index: number = this._unknownDeviceIndexes[kind][id];\n    if (!index) {\n      index = Object.keys(this._unknownDeviceIndexes[kind]).length + 1;\n      this._unknownDeviceIndexes[kind][id] = index;\n    }\n\n    return index;\n  }\n\n  /**\n   * Initialize output device enumeration.\n   */\n  private _initializeEnumeration(): void {\n    if (!this._mediaDevices) {\n      throw new NotSupportedError('Enumeration is not supported');\n    }\n\n    if (this._mediaDevices.addEventListener) {\n      this._mediaDevices.addEventListener('devicechange', this._updateAvailableDevices);\n      this._mediaDevices.addEventListener('deviceinfochange', this._updateAvailableDevices);\n    }\n\n    this._updateAvailableDevices().then(() => {\n      if (!this.isOutputSelectionSupported) { return; }\n\n      Promise.all([\n        this.speakerDevices.set('default'),\n        this.ringtoneDevices.set('default'),\n      ]).catch(reason => {\n        this._log.warn(`Warning: Unable to set audio output devices. ${reason}`);\n      });\n    });\n  }\n\n  /**\n   * Remove an input device from inputs\n   * @param lostDevice\n   * @returns Whether the device was active\n   */\n  private _removeLostInput = (lostDevice: MediaDeviceInfo): boolean => {\n    if (!this.inputDevice || this.inputDevice.deviceId !== lostDevice.deviceId) {\n      return false;\n    }\n\n    this._replaceStream(null);\n    this._inputDevice = null;\n    this._maybeStopPollingVolume();\n\n    const defaultDevice: MediaDeviceInfo = this.availableInputDevices.get('default')\n      || Array.from(this.availableInputDevices.values())[0];\n\n    if (defaultDevice) {\n      this.setInputDevice(defaultDevice.deviceId);\n    }\n\n    return true;\n  }\n\n  /**\n   * Remove an input device from outputs\n   * @param lostDevice\n   * @returns Whether the device was active\n   */\n  private _removeLostOutput = (lostDevice: MediaDeviceInfo): boolean => {\n    const wasSpeakerLost: boolean = this.speakerDevices.delete(lostDevice);\n    const wasRingtoneLost: boolean = this.ringtoneDevices.delete(lostDevice);\n    return wasSpeakerLost || wasRingtoneLost;\n  }\n\n  /**\n   * Stop the tracks on the current input stream before replacing it with the passed stream.\n   * @param stream - The new stream\n   */\n  private _replaceStream(stream: MediaStream | null): void {\n    if (this._inputStream) {\n      this._inputStream.getTracks().forEach(track => {\n        track.stop();\n      });\n    }\n\n    this._inputStream = stream;\n  }\n\n  /**\n   * Replace the current input device with a new device by ID.\n   * @param deviceId - An ID of a device to replace the existing\n   *   input device with.\n   * @param forceGetUserMedia - If true, getUserMedia will be called even if\n   *   the specified device is already active.\n   */\n  private _setInputDevice(deviceId: string, forceGetUserMedia: boolean): Promise<void> {\n    if (typeof deviceId !== 'string') {\n      return Promise.reject(new InvalidArgumentError('Must specify the device to set'));\n    }\n\n    const device: MediaDeviceInfo | undefined = this.availableInputDevices.get(deviceId);\n    if (!device) {\n      return Promise.reject(new InvalidArgumentError(`Device not found: ${deviceId}`));\n    }\n\n    if (this._inputDevice && this._inputDevice.deviceId === deviceId && this._inputStream) {\n      if (!forceGetUserMedia) {\n        return Promise.resolve();\n      }\n\n      // If the currently active track is still in readyState `live`, gUM may return the same track\n      // rather than returning a fresh track.\n      this._inputStream.getTracks().forEach(track => {\n        track.stop();\n      });\n    }\n\n    const constraints = { audio: Object.assign({ deviceId: { exact: deviceId } }, this.audioConstraints) };\n    return this._getUserMedia(constraints).then((stream: MediaStream) => {\n      return this._onActiveInputChanged(stream).then(() => {\n        this._replaceStream(stream);\n        this._inputDevice = device;\n        this._maybeStartPollingVolume();\n      });\n    });\n  }\n\n  /**\n   * Update the available input and output devices\n   */\n  private _updateAvailableDevices = (): Promise<void> => {\n    if (!this._mediaDevices) {\n      return Promise.reject('Enumeration not supported');\n    }\n\n    return this._mediaDevices.enumerateDevices().then((devices: MediaDeviceInfo[]) => {\n      this._updateDevices(devices.filter((d: MediaDeviceInfo) => d.kind === 'audiooutput'),\n        this.availableOutputDevices,\n        this._removeLostOutput);\n\n      this._updateDevices(devices.filter((d: MediaDeviceInfo) => d.kind === 'audioinput'),\n        this.availableInputDevices,\n        this._removeLostInput);\n\n      const defaultDevice = this.availableOutputDevices.get('default')\n        || Array.from(this.availableOutputDevices.values())[0];\n\n      [this.speakerDevices, this.ringtoneDevices].forEach(outputDevices => {\n        if (!outputDevices.get().size && this.availableOutputDevices.size && this.isOutputSelectionSupported) {\n          outputDevices.set(defaultDevice.deviceId)\n            .catch((reason) => {\n              this._log.warn(`Unable to set audio output devices. ${reason}`);\n            });\n        }\n      });\n    });\n  }\n\n  /**\n   * Update a set of devices.\n   * @param updatedDevices - An updated list of available Devices\n   * @param availableDevices - The previous list of available Devices\n   * @param removeLostDevice - The method to call if a previously available Device is\n   *   no longer available.\n   */\n  private _updateDevices(updatedDevices: MediaDeviceInfo[],\n                         availableDevices: Map<string, MediaDeviceInfo>,\n                         removeLostDevice: (lostDevice: MediaDeviceInfo) => boolean): void {\n    const updatedDeviceIds: string[] = updatedDevices.map(d => d.deviceId);\n    const knownDeviceIds: string[] = Array.from(availableDevices.values()).map(d => d.deviceId);\n    const lostActiveDevices: MediaDeviceInfo[] = [];\n\n    // Remove lost devices\n    const lostDeviceIds: string[] = difference(knownDeviceIds, updatedDeviceIds);\n    lostDeviceIds.forEach((lostDeviceId: string) => {\n      const lostDevice: MediaDeviceInfo | undefined = availableDevices.get(lostDeviceId);\n      if (lostDevice) {\n        availableDevices.delete(lostDeviceId);\n        if (removeLostDevice(lostDevice)) { lostActiveDevices.push(lostDevice); }\n      }\n    });\n\n    // Add any new devices, or devices with updated labels\n    let deviceChanged: boolean = false;\n    updatedDevices.forEach(newDevice => {\n      const existingDevice: MediaDeviceInfo | undefined = availableDevices.get(newDevice.deviceId);\n      const newMediaDeviceInfo: MediaDeviceInfo = this._wrapMediaDeviceInfo(newDevice);\n\n      if (!existingDevice || existingDevice.label !== newMediaDeviceInfo.label) {\n        availableDevices.set(newDevice.deviceId, newMediaDeviceInfo);\n        deviceChanged = true;\n      }\n    });\n\n    if (deviceChanged || lostDeviceIds.length) {\n      // Force a new gUM in case the underlying tracks of the active stream have changed. One\n      //   reason this might happen is when `default` is selected and set to a USB device,\n      //   then that device is unplugged or plugged back in. We can't check for the 'ended'\n      //   event or readyState because it is asynchronous and may take upwards of 5 seconds,\n      //   in my testing. (rrowland)\n      if (this.inputDevice !== null && this.inputDevice.deviceId === 'default') {\n        this._log.warn(`Calling getUserMedia after device change to ensure that the \\\n          tracks of the active device (default) have not gone stale.`);\n        this._setInputDevice(this.inputDevice.deviceId, true);\n      }\n\n      this.emit('deviceChange', lostActiveDevices);\n    }\n  }\n\n  /**\n   * Disconnect the old input volume source, and create and connect a new one with the current\n   * input stream.\n   */\n  private _updateVolumeSource(): void {\n    if (!this._inputStream || !this._audioContext || !this._inputVolumeAnalyser) {\n      return;\n    }\n\n    if (this._inputVolumeSource) {\n      this._inputVolumeSource.disconnect();\n    }\n\n    this._inputVolumeSource = this._audioContext.createMediaStreamSource(this._inputStream);\n    this._inputVolumeSource.connect(this._inputVolumeAnalyser);\n  }\n\n  /**\n   * Convert a MediaDeviceInfo to a IMediaDeviceInfoShim.\n   * @param mediaDeviceInfo - The info to convert\n   * @returns The converted shim\n   */\n  private _wrapMediaDeviceInfo(mediaDeviceInfo: MediaDeviceInfo): MediaDeviceInfo {\n    const options: Record<string, string> = {\n      deviceId: mediaDeviceInfo.deviceId,\n      groupId: mediaDeviceInfo.groupId,\n      kind: mediaDeviceInfo.kind,\n      label: mediaDeviceInfo.label,\n    };\n\n    if (!options.label) {\n      if (options.deviceId === 'default') {\n        options.label = 'Default';\n      } else {\n        const index: number = this._getUnknownDeviceIndex(mediaDeviceInfo);\n        options.label = `Unknown ${kindAliases[options.kind]} Device ${index}`;\n      }\n    }\n\n    return new MediaDeviceInfoShim(options) as MediaDeviceInfo;\n  }\n}\n\nnamespace AudioHelper {\n  /**\n   * Emitted when the available set of Devices changes.\n   * @param lostActiveDevices - An array containing any Devices that were previously active\n   * that were lost as a result of this deviceChange event.\n   * @example `device.audio.on('deviceChange', lostActiveDevices => { })`\n   * @event\n   * @private\n   */\n  declare function deviceChangeEvent(lostActiveDevices: MediaDeviceInfo[]): void;\n\n  /**\n   * Emitted on `requestAnimationFrame` (up to 60fps, depending on browser) with\n   *   the current input and output volumes, as a percentage of maximum\n   *   volume, between -100dB and -30dB. Represented by a floating point\n   *   number.\n   * @param inputVolume - A floating point number between 0.0 and 1.0 inclusive.\n   * @example `device.audio.on('inputVolume', volume => { })`\n   * @event\n   */\n  declare function inputVolumeEvent(inputVolume: number): void;\n\n  /**\n   * An object like MediaDevices.\n   * @private\n   */\n  export interface MediaDevicesLike {\n    addEventListener?: (eventName: string, handler: (...args: any[]) => void) => void;\n    enumerateDevices: (...args: any[]) => any;\n    getUserMedia: (...args: any[]) => any;\n    removeEventListener?: (eventName: string, handler: (...args: any[]) => void) => void;\n  }\n\n  /**\n   * Options that can be passed to the AudioHelper constructor\n   * @private\n   */\n  export interface Options {\n    /**\n     * A custom replacement for the AudioContext constructor.\n     */\n    AudioContext?: typeof AudioContext;\n\n    /**\n     * An existing AudioContext instance to use.\n     */\n    audioContext?: AudioContext;\n\n    /**\n     * A Record of sounds. This is modified by reference, and is used to\n     * maintain backward-compatibility. This should be removed or refactored in 2.0.\n     * TODO: Remove / refactor in 2.0. (CLIENT-5302)\n     */\n    enabledSounds?: Record<Device.ToggleableSound, boolean>;\n\n    /**\n     * A custom MediaDevices instance to use.\n     */\n    mediaDevices?: AudioHelper.MediaDevicesLike;\n\n    /**\n     * A custom setSinkId function to use.\n     */\n    setSinkId?: (sinkId: string) => Promise<void>;\n  }\n}\n\nexport default AudioHelper;\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}