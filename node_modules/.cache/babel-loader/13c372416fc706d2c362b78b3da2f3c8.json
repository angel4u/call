{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/root/twilio-phone-client/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _slicedToArray = require(\"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subscriptions = void 0;\n\nvar operation_retrier_1 = require(\"operation-retrier\");\n\nvar syncerror_1 = require(\"./utils/syncerror\");\n\nvar logger_1 = require(\"./utils/logger\");\n\nvar twilsock_1 = require(\"twilsock\");\n/**\n * A data container used by the Subscriptions class to track subscribed entities' local\n * representations and their state.\n */\n\n\nvar SubscribedEntity = /*#__PURE__*/function () {\n  function SubscribedEntity(entity) {\n    _classCallCheck(this, SubscribedEntity);\n\n    this.localObject = entity;\n    this.pendingCorrelationId = null;\n    this.pendingAction = null;\n    this.established = false;\n    this.retryCount = 0;\n  }\n\n  _createClass(SubscribedEntity, [{\n    key: \"update\",\n    value: function update(event, isStrictlyOrdered) {\n      this.localObject._update(event, isStrictlyOrdered);\n    }\n  }, {\n    key: \"updatePending\",\n    value: function updatePending(action, correlationId) {\n      this.pendingAction = action;\n      this.pendingCorrelationId = correlationId;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.updatePending(null, null);\n      this.retryCount = 0;\n      this.established = false;\n      this.setSubscriptionState('none');\n    }\n  }, {\n    key: \"markAsFailed\",\n    value: function markAsFailed(message) {\n      this.rejectedWithError = message.error;\n      this.updatePending(null, null);\n      this.localObject.reportFailure(new syncerror_1.SyncError(\"Failed to subscribe on service events: \".concat(message.error.message), message.error.status, message.error.code));\n    }\n  }, {\n    key: \"complete\",\n    value: function complete(eventId) {\n      this.updatePending(null, null);\n      this.established = true;\n\n      this.localObject._advanceLastEventId(eventId);\n    }\n  }, {\n    key: \"setSubscriptionState\",\n    value: function setSubscriptionState(newState) {\n      this.localObject._setSubscriptionState(newState);\n    }\n  }, {\n    key: \"sid\",\n    get: function get() {\n      return this.localObject.sid;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.localObject.type;\n    }\n  }, {\n    key: \"lastEventId\",\n    get: function get() {\n      return this.localObject.lastEventId;\n    } // below properties are specific to Insights only\n\n  }, {\n    key: \"indexName\",\n    get: function get() {\n      return this.localObject.indexName;\n    }\n  }, {\n    key: \"queryString\",\n    get: function get() {\n      return this.localObject.queryString;\n    }\n  }, {\n    key: \"isEstablished\",\n    get: function get() {\n      return this.established;\n    }\n  }]);\n\n  return SubscribedEntity;\n}();\n/**\n * @class Subscriptions\n * @classdesc A manager which, in batches of varying size, continuously persists the\n *      subscription intent of the caller to the Sync backend until it achieves a\n *      converged state.\n */\n\n\nvar Subscriptions = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * Prepares a new Subscriptions manager object with zero subscribed or persisted subscriptions.\n   *\n   * @param {object} config may include a key 'backoffConfig', wherein any of the parameters\n   *      of Backoff.exponential (from npm 'backoff') are valid and will override the defaults.\n   *\n   * @param {Network} must be a viable running Sync Network object, useful for routing requests.\n   */\n  function Subscriptions(services) {\n    var _this = this;\n\n    _classCallCheck(this, Subscriptions);\n\n    this.isConnected = false;\n    this.maxBatchSize = 100; // If the server includes a `ttl_in_s` attribute in the poke response, subscriptionTtlTimer is started for that duration\n    // such that when it fires, it repokes the entire sync set (i.e., emulates a reconnect). Every reconnect resets the timer.\n    // After the timer has fired, the first poke request includes a `reason: ttl` attribute in the body.\n\n    this.subscriptionTtlTimer = null;\n    this.pendingPokeReason = null;\n    this.services = services;\n    this.subscriptions = new Map();\n    this.persisted = new Map();\n    this.latestPokeResponseArrivalTimestampByCorrelationId = new Map();\n    var defaultBackoffConfig = {\n      randomisationFactor: 0.2,\n      initialDelay: 100,\n      maxDelay: 2 * 60 * 1000\n    };\n    this.backoff = operation_retrier_1.Backoff.exponential(Object.assign(defaultBackoffConfig, this.services.config.backoffConfig)); // This block is triggered by #_persist. Every request is executed in a series of (ideally 1)\n    // backoff 'ready' event, at which point a new subscription set is calculated.\n\n    this.backoff.on('ready', function () {\n      var _this$getSubscription = _this.getSubscriptionUpdateBatch(),\n          action = _this$getSubscription.action,\n          subscriptionRequests = _this$getSubscription.subscriptions;\n\n      if (action) {\n        _this.applyNewSubscriptionUpdateBatch(action, subscriptionRequests);\n      } else {\n        _this.backoff.reset();\n\n        logger_1.default.debug('All subscriptions resolved.');\n      }\n    });\n  }\n\n  _createClass(Subscriptions, [{\n    key: \"getSubscriptionUpdateBatch\",\n    value: function getSubscriptionUpdateBatch() {\n      function subtract(these, those, action, limit) {\n        var result = [];\n\n        var _iterator = _createForOfIteratorHelper(these),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n                thisKey = _step$value[0],\n                thisValue = _step$value[1];\n\n            var otherValue = those.get(thisKey);\n\n            if (!otherValue && action !== thisValue.pendingAction && !thisValue.rejectedWithError) {\n              result.push(thisValue);\n\n              if (limit && result.length >= limit) {\n                break;\n              }\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        return result;\n      }\n\n      var listToAdd = subtract(this.subscriptions, this.persisted, 'establish', this.maxBatchSize);\n\n      if (listToAdd.length > 0) {\n        return {\n          action: 'establish',\n          subscriptions: listToAdd\n        };\n      }\n\n      var listToRemove = subtract(this.persisted, this.subscriptions, 'cancel', this.maxBatchSize);\n\n      if (listToRemove.length > 0) {\n        return {\n          action: 'cancel',\n          subscriptions: listToRemove\n        };\n      }\n\n      return {\n        action: null,\n        subscriptions: null\n      };\n    }\n  }, {\n    key: \"persist\",\n    value: function persist() {\n      this.backoff.backoff();\n    }\n  }, {\n    key: \"applyNewSubscriptionUpdateBatch\",\n    value: function () {\n      var _applyNewSubscriptionUpdateBatch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(action, requests) {\n        var _this2 = this;\n\n        var correlationId, _iterator2, _step2, subscribed, reason, response, newMaxBatchSize, subscriptionTtlInS, isNumeric, isValidTtl, estimatedDeliveryInMs, _isNumeric, isValidTimeout, _iterator3, _step3, attemptedSubscription;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.isConnected) {\n                  _context.next = 4;\n                  break;\n                }\n\n                logger_1.default.debug(\"Twilsock connection (required for subscription) not ready; waiting\\u2026\");\n                this.backoff.reset();\n                return _context.abrupt(\"return\");\n\n              case 4:\n                // Keeping in mind that events may begin flowing _before_ we receive the response\n                requests = this.processLocalActions(action, requests);\n                correlationId = new Date().getTime();\n                _iterator2 = _createForOfIteratorHelper(requests);\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    subscribed = _step2.value;\n                    this.recordActionAttemptOn(subscribed, action, correlationId);\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n\n                reason = this.pendingPokeReason;\n                this.pendingPokeReason = null; // Send this batch to the service\n\n                _context.prev = 10;\n                _context.next = 13;\n                return this.request(action, correlationId, reason, requests);\n\n              case 13:\n                response = _context.sent;\n                newMaxBatchSize = response.body.max_batch_size;\n\n                if (!isNaN(parseInt(newMaxBatchSize)) && isFinite(newMaxBatchSize) && newMaxBatchSize > 0) {\n                  this.maxBatchSize = newMaxBatchSize;\n                }\n\n                if (!this.subscriptionTtlTimer) {\n                  subscriptionTtlInS = response.body.ttl_in_s;\n                  isNumeric = !isNaN(parseFloat(subscriptionTtlInS)) && isFinite(subscriptionTtlInS);\n                  isValidTtl = isNumeric && subscriptionTtlInS > 0;\n\n                  if (isValidTtl) {\n                    this.subscriptionTtlTimer = setTimeout(function () {\n                      return _this2.onSubscriptionTtlElapsed();\n                    }, subscriptionTtlInS * 1000);\n                  }\n                }\n\n                if (action === 'establish') {\n                  estimatedDeliveryInMs = response.body.estimated_delivery_in_ms;\n                  _isNumeric = !isNaN(parseFloat(estimatedDeliveryInMs)) && isFinite(estimatedDeliveryInMs);\n                  isValidTimeout = _isNumeric && estimatedDeliveryInMs > 0;\n\n                  if (isValidTimeout) {\n                    setTimeout(function () {\n                      return _this2.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests);\n                    }, estimatedDeliveryInMs);\n                  } else {\n                    logger_1.default.error(\"Invalid timeout: \".concat(estimatedDeliveryInMs));\n                  }\n\n                  requests.filter(function (r) {\n                    return r.pendingCorrelationId === correlationId;\n                  }).forEach(function (r) {\n                    return r.setSubscriptionState('response_in_flight');\n                  });\n                }\n\n                this.backoff.reset();\n                _context.next = 26;\n                break;\n\n              case 21:\n                _context.prev = 21;\n                _context.t0 = _context[\"catch\"](10);\n                _iterator3 = _createForOfIteratorHelper(requests);\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    attemptedSubscription = _step3.value;\n                    this.recordActionFailureOn(attemptedSubscription, action);\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n                if (_context.t0 instanceof twilsock_1.TransportUnavailableError) {\n                  logger_1.default.debug(\"Twilsock connection (required for subscription) not ready (c:\".concat(correlationId, \"); waiting\\u2026\"));\n                  this.backoff.reset();\n                } else {\n                  logger_1.default.debug(\"Failed an attempt to \".concat(action, \" subscriptions (c:\").concat(correlationId, \"); retrying\"), _context.t0);\n                  this.persist();\n                }\n\n              case 26:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[10, 21]]);\n      }));\n\n      function applyNewSubscriptionUpdateBatch(_x, _x2) {\n        return _applyNewSubscriptionUpdateBatch.apply(this, arguments);\n      }\n\n      return applyNewSubscriptionUpdateBatch;\n    }()\n  }, {\n    key: \"verifyPokeDelivery\",\n    value: function verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests) {\n      var _this3 = this;\n\n      var lastReceived = this.latestPokeResponseArrivalTimestampByCorrelationId.get(correlationId);\n      var silencePeriod = lastReceived ? new Date().getTime() - lastReceived : estimatedDeliveryInMs;\n\n      if (silencePeriod >= estimatedDeliveryInMs) {\n        // If we haven't received _any_ responses from that poke request for the duration of estimated_delivery_in_ms, poke again\n        requests.filter(function (r) {\n          return r.pendingCorrelationId === correlationId;\n        }).forEach(function (r) {\n          r.updatePending(null, null);\n          r.retryCount++;\n\n          _this3.persisted.delete(r.sid);\n        });\n        this.persist();\n        this.latestPokeResponseArrivalTimestampByCorrelationId.delete(correlationId);\n      } else {\n        // Otherwise, the poke responses are probably in transit and we should wait for them\n        var timeoutExtension = estimatedDeliveryInMs - silencePeriod;\n        setTimeout(function () {\n          return _this3.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests);\n        }, timeoutExtension);\n      }\n    }\n  }, {\n    key: \"processLocalActions\",\n    value: function processLocalActions(action, requests) {\n      if (action === 'cancel') {\n        return requests.filter(function (request) {\n          return !request.rejectedWithError;\n        });\n      }\n\n      return requests;\n    }\n  }, {\n    key: \"recordActionAttemptOn\",\n    value: function recordActionAttemptOn(attemptedSubscription, action, correlationId) {\n      attemptedSubscription.setSubscriptionState('request_in_flight');\n\n      if (action === 'establish') {\n        this.persisted.set(attemptedSubscription.sid, attemptedSubscription);\n        attemptedSubscription.updatePending(action, correlationId);\n      } else {\n        // cancel\n        var persistedSubscription = this.persisted.get(attemptedSubscription.sid);\n\n        if (persistedSubscription) {\n          persistedSubscription.updatePending(action, correlationId);\n        }\n      }\n    }\n  }, {\n    key: \"recordActionFailureOn\",\n    value: function recordActionFailureOn(attemptedSubscription, action) {\n      attemptedSubscription.setSubscriptionState('none');\n      attemptedSubscription.updatePending(null, null);\n\n      if (action === 'establish') {\n        this.persisted.delete(attemptedSubscription.sid);\n      }\n    }\n  }, {\n    key: \"request\",\n    value: function request(action, correlationId, reason, objects) {\n      var requests = objects.map(function (object) {\n        return {\n          object_sid: object.sid,\n          object_type: object.type,\n          last_event_id: action === 'establish' ? object.lastEventId : undefined,\n          index_name: action === 'establish' ? object.indexName : undefined,\n          query_string: action === 'establish' ? object.queryString : undefined\n        };\n      });\n      var retriedRequests = objects.filter(function (a) {\n        return a.retryCount > 0;\n      }).length;\n      logger_1.default.debug(\"Attempting '\".concat(action, \"' request (c:\").concat(correlationId, \"):\"), requests);\n      var requestBody = {\n        event_protocol_version: 3,\n        action: action,\n        correlation_id: correlationId,\n        retried_requests: retriedRequests,\n        ttl_in_s: -1,\n        requests: requests\n      };\n\n      if (reason === 'ttl') {\n        requestBody.reason = reason;\n      }\n\n      return this.services.network.post(this.services.config.subscriptionsUri, requestBody);\n    }\n    /**\n     * Establishes intent to be subscribed to this entity. That subscription will be effected\n     * asynchronously.\n     * If subscription to the given sid already exists, it will be overwritten.\n     *\n     * @param {String} sid should be a well-formed SID, uniquely identifying a single instance of a Sync entity.\n     * @param {Object} entity should represent the (singular) local representation of this entity.\n     *      Incoming events and modifications to the entity will be directed at the _update() function\n     *      of this provided reference.\n     *\n     * @return undefined\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(sid, entity) {\n      logger_1.default.debug(\"Establishing intent to subscribe to \".concat(sid));\n      var existingSubscription = this.subscriptions.get(sid);\n\n      if (existingSubscription && entity && existingSubscription.lastEventId === entity.lastEventId) {\n        // If last event id is the same as before - we're fine\n        return;\n      }\n\n      this.persisted.delete(sid);\n      this.subscriptions.set(sid, new SubscribedEntity(entity));\n      this.persist();\n    }\n    /**\n     * Establishes the caller's intent to no longer be subscribed to this entity. Following this\n     * call, no further events shall be routed to the local representation of the entity, even\n     * though a server-side subscription may take more time to actually terminate.\n     *\n     * @param {string} sid should be any well-formed SID, uniquely identifying a Sync entity.\n     *      This call only has meaningful effect if that entity is subscribed at the\n     *      time of call. Otherwise does nothing.\n     *\n     * @return undefined\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(sid) {\n      logger_1.default.debug(\"Establishing intent to unsubscribe from \".concat(sid));\n      var removed = this.subscriptions.delete(sid);\n\n      if (removed) {\n        this.persist();\n      }\n    }\n    /**\n     * The point of ingestion for remote incoming messages (e.g. new data was written to a map\n     * to which we are subscribed).\n     *\n     * @param {object} message is the full, unaltered body of the incoming notification.\n     *\n     * @return undefined\n     */\n\n  }, {\n    key: \"acceptMessage\",\n    value: function acceptMessage(message, isStrictlyOrdered) {\n      logger_1.default.trace('Subscriptions received', message);\n\n      if (message.correlation_id) {\n        this.latestPokeResponseArrivalTimestampByCorrelationId.set(message.correlation_id, new Date().getTime());\n      }\n\n      var event_type;\n\n      switch (message.event_type) {\n        case 'subscription_established':\n          this.applySubscriptionEstablishedMessage(message.event, message.correlation_id);\n          break;\n\n        case 'subscription_canceled':\n          this.applySubscriptionCancelledMessage(message.event, message.correlation_id);\n          break;\n\n        case 'subscription_failed':\n          this.applySubscriptionFailedMessage(message.event, message.correlation_id);\n          break;\n\n        case (event_type = message.event_type.match(/^(?:map|list|document|stream|live_query)_/) || {}).input:\n          {\n            var typedSid;\n\n            switch (event_type[0]) {\n              case 'map_':\n                typedSid = message.event.map_sid;\n                break;\n\n              case 'list_':\n                typedSid = message.event.list_sid;\n                break;\n\n              case 'document_':\n                typedSid = message.event.document_sid;\n                break;\n\n              case 'stream_':\n                typedSid = message.event.stream_sid;\n                break;\n\n              case 'live_query_':\n                typedSid = message.event.query_id; // hack to mark replay events for LiveQuery as strictly ordered, due to lack of special type of notification for them\n                // (normally only replay events would have `twilio.sync.event` type, but LiveQuery non-replay events were also assigned\n                // to this type in legacy clients, which we have to support now; hence a hack)\n\n                isStrictlyOrdered = false; // explicitly override it due to code in router.ts does not know about LiveQueries\n\n                if (message.strictly_ordered === true) {\n                  isStrictlyOrdered = true;\n                }\n\n                break;\n\n              default:\n                typedSid = undefined;\n            }\n\n            this.applyEventToSubscribedEntity(typedSid, message, isStrictlyOrdered);\n          }\n          break;\n\n        default:\n          logger_1.default.debug(\"Dropping unknown message type \".concat(message.event_type));\n          break;\n      }\n    }\n  }, {\n    key: \"applySubscriptionEstablishedMessage\",\n    value: function applySubscriptionEstablishedMessage(message, correlationId) {\n      var sid = message.object_sid;\n      var subscriptionIntent = this.persisted.get(message.object_sid);\n\n      if (subscriptionIntent && subscriptionIntent.pendingCorrelationId === correlationId) {\n        if (message.replay_status === 'interrupted') {\n          logger_1.default.debug(\"Event Replay for subscription to \".concat(sid, \" (c:\").concat(correlationId, \") interrupted; continuing eagerly.\"));\n          subscriptionIntent.updatePending(null, null);\n          this.persisted.delete(subscriptionIntent.sid);\n          this.backoff.reset();\n        } else if (message.replay_status === 'completed') {\n          logger_1.default.debug(\"Event Replay for subscription to \".concat(sid, \" (c:\").concat(correlationId, \") completed. Subscription is ready.\"));\n          subscriptionIntent.complete(message.last_event_id);\n          this.persisted.set(message.object_sid, subscriptionIntent);\n          subscriptionIntent.setSubscriptionState('established');\n          this.backoff.reset();\n        }\n      } else {\n        logger_1.default.debug(\"Late message for \".concat(message.object_sid, \" (c:\").concat(correlationId, \") dropped.\"));\n      }\n\n      this.persist();\n    }\n  }, {\n    key: \"applySubscriptionCancelledMessage\",\n    value: function applySubscriptionCancelledMessage(message, correlationId) {\n      var persistedSubscription = this.persisted.get(message.object_sid);\n\n      if (persistedSubscription && persistedSubscription.pendingCorrelationId === correlationId) {\n        persistedSubscription.updatePending(null, null);\n        persistedSubscription.setSubscriptionState('none');\n        this.persisted.delete(message.object_sid);\n      } else {\n        logger_1.default.debug(\"Late message for \".concat(message.object_sid, \" (c:\").concat(correlationId, \") dropped.\"));\n      }\n\n      this.persist();\n    }\n  }, {\n    key: \"applySubscriptionFailedMessage\",\n    value: function applySubscriptionFailedMessage(message, correlationId) {\n      var sid = message.object_sid;\n      var subscriptionIntent = this.subscriptions.get(sid);\n      var subscription = this.persisted.get(sid);\n\n      if (subscriptionIntent && subscription) {\n        if (subscription.pendingCorrelationId === correlationId) {\n          logger_1.default.error(\"Failed to subscribe on \".concat(subscription.sid), message.error);\n          subscription.markAsFailed(message);\n          subscription.setSubscriptionState('none');\n        }\n      } else if (!subscriptionIntent && subscription) {\n        this.persisted.delete(sid);\n        subscription.setSubscriptionState('none');\n      }\n\n      this.persist();\n    }\n  }, {\n    key: \"applyEventToSubscribedEntity\",\n    value: function applyEventToSubscribedEntity(sid, message, isStrictlyOrdered) {\n      var _this4 = this;\n\n      if (!sid) {\n        return;\n      } // Looking for subscription descriptor to check if poke has been completed\n\n\n      isStrictlyOrdered = isStrictlyOrdered || function () {\n        var subscription = _this4.persisted.get(sid);\n\n        return subscription && subscription.isEstablished;\n      }(); // Still searching for subscriptionIntents. User could remove subscription already\n\n\n      var subscriptionIntent = this.subscriptions.get(sid);\n\n      if (subscriptionIntent) {\n        message.event.type = message.event_type;\n        subscriptionIntent.update(message.event, isStrictlyOrdered);\n      } else {\n        logger_1.default.debug(\"Message dropped for SID '\".concat(sid, \"', for which there is no subscription.\"));\n      }\n    }\n  }, {\n    key: \"onConnectionStateChanged\",\n    value: function onConnectionStateChanged(isConnected) {\n      this.isConnected = isConnected;\n\n      if (isConnected) {\n        this.poke('reconnect');\n      }\n    }\n  }, {\n    key: \"onSubscriptionTtlElapsed\",\n    value: function onSubscriptionTtlElapsed() {\n      if (this.isConnected) {\n        this.poke('ttl');\n      }\n    }\n    /**\n     * Prompts a playback of any missed changes made to any subscribed object. This method\n     * should be invoked whenever the connectivity layer has experienced cross-cutting\n     * delivery failures that would affect the entire local sync set. Any tangible result\n     * of this operation will result in calls to the _update() function of subscribed\n     * Sync entities.\n     */\n\n  }, {\n    key: \"poke\",\n    value: function poke(reason) {\n      logger_1.default.debug(\"Triggering event replay for all subscriptions, reason=\".concat(reason));\n      this.pendingPokeReason = reason;\n\n      if (this.subscriptionTtlTimer) {\n        clearTimeout(this.subscriptionTtlTimer);\n        this.subscriptionTtlTimer = null;\n      }\n\n      var failedSubscriptions = [];\n\n      var _iterator4 = _createForOfIteratorHelper(this.persisted.values()),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _it = _step4.value;\n\n          _it.reset();\n\n          if (_it.rejectedWithError) {\n            failedSubscriptions.push(_it);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      this.persisted.clear();\n\n      for (var _i = 0, _failedSubscriptions = failedSubscriptions; _i < _failedSubscriptions.length; _i++) {\n        var it = _failedSubscriptions[_i];\n        this.persisted.set(it.sid, it);\n      }\n\n      this.persist();\n    }\n    /**\n     * Stops all communication, clears any subscription intent, and returns.\n     */\n\n  }, {\n    key: \"shutdown\",\n    value: function shutdown() {\n      this.backoff.reset();\n      this.subscriptions.clear();\n    }\n  }]);\n\n  return Subscriptions;\n}();\n\nexports.Subscriptions = Subscriptions;","map":{"version":3,"sources":["/root/twilio-phone-client/node_modules/twilio-sync/lib/subscriptions.js"],"names":["Object","defineProperty","exports","value","Subscriptions","operation_retrier_1","require","syncerror_1","logger_1","twilsock_1","SubscribedEntity","entity","localObject","pendingCorrelationId","pendingAction","established","retryCount","event","isStrictlyOrdered","_update","action","correlationId","updatePending","setSubscriptionState","message","rejectedWithError","error","reportFailure","SyncError","status","code","eventId","_advanceLastEventId","newState","_setSubscriptionState","sid","type","lastEventId","indexName","queryString","services","isConnected","maxBatchSize","subscriptionTtlTimer","pendingPokeReason","subscriptions","Map","persisted","latestPokeResponseArrivalTimestampByCorrelationId","defaultBackoffConfig","randomisationFactor","initialDelay","maxDelay","backoff","Backoff","exponential","assign","config","backoffConfig","on","getSubscriptionUpdateBatch","subscriptionRequests","applyNewSubscriptionUpdateBatch","reset","default","debug","subtract","these","those","limit","result","thisKey","thisValue","otherValue","get","push","length","listToAdd","listToRemove","requests","processLocalActions","Date","getTime","subscribed","recordActionAttemptOn","reason","request","response","newMaxBatchSize","body","max_batch_size","isNaN","parseInt","isFinite","subscriptionTtlInS","ttl_in_s","isNumeric","parseFloat","isValidTtl","setTimeout","onSubscriptionTtlElapsed","estimatedDeliveryInMs","estimated_delivery_in_ms","isValidTimeout","verifyPokeDelivery","filter","r","forEach","attemptedSubscription","recordActionFailureOn","TransportUnavailableError","persist","lastReceived","silencePeriod","delete","timeoutExtension","set","persistedSubscription","objects","map","object","object_sid","object_type","last_event_id","undefined","index_name","query_string","retriedRequests","a","requestBody","event_protocol_version","correlation_id","retried_requests","network","post","subscriptionsUri","existingSubscription","removed","trace","event_type","applySubscriptionEstablishedMessage","applySubscriptionCancelledMessage","applySubscriptionFailedMessage","match","input","typedSid","map_sid","list_sid","document_sid","stream_sid","query_id","strictly_ordered","applyEventToSubscribedEntity","subscriptionIntent","replay_status","complete","subscription","markAsFailed","isEstablished","update","poke","clearTimeout","failedSubscriptions","values","it","clear"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Subscriptions = void 0;\nconst operation_retrier_1 = require(\"operation-retrier\");\nconst syncerror_1 = require(\"./utils/syncerror\");\nconst logger_1 = require(\"./utils/logger\");\nconst twilsock_1 = require(\"twilsock\");\n/**\n * A data container used by the Subscriptions class to track subscribed entities' local\n * representations and their state.\n */\nclass SubscribedEntity {\n    constructor(entity) {\n        this.localObject = entity;\n        this.pendingCorrelationId = null;\n        this.pendingAction = null;\n        this.established = false;\n        this.retryCount = 0;\n    }\n    get sid() {\n        return this.localObject.sid;\n    }\n    get type() {\n        return this.localObject.type;\n    }\n    get lastEventId() {\n        return this.localObject.lastEventId;\n    }\n    // below properties are specific to Insights only\n    get indexName() {\n        return this.localObject.indexName;\n    }\n    get queryString() {\n        return this.localObject.queryString;\n    }\n    get isEstablished() {\n        return this.established;\n    }\n    update(event, isStrictlyOrdered) {\n        this.localObject._update(event, isStrictlyOrdered);\n    }\n    updatePending(action, correlationId) {\n        this.pendingAction = action;\n        this.pendingCorrelationId = correlationId;\n    }\n    reset() {\n        this.updatePending(null, null);\n        this.retryCount = 0;\n        this.established = false;\n        this.setSubscriptionState('none');\n    }\n    markAsFailed(message) {\n        this.rejectedWithError = message.error;\n        this.updatePending(null, null);\n        this.localObject.reportFailure(new syncerror_1.SyncError(`Failed to subscribe on service events: ${message.error.message}`, message.error.status, message.error.code));\n    }\n    complete(eventId) {\n        this.updatePending(null, null);\n        this.established = true;\n        this.localObject._advanceLastEventId(eventId);\n    }\n    setSubscriptionState(newState) {\n        this.localObject._setSubscriptionState(newState);\n    }\n}\n/**\n * @class Subscriptions\n * @classdesc A manager which, in batches of varying size, continuously persists the\n *      subscription intent of the caller to the Sync backend until it achieves a\n *      converged state.\n */\nclass Subscriptions {\n    /**\n     * @constructor\n     * Prepares a new Subscriptions manager object with zero subscribed or persisted subscriptions.\n     *\n     * @param {object} config may include a key 'backoffConfig', wherein any of the parameters\n     *      of Backoff.exponential (from npm 'backoff') are valid and will override the defaults.\n     *\n     * @param {Network} must be a viable running Sync Network object, useful for routing requests.\n     */\n    constructor(services) {\n        this.isConnected = false;\n        this.maxBatchSize = 100;\n        // If the server includes a `ttl_in_s` attribute in the poke response, subscriptionTtlTimer is started for that duration\n        // such that when it fires, it repokes the entire sync set (i.e., emulates a reconnect). Every reconnect resets the timer.\n        // After the timer has fired, the first poke request includes a `reason: ttl` attribute in the body.\n        this.subscriptionTtlTimer = null;\n        this.pendingPokeReason = null;\n        this.services = services;\n        this.subscriptions = new Map();\n        this.persisted = new Map();\n        this.latestPokeResponseArrivalTimestampByCorrelationId = new Map();\n        const defaultBackoffConfig = {\n            randomisationFactor: 0.2,\n            initialDelay: 100,\n            maxDelay: 2 * 60 * 1000\n        };\n        this.backoff = operation_retrier_1.Backoff.exponential(Object.assign(defaultBackoffConfig, this.services.config.backoffConfig));\n        // This block is triggered by #_persist. Every request is executed in a series of (ideally 1)\n        // backoff 'ready' event, at which point a new subscription set is calculated.\n        this.backoff.on('ready', () => {\n            let { action: action, subscriptions: subscriptionRequests } = this.getSubscriptionUpdateBatch();\n            if (action) {\n                this.applyNewSubscriptionUpdateBatch(action, subscriptionRequests);\n            }\n            else {\n                this.backoff.reset();\n                logger_1.default.debug('All subscriptions resolved.');\n            }\n        });\n    }\n    getSubscriptionUpdateBatch() {\n        function subtract(these, those, action, limit) {\n            let result = [];\n            for (let [thisKey, thisValue] of these) {\n                const otherValue = those.get(thisKey);\n                if (!otherValue && action !== thisValue.pendingAction && !thisValue.rejectedWithError) {\n                    result.push(thisValue);\n                    if (limit && result.length >= limit) {\n                        break;\n                    }\n                }\n            }\n            return result;\n        }\n        let listToAdd = subtract(this.subscriptions, this.persisted, 'establish', this.maxBatchSize);\n        if (listToAdd.length > 0) {\n            return { action: 'establish', subscriptions: listToAdd };\n        }\n        let listToRemove = subtract(this.persisted, this.subscriptions, 'cancel', this.maxBatchSize);\n        if (listToRemove.length > 0) {\n            return { action: 'cancel', subscriptions: listToRemove };\n        }\n        return { action: null, subscriptions: null };\n    }\n    persist() {\n        this.backoff.backoff();\n    }\n    async applyNewSubscriptionUpdateBatch(action, requests) {\n        if (!this.isConnected) {\n            logger_1.default.debug(`Twilsock connection (required for subscription) not ready; waiting`);\n            this.backoff.reset();\n            return;\n        }\n        // Keeping in mind that events may begin flowing _before_ we receive the response\n        requests = this.processLocalActions(action, requests);\n        const correlationId = new Date().getTime();\n        for (const subscribed of requests) {\n            this.recordActionAttemptOn(subscribed, action, correlationId);\n        }\n        let reason = this.pendingPokeReason;\n        this.pendingPokeReason = null;\n        // Send this batch to the service\n        try {\n            let response = await this.request(action, correlationId, reason, requests);\n            let newMaxBatchSize = response.body.max_batch_size;\n            if (!isNaN(parseInt(newMaxBatchSize)) && isFinite(newMaxBatchSize) && newMaxBatchSize > 0) {\n                this.maxBatchSize = newMaxBatchSize;\n            }\n            if (!this.subscriptionTtlTimer) {\n                let subscriptionTtlInS = response.body.ttl_in_s;\n                let isNumeric = !isNaN(parseFloat(subscriptionTtlInS)) && isFinite(subscriptionTtlInS);\n                let isValidTtl = isNumeric && subscriptionTtlInS > 0;\n                if (isValidTtl) {\n                    this.subscriptionTtlTimer = setTimeout(() => this.onSubscriptionTtlElapsed(), subscriptionTtlInS * 1000);\n                }\n            }\n            if (action === 'establish') {\n                const estimatedDeliveryInMs = response.body.estimated_delivery_in_ms;\n                let isNumeric = !isNaN(parseFloat(estimatedDeliveryInMs)) && isFinite(estimatedDeliveryInMs);\n                let isValidTimeout = isNumeric && estimatedDeliveryInMs > 0;\n                if (isValidTimeout) {\n                    setTimeout(() => this.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests), estimatedDeliveryInMs);\n                }\n                else {\n                    logger_1.default.error(`Invalid timeout: ${estimatedDeliveryInMs}`);\n                }\n                requests.filter(r => r.pendingCorrelationId === correlationId)\n                    .forEach(r => r.setSubscriptionState('response_in_flight'));\n            }\n            this.backoff.reset();\n        }\n        catch (e) {\n            for (const attemptedSubscription of requests) {\n                this.recordActionFailureOn(attemptedSubscription, action);\n            }\n            if (e instanceof twilsock_1.TransportUnavailableError) {\n                logger_1.default.debug(`Twilsock connection (required for subscription) not ready (c:${correlationId}); waiting`);\n                this.backoff.reset();\n            }\n            else {\n                logger_1.default.debug(`Failed an attempt to ${action} subscriptions (c:${correlationId}); retrying`, e);\n                this.persist();\n            }\n        }\n    }\n    verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests) {\n        const lastReceived = this.latestPokeResponseArrivalTimestampByCorrelationId.get(correlationId);\n        const silencePeriod = lastReceived ? (new Date().getTime() - lastReceived)\n            : estimatedDeliveryInMs;\n        if (silencePeriod >= estimatedDeliveryInMs) {\n            // If we haven't received _any_ responses from that poke request for the duration of estimated_delivery_in_ms, poke again\n            requests\n                .filter(r => r.pendingCorrelationId === correlationId)\n                .forEach(r => {\n                r.updatePending(null, null);\n                r.retryCount++;\n                this.persisted.delete(r.sid);\n            });\n            this.persist();\n            this.latestPokeResponseArrivalTimestampByCorrelationId.delete(correlationId);\n        }\n        else {\n            // Otherwise, the poke responses are probably in transit and we should wait for them\n            const timeoutExtension = estimatedDeliveryInMs - silencePeriod;\n            setTimeout(() => this.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests), timeoutExtension);\n        }\n    }\n    processLocalActions(action, requests) {\n        if (action === 'cancel') {\n            return requests.filter(request => !request.rejectedWithError);\n        }\n        return requests;\n    }\n    recordActionAttemptOn(attemptedSubscription, action, correlationId) {\n        attemptedSubscription.setSubscriptionState('request_in_flight');\n        if (action === 'establish') {\n            this.persisted.set(attemptedSubscription.sid, attemptedSubscription);\n            attemptedSubscription.updatePending(action, correlationId);\n        }\n        else { // cancel\n            let persistedSubscription = this.persisted.get(attemptedSubscription.sid);\n            if (persistedSubscription) {\n                persistedSubscription.updatePending(action, correlationId);\n            }\n        }\n    }\n    recordActionFailureOn(attemptedSubscription, action) {\n        attemptedSubscription.setSubscriptionState('none');\n        attemptedSubscription.updatePending(null, null);\n        if (action === 'establish') {\n            this.persisted.delete(attemptedSubscription.sid);\n        }\n    }\n    request(action, correlationId, reason, objects) {\n        let requests = objects.map(object => ({\n            object_sid: object.sid,\n            object_type: object.type,\n            last_event_id: action === 'establish' ? object.lastEventId : undefined,\n            index_name: action === 'establish' ? object.indexName : undefined,\n            query_string: action === 'establish' ? object.queryString : undefined,\n        }));\n        let retriedRequests = objects.filter(a => a.retryCount > 0).length;\n        logger_1.default.debug(`Attempting '${action}' request (c:${correlationId}):`, requests);\n        const requestBody = {\n            event_protocol_version: 3,\n            action,\n            correlation_id: correlationId,\n            retried_requests: retriedRequests,\n            ttl_in_s: -1,\n            requests\n        };\n        if (reason === 'ttl') {\n            requestBody.reason = reason;\n        }\n        return this.services.network.post(this.services.config.subscriptionsUri, requestBody);\n    }\n    /**\n     * Establishes intent to be subscribed to this entity. That subscription will be effected\n     * asynchronously.\n     * If subscription to the given sid already exists, it will be overwritten.\n     *\n     * @param {String} sid should be a well-formed SID, uniquely identifying a single instance of a Sync entity.\n     * @param {Object} entity should represent the (singular) local representation of this entity.\n     *      Incoming events and modifications to the entity will be directed at the _update() function\n     *      of this provided reference.\n     *\n     * @return undefined\n     */\n    add(sid, entity) {\n        logger_1.default.debug(`Establishing intent to subscribe to ${sid}`);\n        const existingSubscription = this.subscriptions.get(sid);\n        if (existingSubscription && entity && existingSubscription.lastEventId === entity.lastEventId) {\n            // If last event id is the same as before - we're fine\n            return;\n        }\n        this.persisted.delete(sid);\n        this.subscriptions.set(sid, new SubscribedEntity(entity));\n        this.persist();\n    }\n    /**\n     * Establishes the caller's intent to no longer be subscribed to this entity. Following this\n     * call, no further events shall be routed to the local representation of the entity, even\n     * though a server-side subscription may take more time to actually terminate.\n     *\n     * @param {string} sid should be any well-formed SID, uniquely identifying a Sync entity.\n     *      This call only has meaningful effect if that entity is subscribed at the\n     *      time of call. Otherwise does nothing.\n     *\n     * @return undefined\n     */\n    remove(sid) {\n        logger_1.default.debug(`Establishing intent to unsubscribe from ${sid}`);\n        const removed = this.subscriptions.delete(sid);\n        if (removed) {\n            this.persist();\n        }\n    }\n    /**\n     * The point of ingestion for remote incoming messages (e.g. new data was written to a map\n     * to which we are subscribed).\n     *\n     * @param {object} message is the full, unaltered body of the incoming notification.\n     *\n     * @return undefined\n     */\n    acceptMessage(message, isStrictlyOrdered) {\n        logger_1.default.trace('Subscriptions received', message);\n        if (message.correlation_id) {\n            this.latestPokeResponseArrivalTimestampByCorrelationId.set(message.correlation_id, new Date().getTime());\n        }\n        let event_type;\n        switch (message.event_type) {\n            case 'subscription_established':\n                this.applySubscriptionEstablishedMessage(message.event, message.correlation_id);\n                break;\n            case 'subscription_canceled':\n                this.applySubscriptionCancelledMessage(message.event, message.correlation_id);\n                break;\n            case 'subscription_failed':\n                this.applySubscriptionFailedMessage(message.event, message.correlation_id);\n                break;\n            case (event_type = message.event_type.match(/^(?:map|list|document|stream|live_query)_/) || {}).input:\n                {\n                    let typedSid;\n                    switch (event_type[0]) {\n                        case 'map_':\n                            typedSid = message.event.map_sid;\n                            break;\n                        case 'list_':\n                            typedSid = message.event.list_sid;\n                            break;\n                        case 'document_':\n                            typedSid = message.event.document_sid;\n                            break;\n                        case 'stream_':\n                            typedSid = message.event.stream_sid;\n                            break;\n                        case 'live_query_':\n                            typedSid = message.event.query_id;\n                            // hack to mark replay events for LiveQuery as strictly ordered, due to lack of special type of notification for them\n                            // (normally only replay events would have `twilio.sync.event` type, but LiveQuery non-replay events were also assigned\n                            // to this type in legacy clients, which we have to support now; hence a hack)\n                            isStrictlyOrdered = false; // explicitly override it due to code in router.ts does not know about LiveQueries\n                            if (message.strictly_ordered === true) {\n                                isStrictlyOrdered = true;\n                            }\n                            break;\n                        default:\n                            typedSid = undefined;\n                    }\n                    this.applyEventToSubscribedEntity(typedSid, message, isStrictlyOrdered);\n                }\n                break;\n            default:\n                logger_1.default.debug(`Dropping unknown message type ${message.event_type}`);\n                break;\n        }\n    }\n    applySubscriptionEstablishedMessage(message, correlationId) {\n        const sid = message.object_sid;\n        let subscriptionIntent = this.persisted.get(message.object_sid);\n        if (subscriptionIntent && subscriptionIntent.pendingCorrelationId === correlationId) {\n            if (message.replay_status === 'interrupted') {\n                logger_1.default.debug(`Event Replay for subscription to ${sid} (c:${correlationId}) interrupted; continuing eagerly.`);\n                subscriptionIntent.updatePending(null, null);\n                this.persisted.delete(subscriptionIntent.sid);\n                this.backoff.reset();\n            }\n            else if (message.replay_status === 'completed') {\n                logger_1.default.debug(`Event Replay for subscription to ${sid} (c:${correlationId}) completed. Subscription is ready.`);\n                subscriptionIntent.complete(message.last_event_id);\n                this.persisted.set(message.object_sid, subscriptionIntent);\n                subscriptionIntent.setSubscriptionState('established');\n                this.backoff.reset();\n            }\n        }\n        else {\n            logger_1.default.debug(`Late message for ${message.object_sid} (c:${correlationId}) dropped.`);\n        }\n        this.persist();\n    }\n    applySubscriptionCancelledMessage(message, correlationId) {\n        let persistedSubscription = this.persisted.get(message.object_sid);\n        if (persistedSubscription && persistedSubscription.pendingCorrelationId === correlationId) {\n            persistedSubscription.updatePending(null, null);\n            persistedSubscription.setSubscriptionState('none');\n            this.persisted.delete(message.object_sid);\n        }\n        else {\n            logger_1.default.debug(`Late message for ${message.object_sid} (c:${correlationId}) dropped.`);\n        }\n        this.persist();\n    }\n    applySubscriptionFailedMessage(message, correlationId) {\n        const sid = message.object_sid;\n        let subscriptionIntent = this.subscriptions.get(sid);\n        let subscription = this.persisted.get(sid);\n        if (subscriptionIntent && subscription) {\n            if (subscription.pendingCorrelationId === correlationId) {\n                logger_1.default.error(`Failed to subscribe on ${subscription.sid}`, message.error);\n                subscription.markAsFailed(message);\n                subscription.setSubscriptionState('none');\n            }\n        }\n        else if (!subscriptionIntent && subscription) {\n            this.persisted.delete(sid);\n            subscription.setSubscriptionState('none');\n        }\n        this.persist();\n    }\n    applyEventToSubscribedEntity(sid, message, isStrictlyOrdered) {\n        if (!sid) {\n            return;\n        }\n        // Looking for subscription descriptor to check if poke has been completed\n        isStrictlyOrdered = isStrictlyOrdered || (() => {\n            let subscription = this.persisted.get(sid);\n            return subscription && subscription.isEstablished;\n        })();\n        // Still searching for subscriptionIntents. User could remove subscription already\n        let subscriptionIntent = this.subscriptions.get(sid);\n        if (subscriptionIntent) {\n            message.event.type = message.event_type;\n            subscriptionIntent.update(message.event, isStrictlyOrdered);\n        }\n        else {\n            logger_1.default.debug(`Message dropped for SID '${sid}', for which there is no subscription.`);\n        }\n    }\n    onConnectionStateChanged(isConnected) {\n        this.isConnected = isConnected;\n        if (isConnected) {\n            this.poke('reconnect');\n        }\n    }\n    onSubscriptionTtlElapsed() {\n        if (this.isConnected) {\n            this.poke('ttl');\n        }\n    }\n    /**\n     * Prompts a playback of any missed changes made to any subscribed object. This method\n     * should be invoked whenever the connectivity layer has experienced cross-cutting\n     * delivery failures that would affect the entire local sync set. Any tangible result\n     * of this operation will result in calls to the _update() function of subscribed\n     * Sync entities.\n     */\n    poke(reason) {\n        logger_1.default.debug(`Triggering event replay for all subscriptions, reason=${reason}`);\n        this.pendingPokeReason = reason;\n        if (this.subscriptionTtlTimer) {\n            clearTimeout(this.subscriptionTtlTimer);\n            this.subscriptionTtlTimer = null;\n        }\n        let failedSubscriptions = [];\n        for (let it of this.persisted.values()) {\n            it.reset();\n            if (it.rejectedWithError) {\n                failedSubscriptions.push(it);\n            }\n        }\n        this.persisted.clear();\n        for (let it of failedSubscriptions) {\n            this.persisted.set(it.sid, it);\n        }\n        this.persist();\n    }\n    /**\n     * Stops all communication, clears any subscription intent, and returns.\n     */\n    shutdown() {\n        this.backoff.reset();\n        this.subscriptions.clear();\n    }\n}\nexports.Subscriptions = Subscriptions;\n"]},"metadata":{},"sourceType":"script"}