{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Upstream = void 0;\n\nconst logger_1 = require(\"../logger\");\n\nconst twilsockerror_1 = require(\"../error/twilsockerror\");\n\nconst twilsockupstreamerror_1 = require(\"../error/twilsockupstreamerror\");\n\nconst Messages = require(\"../protocol/messages\");\n\nconst transportunavailableerror_1 = require(\"../error/transportunavailableerror\");\n\nconst REQUEST_TIMEOUT = 20000;\n\nfunction isHttpSuccess(code) {\n  return code >= 200 && code < 300;\n}\n\nfunction isHttpReply(packet) {\n  return packet && packet.header && packet.header.http_status;\n}\n\nclass Request {}\n\nfunction parseUri(uri) {\n  const match = uri.match(/^(https?\\:)\\/\\/(([^:\\/?#]*)(?:\\:([0-9]+))?)(\\/[^?#]*)(\\?[^#]*|)(#.*|)$/);\n\n  if (match) {\n    let uriStruct = {\n      protocol: match[1],\n      host: match[2],\n      hostname: match[3],\n      port: match[4],\n      pathname: match[5],\n      search: match[6],\n      hash: match[7],\n      params: null\n    };\n\n    if (uriStruct.search.length > 0) {\n      let paramsString = uriStruct.search.substring(1);\n      uriStruct.params = paramsString.split('&').map(el => el.split('=')).reduce((prev, curr) => {\n        if (!prev.hasOwnProperty(curr[0])) {\n          prev[curr[0]] = curr[1];\n        } else if (Array.isArray(prev[curr[0]])) {\n          prev[curr[0]].push(curr[1]);\n        } else {\n          prev[curr[0]] = [prev[curr[0]], curr[1]];\n        }\n\n        return prev;\n      }, {});\n    }\n\n    return uriStruct;\n  }\n\n  throw new twilsockerror_1.TwilsockError('Incorrect URI: ' + uri);\n}\n\nfunction twilsockAddress(method, uri) {\n  const parsedUri = parseUri(uri);\n  let to = {\n    method: method,\n    host: parsedUri.host,\n    path: parsedUri.pathname\n  };\n\n  if (parsedUri.params) {\n    to.params = parsedUri.params;\n  }\n\n  return to;\n}\n\nfunction twilsockParams(method, uri, headers, body) {\n  return {\n    to: twilsockAddress(method, uri),\n    headers: headers,\n    body: body\n  };\n}\n\nclass Upstream {\n  constructor(transport, twilsock, config) {\n    this.config = config;\n    this.transport = transport;\n    this.pendingMessages = [];\n    this.twilsock = twilsock;\n  }\n\n  saveMessage(message) {\n    return new Promise((resolve, reject) => {\n      let requestDescriptor = {\n        message,\n        resolve: resolve,\n        reject: reject,\n        alreadyRejected: false,\n        timeout: setTimeout(() => {\n          logger_1.log.debug('request is timed out');\n          reject(new twilsockerror_1.TwilsockError('Twilsock: request timeout'));\n          requestDescriptor.alreadyRejected = true;\n        }, REQUEST_TIMEOUT)\n      };\n      this.pendingMessages.push(requestDescriptor);\n    });\n  }\n\n  sendPendingMessages() {\n    while (this.pendingMessages.length) {\n      let request = this.pendingMessages[0]; // Do not send message if we've rejected its promise already\n\n      if (!request.alreadyRejected) {\n        try {\n          let message = request.message;\n          this.actualSend(message).then(response => request.resolve(response)).catch(e => request.reject(e));\n          clearTimeout(request.timeout);\n        } catch (e) {\n          logger_1.log.debug('Failed to send pending message', e);\n          break;\n        }\n      }\n\n      this.pendingMessages.splice(0, 1);\n    }\n  }\n\n  rejectPendingMessages() {\n    this.pendingMessages.forEach(message => {\n      message.reject(new transportunavailableerror_1.TransportUnavailableError('Unable to connect: ' + this.twilsock.getTerminationReason));\n      clearTimeout(message.timeout);\n    });\n    this.pendingMessages.splice(0, this.pendingMessages.length);\n  }\n\n  async actualSend(message) {\n    let address = message.to;\n    let headers = message.headers;\n    let body = message.body;\n    let httpRequest = {\n      host: address.host,\n      path: address.path,\n      method: address.method,\n      params: address.params,\n      headers: headers\n    };\n    let upstreamMessage = new Messages.Message(this.config.activeGrant, headers['Content-Type'] || 'application/json', httpRequest);\n    let reply = await this.transport.sendWithReply(upstreamMessage, body);\n\n    if (isHttpReply(reply) && !isHttpSuccess(reply.header.http_status.code)) {\n      throw new twilsockupstreamerror_1.TwilsockUpstreamError(reply.header.http_status.code, reply.header.http_status.status, reply.body);\n    }\n\n    return {\n      status: reply.header.http_status,\n      headers: reply.header.http_headers,\n      body: reply.body\n    };\n  }\n  /**\n   * Send an upstream message\n   * @param {Twilsock#Message} message Message structure with header, body and remote address\n   * @returns {Promise<Result>} Result from remote side\n   */\n\n\n  send(method, url, headers = {}, body) {\n    if (this.twilsock.isTerminalState) {\n      return Promise.reject(new transportunavailableerror_1.TransportUnavailableError('Unable to connect: ' + this.twilsock.getTerminationReason));\n    }\n\n    let twilsockMessage = twilsockParams(method, url, headers, body);\n\n    if (!this.twilsock.isConnected) {\n      return this.saveMessage(twilsockMessage);\n    }\n\n    return this.actualSend(twilsockMessage);\n  }\n\n}\n\nexports.Upstream = Upstream;","map":{"version":3,"sources":["/root/twilio-phone-client/node_modules/twilsock/lib/services/upstream.js"],"names":["Object","defineProperty","exports","value","Upstream","logger_1","require","twilsockerror_1","twilsockupstreamerror_1","Messages","transportunavailableerror_1","REQUEST_TIMEOUT","isHttpSuccess","code","isHttpReply","packet","header","http_status","Request","parseUri","uri","match","uriStruct","protocol","host","hostname","port","pathname","search","hash","params","length","paramsString","substring","split","map","el","reduce","prev","curr","hasOwnProperty","Array","isArray","push","TwilsockError","twilsockAddress","method","parsedUri","to","path","twilsockParams","headers","body","constructor","transport","twilsock","config","pendingMessages","saveMessage","message","Promise","resolve","reject","requestDescriptor","alreadyRejected","timeout","setTimeout","log","debug","sendPendingMessages","request","actualSend","then","response","catch","e","clearTimeout","splice","rejectPendingMessages","forEach","TransportUnavailableError","getTerminationReason","address","httpRequest","upstreamMessage","Message","activeGrant","reply","sendWithReply","TwilsockUpstreamError","status","http_headers","send","url","isTerminalState","twilsockMessage","isConnected"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Upstream = void 0;\nconst logger_1 = require(\"../logger\");\nconst twilsockerror_1 = require(\"../error/twilsockerror\");\nconst twilsockupstreamerror_1 = require(\"../error/twilsockupstreamerror\");\nconst Messages = require(\"../protocol/messages\");\nconst transportunavailableerror_1 = require(\"../error/transportunavailableerror\");\nconst REQUEST_TIMEOUT = 20000;\nfunction isHttpSuccess(code) {\n    return (code >= 200 && code < 300);\n}\nfunction isHttpReply(packet) {\n    return packet && packet.header && packet.header.http_status;\n}\nclass Request {\n}\nfunction parseUri(uri) {\n    const match = uri.match(/^(https?\\:)\\/\\/(([^:\\/?#]*)(?:\\:([0-9]+))?)(\\/[^?#]*)(\\?[^#]*|)(#.*|)$/);\n    if (match) {\n        let uriStruct = {\n            protocol: match[1],\n            host: match[2],\n            hostname: match[3],\n            port: match[4],\n            pathname: match[5],\n            search: match[6],\n            hash: match[7],\n            params: null\n        };\n        if (uriStruct.search.length > 0) {\n            let paramsString = uriStruct.search.substring(1);\n            uriStruct.params = paramsString.split('&')\n                .map(el => el.split('='))\n                .reduce((prev, curr) => {\n                if (!prev.hasOwnProperty(curr[0])) {\n                    prev[curr[0]] = curr[1];\n                }\n                else if (Array.isArray(prev[curr[0]])) {\n                    prev[curr[0]].push(curr[1]);\n                }\n                else {\n                    prev[curr[0]] = [prev[curr[0]], curr[1]];\n                }\n                return prev;\n            }, {});\n        }\n        return uriStruct;\n    }\n    throw new twilsockerror_1.TwilsockError('Incorrect URI: ' + uri);\n}\nfunction twilsockAddress(method, uri) {\n    const parsedUri = parseUri(uri);\n    let to = {\n        method: method,\n        host: parsedUri.host,\n        path: parsedUri.pathname\n    };\n    if (parsedUri.params) {\n        to.params = parsedUri.params;\n    }\n    return to;\n}\nfunction twilsockParams(method, uri, headers, body) {\n    return {\n        to: twilsockAddress(method, uri),\n        headers: headers,\n        body: body\n    };\n}\nclass Upstream {\n    constructor(transport, twilsock, config) {\n        this.config = config;\n        this.transport = transport;\n        this.pendingMessages = [];\n        this.twilsock = twilsock;\n    }\n    saveMessage(message) {\n        return new Promise((resolve, reject) => {\n            let requestDescriptor = {\n                message,\n                resolve: resolve,\n                reject: reject,\n                alreadyRejected: false,\n                timeout: setTimeout(() => {\n                    logger_1.log.debug('request is timed out');\n                    reject(new twilsockerror_1.TwilsockError('Twilsock: request timeout'));\n                    requestDescriptor.alreadyRejected = true;\n                }, REQUEST_TIMEOUT)\n            };\n            this.pendingMessages.push(requestDescriptor);\n        });\n    }\n    sendPendingMessages() {\n        while (this.pendingMessages.length) {\n            let request = this.pendingMessages[0];\n            // Do not send message if we've rejected its promise already\n            if (!request.alreadyRejected) {\n                try {\n                    let message = request.message;\n                    this.actualSend(message)\n                        .then(response => request.resolve(response))\n                        .catch(e => request.reject(e));\n                    clearTimeout(request.timeout);\n                }\n                catch (e) {\n                    logger_1.log.debug('Failed to send pending message', e);\n                    break;\n                }\n            }\n            this.pendingMessages.splice(0, 1);\n        }\n    }\n    rejectPendingMessages() {\n        this.pendingMessages.forEach(message => {\n            message.reject(new transportunavailableerror_1.TransportUnavailableError('Unable to connect: ' + this.twilsock.getTerminationReason));\n            clearTimeout(message.timeout);\n        });\n        this.pendingMessages.splice(0, this.pendingMessages.length);\n    }\n    async actualSend(message) {\n        let address = message.to;\n        let headers = message.headers;\n        let body = message.body;\n        let httpRequest = {\n            host: address.host,\n            path: address.path,\n            method: address.method,\n            params: address.params,\n            headers: headers\n        };\n        let upstreamMessage = new Messages.Message(this.config.activeGrant, headers['Content-Type'] || 'application/json', httpRequest);\n        let reply = await this.transport.sendWithReply(upstreamMessage, body);\n        if (isHttpReply(reply) && !isHttpSuccess(reply.header.http_status.code)) {\n            throw new twilsockupstreamerror_1.TwilsockUpstreamError(reply.header.http_status.code, reply.header.http_status.status, reply.body);\n        }\n        return {\n            status: reply.header.http_status,\n            headers: reply.header.http_headers,\n            body: reply.body\n        };\n    }\n    /**\n     * Send an upstream message\n     * @param {Twilsock#Message} message Message structure with header, body and remote address\n     * @returns {Promise<Result>} Result from remote side\n     */\n    send(method, url, headers = {}, body) {\n        if (this.twilsock.isTerminalState) {\n            return Promise.reject(new transportunavailableerror_1.TransportUnavailableError('Unable to connect: ' + this.twilsock.getTerminationReason));\n        }\n        let twilsockMessage = twilsockParams(method, url, headers, body);\n        if (!this.twilsock.isConnected) {\n            return this.saveMessage(twilsockMessage);\n        }\n        return this.actualSend(twilsockMessage);\n    }\n}\nexports.Upstream = Upstream;\n"]},"metadata":{},"sourceType":"script"}