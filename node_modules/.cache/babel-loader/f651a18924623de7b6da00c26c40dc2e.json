{"ast":null,"code":"\"use strict\";\n/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar errors_1 = require(\"./errors\");\n\nvar util_1 = require(\"./util\");\n\nvar getRTCStats = require('./rtc/stats').getRTCStats;\n\nvar Mos = require('./rtc/mos'); // How many samples we use when testing metric thresholds\n\n\nvar SAMPLE_COUNT_METRICS = 5; // How many samples that need to cross the threshold to\n// raise or clear a warning.\n\nvar SAMPLE_COUNT_CLEAR = 0;\nvar SAMPLE_COUNT_RAISE = 3;\nvar SAMPLE_INTERVAL = 1000;\nvar WARNING_TIMEOUT = 5 * 1000;\nvar DEFAULT_THRESHOLDS = {\n  audioInputLevel: {\n    minStandardDeviation: 327.67,\n    sampleCount: 10\n  },\n  audioOutputLevel: {\n    minStandardDeviation: 327.67,\n    sampleCount: 10\n  },\n  bytesReceived: {\n    clearCount: 2,\n    min: 1,\n    raiseCount: 3,\n    sampleCount: 3\n  },\n  bytesSent: {\n    clearCount: 2,\n    min: 1,\n    raiseCount: 3,\n    sampleCount: 3\n  },\n  jitter: {\n    max: 30\n  },\n  mos: {\n    min: 3\n  },\n  packetsLostFraction: [{\n    max: 1\n  }, {\n    clearValue: 1,\n    maxAverage: 3,\n    sampleCount: 7\n  }],\n  rtt: {\n    max: 400\n  }\n};\n/**\n * Count the number of values that cross the max threshold.\n * @private\n * @param max - The max allowable value.\n * @param values - The values to iterate over.\n * @returns The amount of values in which the stat crossed the threshold.\n */\n\nfunction countHigh(max, values) {\n  return values.reduce(function (highCount, value) {\n    return highCount += value > max ? 1 : 0;\n  }, 0);\n}\n/**\n * Count the number of values that cross the min threshold.\n * @private\n * @param min - The minimum allowable value.\n * @param values - The values to iterate over.\n * @returns The amount of values in which the stat crossed the threshold.\n */\n\n\nfunction countLow(min, values) {\n  return values.reduce(function (lowCount, value) {\n    return lowCount += value < min ? 1 : 0;\n  }, 0);\n}\n/**\n * Calculate the standard deviation from a list of numbers.\n * @private\n * @param values The list of numbers to calculate the standard deviation from.\n * @returns The standard deviation of a list of numbers.\n */\n\n\nfunction calculateStandardDeviation(values) {\n  if (values.length <= 0) {\n    return null;\n  }\n\n  var valueAverage = values.reduce(function (partialSum, value) {\n    return partialSum + value;\n  }, 0) / values.length;\n  var diffSquared = values.map(function (value) {\n    return Math.pow(value - valueAverage, 2);\n  });\n  var stdDev = Math.sqrt(diffSquared.reduce(function (partialSum, value) {\n    return partialSum + value;\n  }, 0) / diffSquared.length);\n  return stdDev;\n}\n/**\n * Flatten a set of numerical sample sets into a single array of samples.\n * @param sampleSets\n */\n\n\nfunction flattenSamples(sampleSets) {\n  return sampleSets.reduce(function (flat, current) {\n    return __spreadArrays(flat, current);\n  }, []);\n}\n/**\n * {@link StatsMonitor} polls a peerConnection via PeerConnection.getStats\n * and emits warnings when stats cross the specified threshold values.\n */\n\n\nvar StatsMonitor =\n/** @class */\nfunction (_super) {\n  __extends(StatsMonitor, _super);\n  /**\n   * @constructor\n   * @param [options] - Optional settings\n   */\n\n\n  function StatsMonitor(options) {\n    var _this = _super.call(this) || this;\n    /**\n     * A map of warnings with their raised time\n     */\n\n\n    _this._activeWarnings = new Map();\n    /**\n     * A map of stats with the number of exceeded thresholds\n     */\n\n    _this._currentStreaks = new Map();\n    /**\n     * Keeps track of input volumes in the last second\n     */\n\n    _this._inputVolumes = [];\n    /**\n     * Keeps track of output volumes in the last second\n     */\n\n    _this._outputVolumes = [];\n    /**\n     * Sample buffer. Saves most recent samples\n     */\n\n    _this._sampleBuffer = [];\n    /**\n     * Keeps track of supplemental sample values.\n     *\n     * Currently used for constant audio detection. Contains an array of volume\n     * samples for each sample interval.\n     */\n\n    _this._supplementalSampleBuffers = {\n      audioInputLevel: [],\n      audioOutputLevel: []\n    };\n    /**\n     * Whether warnings should be enabled\n     */\n\n    _this._warningsEnabled = true;\n    options = options || {};\n    _this._getRTCStats = options.getRTCStats || getRTCStats;\n    _this._mos = options.Mos || Mos;\n    _this._peerConnection = options.peerConnection;\n    _this._thresholds = __assign(__assign({}, DEFAULT_THRESHOLDS), options.thresholds);\n    var thresholdSampleCounts = Object.values(_this._thresholds).map(function (threshold) {\n      return threshold.sampleCount;\n    }).filter(function (sampleCount) {\n      return !!sampleCount;\n    });\n    _this._maxSampleCount = Math.max.apply(Math, __spreadArrays([SAMPLE_COUNT_METRICS], thresholdSampleCounts));\n\n    if (_this._peerConnection) {\n      _this.enable(_this._peerConnection);\n    }\n\n    return _this;\n  }\n  /**\n   * Called when a volume sample is available\n   * @param inputVolume - Input volume level from 0 to 32767\n   * @param outputVolume - Output volume level from 0 to 32767\n   */\n\n\n  StatsMonitor.prototype.addVolumes = function (inputVolume, outputVolume) {\n    this._inputVolumes.push(inputVolume);\n\n    this._outputVolumes.push(outputVolume);\n  };\n  /**\n   * Stop sampling RTC statistics for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n\n\n  StatsMonitor.prototype.disable = function () {\n    clearInterval(this._sampleInterval);\n    delete this._sampleInterval;\n    return this;\n  };\n  /**\n   * Disable warnings for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n\n\n  StatsMonitor.prototype.disableWarnings = function () {\n    if (this._warningsEnabled) {\n      this._activeWarnings.clear();\n    }\n\n    this._warningsEnabled = false;\n    return this;\n  };\n  /**\n   * Start sampling RTC statistics for this {@link StatsMonitor}.\n   * @param peerConnection - A PeerConnection to monitor.\n   * @returns The current {@link StatsMonitor}.\n   */\n\n\n  StatsMonitor.prototype.enable = function (peerConnection) {\n    if (peerConnection) {\n      if (this._peerConnection && peerConnection !== this._peerConnection) {\n        throw new errors_1.InvalidArgumentError('Attempted to replace an existing PeerConnection in StatsMonitor.enable');\n      }\n\n      this._peerConnection = peerConnection;\n    }\n\n    if (!this._peerConnection) {\n      throw new errors_1.InvalidArgumentError('Can not enable StatsMonitor without a PeerConnection');\n    }\n\n    this._sampleInterval = this._sampleInterval || setInterval(this._fetchSample.bind(this), SAMPLE_INTERVAL);\n    return this;\n  };\n  /**\n   * Enable warnings for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n\n\n  StatsMonitor.prototype.enableWarnings = function () {\n    this._warningsEnabled = true;\n    return this;\n  };\n  /**\n   * Check if there is an active warning for a specific stat and threshold\n   * @param statName - The name of the stat to check\n   * @param thresholdName - The name of the threshold to check\n   * @returns Whether there is an active warning for a specific stat and threshold\n   */\n\n\n  StatsMonitor.prototype.hasActiveWarning = function (statName, thresholdName) {\n    var warningId = statName + \":\" + thresholdName;\n    return !!this._activeWarnings.get(warningId);\n  };\n  /**\n   * Add a sample to our sample buffer and remove the oldest if we are over the limit.\n   * @param sample - Sample to add\n   */\n\n\n  StatsMonitor.prototype._addSample = function (sample) {\n    var samples = this._sampleBuffer;\n    samples.push(sample); // We store 1 extra sample so that we always have (current, previous)\n    // available for all {sampleBufferSize} threshold validations.\n\n    if (samples.length > this._maxSampleCount) {\n      samples.splice(0, samples.length - this._maxSampleCount);\n    }\n  };\n  /**\n   * Clear an active warning.\n   * @param statName - The name of the stat to clear.\n   * @param thresholdName - The name of the threshold to clear\n   * @param [data] - Any relevant sample data.\n   */\n\n\n  StatsMonitor.prototype._clearWarning = function (statName, thresholdName, data) {\n    var warningId = statName + \":\" + thresholdName;\n\n    var activeWarning = this._activeWarnings.get(warningId);\n\n    if (!activeWarning || Date.now() - activeWarning.timeRaised < WARNING_TIMEOUT) {\n      return;\n    }\n\n    this._activeWarnings.delete(warningId);\n\n    this.emit('warning-cleared', __assign(__assign({}, data), {\n      name: statName,\n      threshold: {\n        name: thresholdName,\n        value: this._thresholds[statName][thresholdName]\n      }\n    }));\n  };\n  /**\n   * Create a sample object from a stats object using the previous sample, if available.\n   * @param stats - Stats retrieved from getStatistics\n   * @param [previousSample=null] - The previous sample to use to calculate deltas.\n   * @returns A universally-formatted version of RTC stats.\n   */\n\n\n  StatsMonitor.prototype._createSample = function (stats, previousSample) {\n    var previousBytesSent = previousSample && previousSample.totals.bytesSent || 0;\n    var previousBytesReceived = previousSample && previousSample.totals.bytesReceived || 0;\n    var previousPacketsSent = previousSample && previousSample.totals.packetsSent || 0;\n    var previousPacketsReceived = previousSample && previousSample.totals.packetsReceived || 0;\n    var previousPacketsLost = previousSample && previousSample.totals.packetsLost || 0;\n    var currentBytesSent = stats.bytesSent - previousBytesSent;\n    var currentBytesReceived = stats.bytesReceived - previousBytesReceived;\n    var currentPacketsSent = stats.packetsSent - previousPacketsSent;\n    var currentPacketsReceived = stats.packetsReceived - previousPacketsReceived;\n    var currentPacketsLost = stats.packetsLost - previousPacketsLost;\n    var currentInboundPackets = currentPacketsReceived + currentPacketsLost;\n    var currentPacketsLostFraction = currentInboundPackets > 0 ? currentPacketsLost / currentInboundPackets * 100 : 0;\n    var totalInboundPackets = stats.packetsReceived + stats.packetsLost;\n    var totalPacketsLostFraction = totalInboundPackets > 0 ? stats.packetsLost / totalInboundPackets * 100 : 100;\n    var rttValue = typeof stats.rtt === 'number' || !previousSample ? stats.rtt : previousSample.rtt;\n\n    var audioInputLevelValues = this._inputVolumes.splice(0);\n\n    this._supplementalSampleBuffers.audioInputLevel.push(audioInputLevelValues);\n\n    var audioOutputLevelValues = this._outputVolumes.splice(0);\n\n    this._supplementalSampleBuffers.audioOutputLevel.push(audioOutputLevelValues);\n\n    return {\n      audioInputLevel: Math.round(util_1.average(audioInputLevelValues)),\n      audioOutputLevel: Math.round(util_1.average(audioOutputLevelValues)),\n      bytesReceived: currentBytesReceived,\n      bytesSent: currentBytesSent,\n      codecName: stats.codecName,\n      jitter: stats.jitter,\n      mos: this._mos.calculate(rttValue, stats.jitter, previousSample && currentPacketsLostFraction),\n      packetsLost: currentPacketsLost,\n      packetsLostFraction: currentPacketsLostFraction,\n      packetsReceived: currentPacketsReceived,\n      packetsSent: currentPacketsSent,\n      rtt: rttValue,\n      timestamp: stats.timestamp,\n      totals: {\n        bytesReceived: stats.bytesReceived,\n        bytesSent: stats.bytesSent,\n        packetsLost: stats.packetsLost,\n        packetsLostFraction: totalPacketsLostFraction,\n        packetsReceived: stats.packetsReceived,\n        packetsSent: stats.packetsSent\n      }\n    };\n  };\n  /**\n   * Get stats from the PeerConnection and add it to our list of samples.\n   */\n\n\n  StatsMonitor.prototype._fetchSample = function () {\n    var _this = this;\n\n    this._getSample().then(function (sample) {\n      _this._addSample(sample);\n\n      _this._raiseWarnings();\n\n      _this.emit('sample', sample);\n    }).catch(function (error) {\n      _this.disable(); // We only bubble up any errors coming from pc.getStats()\n      // No need to attach a twilioError\n\n\n      _this.emit('error', error);\n    });\n  };\n  /**\n   * Get stats from the PeerConnection.\n   * @returns A universally-formatted version of RTC stats.\n   */\n\n\n  StatsMonitor.prototype._getSample = function () {\n    var _this = this;\n\n    return this._getRTCStats(this._peerConnection).then(function (stats) {\n      var previousSample = null;\n\n      if (_this._sampleBuffer.length) {\n        previousSample = _this._sampleBuffer[_this._sampleBuffer.length - 1];\n      }\n\n      return _this._createSample(stats, previousSample);\n    });\n  };\n  /**\n   * Raise a warning and log its raised time.\n   * @param statName - The name of the stat to raise.\n   * @param thresholdName - The name of the threshold to raise\n   * @param [data] - Any relevant sample data.\n   */\n\n\n  StatsMonitor.prototype._raiseWarning = function (statName, thresholdName, data) {\n    var warningId = statName + \":\" + thresholdName;\n\n    if (this._activeWarnings.has(warningId)) {\n      return;\n    }\n\n    this._activeWarnings.set(warningId, {\n      timeRaised: Date.now()\n    });\n\n    var thresholds = this._thresholds[statName];\n    var thresholdValue;\n\n    if (Array.isArray(thresholds)) {\n      var foundThreshold = thresholds.find(function (threshold) {\n        return thresholdName in threshold;\n      });\n\n      if (foundThreshold) {\n        thresholdValue = foundThreshold[thresholdName];\n      }\n    } else {\n      thresholdValue = this._thresholds[statName][thresholdName];\n    }\n\n    this.emit('warning', __assign(__assign({}, data), {\n      name: statName,\n      threshold: {\n        name: thresholdName,\n        value: thresholdValue\n      }\n    }));\n  };\n  /**\n   * Apply our thresholds to our array of RTCStat samples.\n   */\n\n\n  StatsMonitor.prototype._raiseWarnings = function () {\n    var _this = this;\n\n    if (!this._warningsEnabled) {\n      return;\n    }\n\n    Object.keys(this._thresholds).forEach(function (name) {\n      return _this._raiseWarningsForStat(name);\n    });\n  };\n  /**\n   * Apply thresholds for a given stat name to our array of\n   * RTCStat samples and raise or clear any associated warnings.\n   * @param statName - Name of the stat to compare.\n   */\n\n\n  StatsMonitor.prototype._raiseWarningsForStat = function (statName) {\n    var _this = this;\n\n    var limits = Array.isArray(this._thresholds[statName]) ? this._thresholds[statName] : [this._thresholds[statName]];\n    limits.forEach(function (limit) {\n      var samples = _this._sampleBuffer;\n      var clearCount = limit.clearCount || SAMPLE_COUNT_CLEAR;\n      var raiseCount = limit.raiseCount || SAMPLE_COUNT_RAISE;\n      var sampleCount = limit.sampleCount || _this._maxSampleCount;\n      var relevantSamples = samples.slice(-sampleCount);\n      var values = relevantSamples.map(function (sample) {\n        return sample[statName];\n      }); // (rrowland) If we have a bad or missing value in the set, we don't\n      // have enough information to throw or clear a warning. Bail out.\n\n      var containsNull = values.some(function (value) {\n        return typeof value === 'undefined' || value === null;\n      });\n\n      if (containsNull) {\n        return;\n      }\n\n      var count;\n\n      if (typeof limit.max === 'number') {\n        count = countHigh(limit.max, values);\n\n        if (count >= raiseCount) {\n          _this._raiseWarning(statName, 'max', {\n            values: values,\n            samples: relevantSamples\n          });\n        } else if (count <= clearCount) {\n          _this._clearWarning(statName, 'max', {\n            values: values,\n            samples: relevantSamples\n          });\n        }\n      }\n\n      if (typeof limit.min === 'number') {\n        count = countLow(limit.min, values);\n\n        if (count >= raiseCount) {\n          _this._raiseWarning(statName, 'min', {\n            values: values,\n            samples: relevantSamples\n          });\n        } else if (count <= clearCount) {\n          _this._clearWarning(statName, 'min', {\n            values: values,\n            samples: relevantSamples\n          });\n        }\n      }\n\n      if (typeof limit.maxDuration === 'number' && samples.length > 1) {\n        relevantSamples = samples.slice(-2);\n        var prevValue = relevantSamples[0][statName];\n        var curValue = relevantSamples[1][statName];\n        var prevStreak = _this._currentStreaks.get(statName) || 0;\n        var streak = prevValue === curValue ? prevStreak + 1 : 0;\n\n        _this._currentStreaks.set(statName, streak);\n\n        if (streak >= limit.maxDuration) {\n          _this._raiseWarning(statName, 'maxDuration', {\n            value: streak\n          });\n        } else if (streak === 0) {\n          _this._clearWarning(statName, 'maxDuration', {\n            value: prevStreak\n          });\n        }\n      }\n\n      if (typeof limit.minStandardDeviation === 'number') {\n        var sampleSets = _this._supplementalSampleBuffers[statName];\n\n        if (!sampleSets || sampleSets.length < limit.sampleCount) {\n          return;\n        }\n\n        if (sampleSets.length > limit.sampleCount) {\n          sampleSets.splice(0, sampleSets.length - limit.sampleCount);\n        }\n\n        var flatSamples = flattenSamples(sampleSets.slice(-sampleCount));\n        var stdDev = calculateStandardDeviation(flatSamples);\n\n        if (typeof stdDev !== 'number') {\n          return;\n        }\n\n        if (stdDev < limit.minStandardDeviation) {\n          _this._raiseWarning(statName, 'minStandardDeviation', {\n            value: stdDev\n          });\n        } else {\n          _this._clearWarning(statName, 'minStandardDeviation', {\n            value: stdDev\n          });\n        }\n      }\n\n      [['maxAverage', function (x, y) {\n        return x > y;\n      }], ['minAverage', function (x, y) {\n        return x < y;\n      }]].forEach(function (_a) {\n        var thresholdName = _a[0],\n            comparator = _a[1];\n\n        if (typeof limit[thresholdName] === 'number' && values.length >= sampleCount) {\n          var avg = util_1.average(values);\n\n          if (comparator(avg, limit[thresholdName])) {\n            _this._raiseWarning(statName, thresholdName, {\n              values: values,\n              samples: relevantSamples\n            });\n          } else if (!comparator(avg, limit.clearValue || limit[thresholdName])) {\n            _this._clearWarning(statName, thresholdName, {\n              values: values,\n              samples: relevantSamples\n            });\n          }\n        }\n      });\n    });\n  };\n\n  return StatsMonitor;\n}(events_1.EventEmitter);\n\nexports.default = StatsMonitor;","map":{"version":3,"sources":["../../lib/twilio/statsMonitor.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\n\nimport { EventEmitter } from 'events';\nimport { InvalidArgumentError } from './errors';\nimport RTCSample from './rtc/sample';\nimport RTCWarning from './rtc/warning';\nimport { average } from './util';\n\nconst { getRTCStats } = require('./rtc/stats');\nconst Mos = require('./rtc/mos');\n\n// How many samples we use when testing metric thresholds\nconst SAMPLE_COUNT_METRICS = 5;\n\n// How many samples that need to cross the threshold to\n// raise or clear a warning.\nconst SAMPLE_COUNT_CLEAR = 0;\nconst SAMPLE_COUNT_RAISE = 3;\n\nconst SAMPLE_INTERVAL = 1000;\nconst WARNING_TIMEOUT = 5 * 1000;\n\nconst DEFAULT_THRESHOLDS: StatsMonitor.ThresholdOptions = {\n  audioInputLevel: { minStandardDeviation: 327.67, sampleCount: 10 },\n  audioOutputLevel: { minStandardDeviation: 327.67, sampleCount: 10 },\n  bytesReceived: { clearCount: 2, min: 1, raiseCount: 3, sampleCount: 3 },\n  bytesSent: { clearCount: 2, min: 1, raiseCount: 3, sampleCount: 3 },\n  jitter: { max: 30 },\n  mos: { min: 3 },\n  packetsLostFraction: [{\n    max: 1,\n  }, {\n    clearValue: 1,\n    maxAverage: 3,\n    sampleCount: 7,\n  }],\n  rtt: { max: 400 },\n};\n\n// Placeholders until we convert the respective files to TypeScript.\n/**\n * @private\n */\nexport type IPeerConnection = any;\n\n/**\n * @private\n */\nexport type IRTCStats = any;\n\n/**\n * @private\n */\nexport type IMos = any;\n\n/**\n * Count the number of values that cross the max threshold.\n * @private\n * @param max - The max allowable value.\n * @param values - The values to iterate over.\n * @returns The amount of values in which the stat crossed the threshold.\n */\nfunction countHigh(max: number, values: number[]): number {\n  return values.reduce((highCount, value) => highCount += (value > max) ? 1 : 0, 0);\n}\n\n/**\n * Count the number of values that cross the min threshold.\n * @private\n * @param min - The minimum allowable value.\n * @param values - The values to iterate over.\n * @returns The amount of values in which the stat crossed the threshold.\n */\nfunction countLow(min: number, values: number[]): number {\n  return values.reduce((lowCount, value) => lowCount += (value < min) ? 1 : 0, 0);\n}\n\n/**\n * Calculate the standard deviation from a list of numbers.\n * @private\n * @param values The list of numbers to calculate the standard deviation from.\n * @returns The standard deviation of a list of numbers.\n */\nfunction calculateStandardDeviation(values: number[]): number | null {\n  if (values.length <= 0) {\n    return null;\n  }\n\n  const valueAverage: number = values.reduce(\n    (partialSum: number, value: number) => partialSum + value,\n    0,\n  ) / values.length;\n\n  const diffSquared: number[] = values.map(\n    (value: number) => Math.pow(value - valueAverage, 2),\n  );\n\n  const stdDev: number = Math.sqrt(diffSquared.reduce(\n    (partialSum: number, value: number) => partialSum + value,\n    0,\n  ) / diffSquared.length);\n\n  return stdDev;\n}\n\n/**\n * Flatten a set of numerical sample sets into a single array of samples.\n * @param sampleSets\n */\nfunction flattenSamples(sampleSets: number[][]): number[] {\n  return sampleSets.reduce(\n    (flat: number[], current: number[]) => [...flat, ...current],\n    [],\n  );\n}\n\n/**\n * {@link StatsMonitor} polls a peerConnection via PeerConnection.getStats\n * and emits warnings when stats cross the specified threshold values.\n */\nclass StatsMonitor extends EventEmitter {\n  /**\n   * A map of warnings with their raised time\n   */\n  private _activeWarnings: Map<string, StatsMonitor.WarningTimestamp> = new Map();\n\n  /**\n   * A map of stats with the number of exceeded thresholds\n   */\n  private _currentStreaks: Map<string, number> = new Map();\n\n  /**\n   * Method to get stats from a PeerConnection object. Overrides getRTCStats library\n   */\n  private _getRTCStats: (peerConnection: IPeerConnection) => IRTCStats;\n\n  /**\n   * Keeps track of input volumes in the last second\n   */\n  private _inputVolumes: number[] = [];\n\n  /**\n   * How many samples we use when testing metric thresholds.\n   */\n  private _maxSampleCount: number;\n\n  /**\n   * For calculating Mos. Overrides Mos library\n   */\n  private _mos: IMos;\n\n  /**\n   * Keeps track of output volumes in the last second\n   */\n  private _outputVolumes: number[] = [];\n\n  /**\n   * The PeerConnection to monitor.\n   */\n  private _peerConnection: IPeerConnection;\n\n  /**\n   * Sample buffer. Saves most recent samples\n   */\n  private _sampleBuffer: RTCSample[] = [];\n\n  /**\n   * The setInterval id for fetching samples.\n   */\n  private _sampleInterval: NodeJS.Timer;\n\n  /**\n   * Keeps track of supplemental sample values.\n   *\n   * Currently used for constant audio detection. Contains an array of volume\n   * samples for each sample interval.\n   */\n  private _supplementalSampleBuffers: Record<string, number[][]> = {\n    audioInputLevel: [],\n    audioOutputLevel: [],\n  };\n\n  /**\n   * Threshold values for {@link StatsMonitor}\n   */\n  private _thresholds: StatsMonitor.ThresholdOptions;\n\n  /**\n   * Whether warnings should be enabled\n   */\n  private _warningsEnabled: boolean = true;\n\n  /**\n   * @constructor\n   * @param [options] - Optional settings\n   */\n  constructor(options?: StatsMonitor.Options) {\n    super();\n\n    options = options || {};\n    this._getRTCStats = options.getRTCStats || getRTCStats;\n    this._mos = options.Mos || Mos;\n    this._peerConnection = options.peerConnection;\n    this._thresholds = {...DEFAULT_THRESHOLDS, ...options.thresholds};\n\n    const thresholdSampleCounts = Object.values(this._thresholds)\n      .map((threshold: StatsMonitor.ThresholdOptions) => threshold.sampleCount)\n      .filter((sampleCount: number | undefined) => !!sampleCount);\n\n    this._maxSampleCount = Math.max(SAMPLE_COUNT_METRICS, ...thresholdSampleCounts);\n\n    if (this._peerConnection) {\n      this.enable(this._peerConnection);\n    }\n  }\n\n  /**\n   * Called when a volume sample is available\n   * @param inputVolume - Input volume level from 0 to 32767\n   * @param outputVolume - Output volume level from 0 to 32767\n   */\n  addVolumes(inputVolume: number, outputVolume: number): void {\n    this._inputVolumes.push(inputVolume);\n    this._outputVolumes.push(outputVolume);\n  }\n\n  /**\n   * Stop sampling RTC statistics for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n  disable(): this {\n    clearInterval(this._sampleInterval);\n    delete this._sampleInterval;\n\n    return this;\n  }\n\n  /**\n   * Disable warnings for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n  disableWarnings(): this {\n    if (this._warningsEnabled) {\n      this._activeWarnings.clear();\n    }\n\n    this._warningsEnabled = false;\n    return this;\n  }\n\n  /**\n   * Start sampling RTC statistics for this {@link StatsMonitor}.\n   * @param peerConnection - A PeerConnection to monitor.\n   * @returns The current {@link StatsMonitor}.\n   */\n  enable(peerConnection: IPeerConnection): this {\n    if (peerConnection) {\n      if (this._peerConnection && peerConnection !== this._peerConnection) {\n        throw new InvalidArgumentError('Attempted to replace an existing PeerConnection in StatsMonitor.enable');\n      }\n      this._peerConnection = peerConnection;\n    }\n\n    if (!this._peerConnection) {\n      throw new InvalidArgumentError('Can not enable StatsMonitor without a PeerConnection');\n    }\n\n    this._sampleInterval = this._sampleInterval ||\n      setInterval(this._fetchSample.bind(this), SAMPLE_INTERVAL);\n\n    return this;\n  }\n\n  /**\n   * Enable warnings for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n  enableWarnings(): this {\n    this._warningsEnabled = true;\n    return this;\n  }\n\n  /**\n   * Check if there is an active warning for a specific stat and threshold\n   * @param statName - The name of the stat to check\n   * @param thresholdName - The name of the threshold to check\n   * @returns Whether there is an active warning for a specific stat and threshold\n   */\n  hasActiveWarning(statName: string, thresholdName: string): boolean {\n    const warningId = `${statName}:${thresholdName}`;\n    return !!this._activeWarnings.get(warningId);\n  }\n\n  /**\n   * Add a sample to our sample buffer and remove the oldest if we are over the limit.\n   * @param sample - Sample to add\n   */\n  private _addSample(sample: RTCSample): void {\n    const samples = this._sampleBuffer;\n    samples.push(sample);\n\n    // We store 1 extra sample so that we always have (current, previous)\n    // available for all {sampleBufferSize} threshold validations.\n    if (samples.length > this._maxSampleCount) {\n      samples.splice(0, samples.length - this._maxSampleCount);\n    }\n  }\n\n  /**\n   * Clear an active warning.\n   * @param statName - The name of the stat to clear.\n   * @param thresholdName - The name of the threshold to clear\n   * @param [data] - Any relevant sample data.\n   */\n  private _clearWarning(statName: string, thresholdName: string, data?: RTCWarning): void {\n    const warningId = `${statName}:${thresholdName}`;\n    const activeWarning = this._activeWarnings.get(warningId);\n\n    if (!activeWarning || Date.now() - activeWarning.timeRaised < WARNING_TIMEOUT) { return; }\n    this._activeWarnings.delete(warningId);\n\n    this.emit('warning-cleared', {\n      ...data,\n      name: statName,\n      threshold: {\n        name: thresholdName,\n        value: this._thresholds[statName][thresholdName],\n      },\n    });\n  }\n\n  /**\n   * Create a sample object from a stats object using the previous sample, if available.\n   * @param stats - Stats retrieved from getStatistics\n   * @param [previousSample=null] - The previous sample to use to calculate deltas.\n   * @returns A universally-formatted version of RTC stats.\n   */\n  private _createSample(stats: IRTCStats, previousSample: RTCSample | null): RTCSample {\n    const previousBytesSent = previousSample && previousSample.totals.bytesSent || 0;\n    const previousBytesReceived = previousSample && previousSample.totals.bytesReceived || 0;\n    const previousPacketsSent = previousSample && previousSample.totals.packetsSent || 0;\n    const previousPacketsReceived = previousSample && previousSample.totals.packetsReceived || 0;\n    const previousPacketsLost = previousSample && previousSample.totals.packetsLost || 0;\n\n    const currentBytesSent = stats.bytesSent - previousBytesSent;\n    const currentBytesReceived = stats.bytesReceived - previousBytesReceived;\n    const currentPacketsSent = stats.packetsSent - previousPacketsSent;\n    const currentPacketsReceived = stats.packetsReceived - previousPacketsReceived;\n    const currentPacketsLost = stats.packetsLost - previousPacketsLost;\n    const currentInboundPackets = currentPacketsReceived + currentPacketsLost;\n    const currentPacketsLostFraction = (currentInboundPackets > 0) ?\n      (currentPacketsLost / currentInboundPackets) * 100 : 0;\n\n    const totalInboundPackets = stats.packetsReceived + stats.packetsLost;\n    const totalPacketsLostFraction = (totalInboundPackets > 0) ?\n      (stats.packetsLost / totalInboundPackets) * 100 : 100;\n\n    const rttValue = (typeof stats.rtt === 'number' || !previousSample) ? stats.rtt : previousSample.rtt;\n\n    const audioInputLevelValues = this._inputVolumes.splice(0);\n    this._supplementalSampleBuffers.audioInputLevel.push(audioInputLevelValues);\n\n    const audioOutputLevelValues = this._outputVolumes.splice(0);\n    this._supplementalSampleBuffers.audioOutputLevel.push(audioOutputLevelValues);\n\n    return {\n      audioInputLevel: Math.round(average(audioInputLevelValues)),\n      audioOutputLevel: Math.round(average(audioOutputLevelValues)),\n      bytesReceived: currentBytesReceived,\n      bytesSent: currentBytesSent,\n      codecName: stats.codecName,\n      jitter: stats.jitter,\n      mos: this._mos.calculate(rttValue, stats.jitter, previousSample && currentPacketsLostFraction),\n      packetsLost: currentPacketsLost,\n      packetsLostFraction: currentPacketsLostFraction,\n      packetsReceived: currentPacketsReceived,\n      packetsSent: currentPacketsSent,\n      rtt: rttValue,\n      timestamp: stats.timestamp,\n      totals: {\n        bytesReceived: stats.bytesReceived,\n        bytesSent: stats.bytesSent,\n        packetsLost: stats.packetsLost,\n        packetsLostFraction: totalPacketsLostFraction,\n        packetsReceived: stats.packetsReceived,\n        packetsSent: stats.packetsSent,\n      },\n    };\n  }\n\n  /**\n   * Get stats from the PeerConnection and add it to our list of samples.\n   */\n  private _fetchSample(): void {\n    this._getSample().then(sample => {\n      this._addSample(sample);\n      this._raiseWarnings();\n      this.emit('sample', sample);\n    }).catch(error => {\n      this.disable();\n      // We only bubble up any errors coming from pc.getStats()\n      // No need to attach a twilioError\n      this.emit('error', error);\n    });\n  }\n\n  /**\n   * Get stats from the PeerConnection.\n   * @returns A universally-formatted version of RTC stats.\n   */\n  private _getSample(): Promise<RTCSample> {\n    return this._getRTCStats(this._peerConnection).then((stats: IRTCStats) => {\n      let previousSample = null;\n      if (this._sampleBuffer.length) {\n        previousSample = this._sampleBuffer[this._sampleBuffer.length - 1];\n      }\n\n      return this._createSample(stats, previousSample);\n    });\n  }\n\n  /**\n   * Raise a warning and log its raised time.\n   * @param statName - The name of the stat to raise.\n   * @param thresholdName - The name of the threshold to raise\n   * @param [data] - Any relevant sample data.\n   */\n  private _raiseWarning(statName: string, thresholdName: string, data?: RTCWarning): void {\n    const warningId = `${statName}:${thresholdName}`;\n\n    if (this._activeWarnings.has(warningId)) { return; }\n    this._activeWarnings.set(warningId, { timeRaised: Date.now() });\n\n    const thresholds: StatsMonitor.ThresholdOption | StatsMonitor.ThresholdOption[] =\n      this._thresholds[statName];\n\n    let thresholdValue;\n\n    if (Array.isArray(thresholds)) {\n      const foundThreshold = thresholds.find(threshold => thresholdName in threshold);\n      if (foundThreshold) {\n        thresholdValue = foundThreshold[thresholdName as keyof StatsMonitor.ThresholdOption];\n      }\n    } else {\n      thresholdValue = this._thresholds[statName][thresholdName];\n    }\n\n    this.emit('warning', {\n      ...data,\n      name: statName,\n      threshold: {\n        name: thresholdName,\n        value: thresholdValue,\n      },\n    });\n  }\n\n  /**\n   * Apply our thresholds to our array of RTCStat samples.\n   */\n  private _raiseWarnings(): void {\n    if (!this._warningsEnabled) { return; }\n\n    Object.keys(this._thresholds).forEach(name => this._raiseWarningsForStat(name));\n  }\n\n  /**\n   * Apply thresholds for a given stat name to our array of\n   * RTCStat samples and raise or clear any associated warnings.\n   * @param statName - Name of the stat to compare.\n   */\n  private _raiseWarningsForStat(statName: string): void {\n    const limits: StatsMonitor.ThresholdOptions[] =\n      Array.isArray(this._thresholds[statName])\n        ? this._thresholds[statName]\n        : [this._thresholds[statName]];\n\n    limits.forEach((limit: StatsMonitor.ThresholdOptions) => {\n      const samples = this._sampleBuffer;\n\n      const clearCount = limit.clearCount || SAMPLE_COUNT_CLEAR;\n      const raiseCount = limit.raiseCount || SAMPLE_COUNT_RAISE;\n      const sampleCount = limit.sampleCount || this._maxSampleCount;\n\n      let relevantSamples = samples.slice(-sampleCount);\n      const values = relevantSamples.map(sample => sample[statName]);\n\n      // (rrowland) If we have a bad or missing value in the set, we don't\n      // have enough information to throw or clear a warning. Bail out.\n      const containsNull = values.some(value => typeof value === 'undefined' || value === null);\n\n      if (containsNull) {\n        return;\n      }\n\n      let count;\n      if (typeof limit.max === 'number') {\n        count = countHigh(limit.max, values);\n        if (count >= raiseCount) {\n          this._raiseWarning(statName, 'max', { values, samples: relevantSamples });\n        } else if (count <= clearCount) {\n          this._clearWarning(statName, 'max', { values, samples: relevantSamples });\n        }\n      }\n\n      if (typeof limit.min === 'number') {\n        count = countLow(limit.min, values);\n        if (count >= raiseCount) {\n          this._raiseWarning(statName, 'min', { values, samples: relevantSamples });\n        } else if (count <= clearCount) {\n          this._clearWarning(statName, 'min', { values, samples: relevantSamples });\n        }\n      }\n\n      if (typeof limit.maxDuration === 'number' && samples.length > 1) {\n        relevantSamples = samples.slice(-2);\n        const prevValue = relevantSamples[0][statName];\n        const curValue = relevantSamples[1][statName];\n\n        const prevStreak = this._currentStreaks.get(statName) || 0;\n        const streak = (prevValue === curValue) ? prevStreak + 1 : 0;\n\n        this._currentStreaks.set(statName, streak);\n\n        if (streak >= limit.maxDuration) {\n          this._raiseWarning(statName, 'maxDuration', { value: streak });\n        } else if (streak === 0) {\n          this._clearWarning(statName, 'maxDuration', { value: prevStreak });\n        }\n      }\n\n      if (typeof limit.minStandardDeviation === 'number') {\n        const sampleSets: number[][] = this._supplementalSampleBuffers[statName];\n        if (!sampleSets || sampleSets.length < limit.sampleCount) {\n          return;\n        }\n        if (sampleSets.length > limit.sampleCount) {\n          sampleSets.splice(0, sampleSets.length - limit.sampleCount);\n        }\n        const flatSamples: number[] = flattenSamples(sampleSets.slice(-sampleCount));\n        const stdDev: number | null = calculateStandardDeviation(flatSamples);\n\n        if (typeof stdDev !== 'number') {\n          return;\n        }\n\n        if (stdDev < limit.minStandardDeviation) {\n          this._raiseWarning(statName, 'minStandardDeviation', { value: stdDev });\n        } else {\n          this._clearWarning(statName, 'minStandardDeviation', { value: stdDev });\n        }\n      }\n\n      ([\n        ['maxAverage', (x: number, y: number) => x > y],\n        ['minAverage', (x: number, y: number) => x < y],\n      ] as const).forEach(([thresholdName, comparator]) => {\n        if (typeof limit[thresholdName] === 'number' && values.length >= sampleCount) {\n          const avg: number = average(values);\n\n          if (comparator(avg, limit[thresholdName])) {\n            this._raiseWarning(statName, thresholdName, { values, samples: relevantSamples });\n          } else if (!comparator(avg, limit.clearValue || limit[thresholdName])) {\n            this._clearWarning(statName, thresholdName, { values, samples: relevantSamples });\n          }\n        }\n      });\n    });\n  }\n}\n\nnamespace StatsMonitor {\n  /**\n   * Config options to be passed to the {@link StatsMonitor} constructor.\n   * @private\n   */\n  export interface Options {\n    /**\n     * Method to get stats from a PeerConnection object\n     */\n    getRTCStats?: (peerConnection: IPeerConnection) => IRTCStats;\n\n    /**\n     * For calculating Mos. Overrides Mos library\n     */\n    Mos?: IMos;\n\n    /**\n     * The PeerConnection to monitor.\n     */\n    peerConnection?: IPeerConnection;\n\n    /**\n     * Optional custom threshold values.\n     */\n    thresholds?: ThresholdOptions;\n  }\n\n  /**\n   * Speficic threshold value for {@link ThresholdOptions}\n   * @private\n   */\n  export interface ThresholdOption {\n    /**\n     * How many samples that need to cross the threshold to clear a warning.\n     * Overrides SAMPLE_COUNT_CLEAR\n     */\n    clearCount?: number;\n\n    /**\n     * Used with the `minAverage` and `maxAverage` options. If `maxAverage` is\n     * used, then the warning will be cleared when at or below this value. If\n     * `minAverage` is used, then the warning will be cleared at or above this\n     * value.\n     */\n    clearValue?: number;\n\n    /**\n     * Warning will be raised if tracked metric rises above this value.\n     */\n    max?: number;\n\n    /**\n     * Warning will be raised based on the average over `sampleCount` samples.\n     * The warning is raised if the average is above the `raiseValue` amount and\n     * is cleared when below the `clearValue` amount.\n     */\n    maxAverage?: number;\n\n    /**\n     * Warning will be raised if tracked metric stays constant for\n     * the specified number of consequent samples.\n     */\n    maxDuration?: number;\n\n    /**\n     * Warning will be raised if tracked metric falls below this value.\n     */\n    min?: number;\n\n    /**\n     * Warning will be raised based on the average over `sampleCount` samples.\n     * The warning is raised if the average is below the `raiseValue` amount and\n     * is cleared when above the `clearValue` amount.\n     */\n    minAverage?: number;\n\n    /**\n     * Warning will be raised if the standard deviation of the tracked metric\n     * does not exceed this value.\n     */\n    minStandardDeviation?: number;\n\n    /**\n     * How many samples that need to cross the threshold to raise a warning.\n     * Overrides SAMPLE_COUNT_RAISE\n     */\n    raiseCount?: number;\n\n    /**\n     * How many samples we use when testing metric thresholds.\n     * Overrides _maxSampleCount\n     */\n    sampleCount?: number;\n  }\n\n  /**\n   * Threshold values for {@link StatsMonitor}\n   * @private\n   */\n  export interface ThresholdOptions {\n    [key: string]: any;\n\n    /**\n     * Audio input level between 0 and 32767, representing -100 to -30 dB.\n     */\n    audioInputLevel?: ThresholdOption;\n\n    /**\n     * Audio output level between 0 and 32767, representing -100 to -30 dB.\n     */\n    audioOutputLevel?: ThresholdOption;\n\n    /**\n     * Rules to apply to sample.jitter\n     */\n    jitter?: ThresholdOption;\n\n    /**\n     * Rules to apply to sample.mos\n     */\n    mos?: ThresholdOption;\n\n    /**\n     * Rules to apply to sample.packetsLostFraction\n     */\n    packetsLostFraction?: ThresholdOption[];\n\n    /**\n     * Rules to apply to sample.rtt\n     */\n    rtt?: ThresholdOption;\n  }\n\n  /**\n   * Timestamp for raised warnings\n   * @private\n   */\n  export interface WarningTimestamp {\n    /**\n     * Timestamp in milliseconds\n     */\n    timeRaised: number;\n  }\n}\n\nexport default StatsMonitor;\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}