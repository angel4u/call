{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @packageDocumentation\n * @module Voice\n */\n\nvar constants_1 = require(\"./constants\");\n\nvar errors_1 = require(\"./errors\");\n\nvar DEFAULT_TEST_SOUND_URL = constants_1.SOUNDS_BASE_URL + \"/outgoing.mp3\";\n/**\n * A smart collection containing a Set of active output devices.\n * @publicapi\n */\n\nvar OutputDeviceCollection =\n/** @class */\nfunction () {\n  /**\n   * @private\n   */\n  function OutputDeviceCollection(_name, _availableDevices, _beforeChange, _isSupported) {\n    this._name = _name;\n    this._availableDevices = _availableDevices;\n    this._beforeChange = _beforeChange;\n    this._isSupported = _isSupported;\n    /**\n     * The currently active output devices.\n     */\n\n    this._activeDevices = new Set();\n  }\n  /**\n   * Delete a device from the collection. If no devices remain, the 'default'\n   * device will be added as the sole device. If no `default` device exists,\n   * the first available device will be used.\n   * @param device - The device to delete from the collection\n   * @returns whether the device was present before it was deleted\n   */\n\n\n  OutputDeviceCollection.prototype.delete = function (device) {\n    var wasDeleted = !!this._activeDevices.delete(device);\n    var defaultDevice = this._availableDevices.get('default') || Array.from(this._availableDevices.values())[0];\n\n    if (!this._activeDevices.size && defaultDevice) {\n      this._activeDevices.add(defaultDevice);\n    } // Call _beforeChange so that the implementation can react when a device is\n    // removed or lost.\n\n\n    var deviceIds = Array.from(this._activeDevices.values()).map(function (deviceInfo) {\n      return deviceInfo.deviceId;\n    });\n\n    this._beforeChange(this._name, deviceIds);\n\n    return !!wasDeleted;\n  };\n  /**\n   * Get the current set of devices.\n   */\n\n\n  OutputDeviceCollection.prototype.get = function () {\n    return this._activeDevices;\n  };\n  /**\n   * Replace the current set of devices with a new set of devices.\n   * @param deviceIdOrIds - An ID or array of IDs of devices to replace the existing devices with.\n   * @returns Rejects if this feature is not supported, any of the supplied IDs are not found,\n   * or no IDs are passed.\n   */\n\n\n  OutputDeviceCollection.prototype.set = function (deviceIdOrIds) {\n    var _this = this;\n\n    if (!this._isSupported) {\n      return Promise.reject(new errors_1.NotSupportedError('This browser does not support audio output selection'));\n    }\n\n    var deviceIds = Array.isArray(deviceIdOrIds) ? deviceIdOrIds : [deviceIdOrIds];\n\n    if (!deviceIds.length) {\n      return Promise.reject(new errors_1.InvalidArgumentError('Must specify at least one device to set'));\n    }\n\n    var missingIds = [];\n    var devices = deviceIds.map(function (id) {\n      var device = _this._availableDevices.get(id);\n\n      if (!device) {\n        missingIds.push(id);\n      }\n\n      return device;\n    });\n\n    if (missingIds.length) {\n      return Promise.reject(new errors_1.InvalidArgumentError(\"Devices not found: \" + missingIds.join(', ')));\n    }\n\n    return new Promise(function (resolve) {\n      resolve(_this._beforeChange(_this._name, deviceIds));\n    }).then(function () {\n      _this._activeDevices.clear();\n\n      devices.forEach(_this._activeDevices.add, _this._activeDevices);\n    });\n  };\n  /**\n   * Test the devices by playing audio through them.\n   * @param [soundUrl] - An optional URL. If none is specified, we will\n   *   play a default test tone.\n   * @returns Resolves with the result of the underlying HTMLAudioElements' play() calls.\n   */\n\n\n  OutputDeviceCollection.prototype.test = function (soundUrl) {\n    if (soundUrl === void 0) {\n      soundUrl = DEFAULT_TEST_SOUND_URL;\n    }\n\n    if (!this._isSupported) {\n      return Promise.reject(new errors_1.NotSupportedError('This browser does not support audio output selection'));\n    }\n\n    if (!this._activeDevices.size) {\n      return Promise.reject(new errors_1.InvalidStateError('No active output devices to test'));\n    }\n\n    return Promise.all(Array.from(this._activeDevices).map(function (device) {\n      var el; // (rrowland) We need to wait for the oncanplay event because of a regression introduced\n      // in Chrome M72: https://bugs.chromium.org/p/chromium/issues/detail?id=930876\n\n      return new Promise(function (resolve) {\n        el = new Audio(soundUrl);\n        el.oncanplay = resolve;\n      }).then(function () {\n        return el.setSinkId(device.deviceId).then(function () {\n          return el.play();\n        });\n      });\n    }));\n  };\n\n  return OutputDeviceCollection;\n}();\n\nexports.default = OutputDeviceCollection;","map":{"version":3,"sources":["../../lib/twilio/outputdevicecollection.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n */\nimport { SOUNDS_BASE_URL } from './constants';\nimport { InvalidArgumentError, InvalidStateError, NotSupportedError } from './errors';\nconst DEFAULT_TEST_SOUND_URL = `${SOUNDS_BASE_URL}/outgoing.mp3`;\n\n/**\n * A smart collection containing a Set of active output devices.\n * @publicapi\n */\nexport default class OutputDeviceCollection {\n  /**\n   * The currently active output devices.\n   */\n  private _activeDevices: Set<MediaDeviceInfo> = new Set();\n\n  /**\n   * @private\n   */\n  constructor(private _name: string,\n              private _availableDevices: Map<string, MediaDeviceInfo>,\n              private _beforeChange: (name: string, devices: string[]) => Promise<void>,\n              private _isSupported: boolean) { }\n\n  /**\n   * Delete a device from the collection. If no devices remain, the 'default'\n   * device will be added as the sole device. If no `default` device exists,\n   * the first available device will be used.\n   * @param device - The device to delete from the collection\n   * @returns whether the device was present before it was deleted\n   */\n  delete(device: MediaDeviceInfo): boolean {\n    const wasDeleted: boolean = !!(this._activeDevices.delete(device));\n\n    const defaultDevice: MediaDeviceInfo = this._availableDevices.get('default')\n      || Array.from(this._availableDevices.values())[0];\n\n    if (!this._activeDevices.size && defaultDevice) {\n      this._activeDevices.add(defaultDevice);\n    }\n\n    // Call _beforeChange so that the implementation can react when a device is\n    // removed or lost.\n    const deviceIds = Array.from(this._activeDevices.values()).map(deviceInfo => deviceInfo.deviceId);\n\n    this._beforeChange(this._name, deviceIds);\n    return !!wasDeleted;\n  }\n\n  /**\n   * Get the current set of devices.\n   */\n  get(): Set<MediaDeviceInfo> {\n    return this._activeDevices;\n  }\n\n  /**\n   * Replace the current set of devices with a new set of devices.\n   * @param deviceIdOrIds - An ID or array of IDs of devices to replace the existing devices with.\n   * @returns Rejects if this feature is not supported, any of the supplied IDs are not found,\n   * or no IDs are passed.\n   */\n  set(deviceIdOrIds: string | string[]): Promise<void> {\n    if (!this._isSupported) {\n      return Promise.reject(new NotSupportedError('This browser does not support audio output selection'));\n    }\n\n    const deviceIds: string[] = Array.isArray(deviceIdOrIds) ? deviceIdOrIds : [deviceIdOrIds];\n\n    if (!deviceIds.length) {\n      return Promise.reject(new InvalidArgumentError('Must specify at least one device to set'));\n    }\n\n    const missingIds: string[] = [];\n    const devices: Array<MediaDeviceInfo | undefined> = deviceIds.map((id: string) => {\n      const device: MediaDeviceInfo | undefined = this._availableDevices.get(id);\n      if (!device) { missingIds.push(id); }\n      return device;\n    });\n\n    if (missingIds.length) {\n      return Promise.reject(new InvalidArgumentError(`Devices not found: ${missingIds.join(', ')}`));\n    }\n\n    return new Promise(resolve => {\n      resolve(this._beforeChange(this._name, deviceIds));\n    }).then(() => {\n      this._activeDevices.clear();\n      devices.forEach(this._activeDevices.add, this._activeDevices);\n    });\n  }\n\n  /**\n   * Test the devices by playing audio through them.\n   * @param [soundUrl] - An optional URL. If none is specified, we will\n   *   play a default test tone.\n   * @returns Resolves with the result of the underlying HTMLAudioElements' play() calls.\n   */\n  test(soundUrl: string = DEFAULT_TEST_SOUND_URL): Promise<any> {\n    if (!this._isSupported) {\n      return Promise.reject(new NotSupportedError('This browser does not support audio output selection'));\n    }\n\n    if (!this._activeDevices.size) {\n      return Promise.reject(new InvalidStateError('No active output devices to test'));\n    }\n\n    return Promise.all(Array.from(this._activeDevices).map((device: MediaDeviceInfo) => {\n      let el: HTMLAudioElement;\n\n      // (rrowland) We need to wait for the oncanplay event because of a regression introduced\n      // in Chrome M72: https://bugs.chromium.org/p/chromium/issues/detail?id=930876\n      return new Promise((resolve: Function) => {\n        el = new Audio(soundUrl);\n        (el as any).oncanplay = resolve;\n      }).then(() => (el as any).setSinkId(device.deviceId).then(() => el.play()));\n    }));\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}