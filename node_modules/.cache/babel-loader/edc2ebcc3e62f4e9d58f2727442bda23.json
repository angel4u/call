{"ast":null,"code":"import _taggedTemplateLiteral from \"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";\nimport _defineProperty from \"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"/root/twilio-phone-client/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/root/twilio-phone-client/node_modules/@babel/runtime/helpers/esm/inherits\";\n\nvar _jsxFileName = \"/root/twilio-phone-client/src/components/PhoneClient.js\",\n    _templateObject;\n\nimport React, { Component } from 'react';\nimport styled from 'styled-components';\nimport update from 'immutability-helper';\nimport jwt_decode from 'jwt-decode';\nimport { formParams, stringify } from '../lib/common';\nimport ChannelSwitcher from './ChannelSwitcher';\nimport ChannelContent from './ChannelContent';\nimport AuthForm from './AuthForm';\nimport { ModalMessage } from './CommonComponents';\n\nvar TwilioChat = require('twilio-chat');\n\nvar TwilioVoice = require('twilio-client');\n\nvar maxAuthAttempts = 3;\n\nvar Canvas = /*#__PURE__*/function (_Component) {\n  _inherits(Canvas, _Component);\n\n  function Canvas(props) {\n    var _this;\n\n    _classCallCheck(this, Canvas);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Canvas).call(this, props));\n\n    _this._fetchToken = function () {\n      return new Promise(function (resolve, reject) {\n        var accessTokenGenerator = (process.env.REACT_APP_RUNTIME_DOMAIN ? process.env.REACT_APP_RUNTIME_DOMAIN : '') + '/getAccessToken';\n        var body = formParams({\n          secret: _this.state.secret // handle escaping\n\n        });\n        fetch(accessTokenGenerator, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n          },\n          body: body\n        }).then( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(response) {\n            var errText;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    if (!(response.status === 200)) {\n                      _context.next = 4;\n                      break;\n                    }\n\n                    return _context.abrupt(\"return\", response.text());\n\n                  case 4:\n                    if (!(response.status === 401)) {\n                      _context.next = 11;\n                      break;\n                    }\n\n                    _context.next = 7;\n                    return response.text();\n\n                  case 7:\n                    errText = _context.sent;\n\n                    _this.setState({\n                      authorized: false,\n                      authError: _this.state.authCounter === 0 ? '' : errText,\n                      authCounter: _this.state.authCounter + 1\n                    });\n\n                    console.error('Authorization failed - check if SECRET env variable is set correctly:', errText);\n                    reject(errText);\n\n                  case 11:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee);\n          }));\n\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }()).then(function (token) {\n          if (token !== undefined) {\n            _this.setState({\n              authorized: true,\n              authError: '',\n              authCounter: 0\n            });\n\n            resolve(token);\n          }\n        }).catch(function (err) {\n          console.error('Error fetching Access Token:', err);\n\n          _this.setState({\n            displayError: \"Error fetching Access Token (\".concat(stringify(err), \")\")\n          });\n\n          reject(err);\n        });\n      });\n    };\n\n    _this.setSecret = function (secret) {\n      _this.setState({\n        secret: secret\n      }, function () {\n        return _this.initClients();\n      });\n    };\n\n    _this.setCallDisplay = function (callDisplay) {\n      _this.setState({\n        callDisplay: callDisplay\n      });\n    };\n\n    _this.setCallConnection = function (callConnection) {\n      _this.callConnection = callConnection;\n    };\n\n    _this.getCallConnection = function () {\n      return _this.callConnection;\n    };\n\n    _this.setCallStartTime = function (callStartTime) {\n      _this.callStartTime = callStartTime;\n    };\n\n    _this.getCallStartTime = function () {\n      return _this.callStartTime;\n    };\n\n    _this.setCallNextKeyReset = function (callNextKeyReset) {\n      _this.callNextKeyReset = callNextKeyReset;\n    };\n\n    _this.getCallNextKeyReset = function () {\n      return _this.callNextKeyReset;\n    };\n\n    _this.setCallTypingPN = function (callTypingPN) {\n      _this.callTypingPN = callTypingPN;\n    };\n\n    _this.getCallTypingPN = function () {\n      return _this.callTypingPN;\n    };\n\n    _this.setUnreadsCache = function (contact, unread) {\n      _this.setState({\n        msgUnreadsCache: update(_this.state.msgUnreadsCache, _defineProperty({}, contact, {\n          $set: unread\n        }))\n      });\n    };\n\n    _this.setUnreadMsgs = function (channel, contact) {\n      // if there's no consumed messages, all messages are unread\n      // (getUnconsumedMessagesCount doesn't really work in this case\n      // so we need to handle this edge case manually)\n      if (channel.lastConsumedMessageIndex === null) {\n        channel.getMessagesCount().then(function (cnt) {\n          _this.setState({\n            msgUnreadsCache: update(_this.state.msgUnreadsCache, _defineProperty({}, contact, {\n              $set: cnt\n            }))\n          });\n        });\n      } else {\n        channel.getUnconsumedMessagesCount().then(function (cnt) {\n          _this.setState({\n            msgUnreadsCache: update(_this.state.msgUnreadsCache, _defineProperty({}, contact, {\n              $set: cnt\n            }))\n          });\n        });\n      }\n    };\n\n    _this.setMsgCachePage = function (contact, messages, paginator) {\n      _this.setState({\n        msgCache: update(_this.state.msgCache, _defineProperty({}, contact, {\n          $set: messages\n        })),\n        pgtrCache: update(_this.state.msgPgtrCache, _defineProperty({}, contact, {\n          $set: paginator\n        }))\n      });\n    };\n\n    _this.addMsgCachePage = function (contact, messages, paginator) {\n      _this.setState({\n        msgCache: update(_this.state.msgCache, _defineProperty({}, contact, {\n          $unshift: messages\n        })),\n        pgtrCache: update(_this.state.msgPgtrCache, _defineProperty({}, contact, {\n          $set: paginator\n        }))\n      });\n    };\n\n    _this.addMsgCacheMsg = function (contact, msg) {\n      if (_this.state.msgCache[contact] === undefined) {\n        _this.setState({\n          msgCache: update(_this.state.msgCache, {\n            $merge: _defineProperty({}, contact, [])\n          })\n        });\n      }\n\n      _this.setState({\n        msgCache: update(_this.state.msgCache, _defineProperty({}, contact, {\n          $push: [msg]\n        }))\n      });\n    };\n\n    _this.getToken = function () {\n      return new Promise(function (resolve, reject) {\n        if (_this.state.token) {\n          var decoded_token = jwt_decode(_this.state.token);\n          var s_now = Math.floor(Date.now() / 1000);\n          var s_expire = decoded_token.exp;\n          console.log(\"Token is expiring in \".concat(s_expire - s_now, \"s\"));\n\n          if (s_expire - s_now < 300) {\n            // token is about to expire, let's renew it\n            _this._fetchToken().then(function (token) {\n              _this.setState({\n                token: token\n              });\n\n              _this.getTokenActive = false;\n              resolve(token);\n            });\n          } else {\n            _this.getTokenActive = false;\n            resolve(_this.state.token);\n          }\n        } else {\n          _this._fetchToken().then(function (token) {\n            _this.setState({\n              token: token\n            });\n\n            _this.getTokenActive = false;\n            resolve(token);\n          });\n        }\n      });\n    };\n\n    _this.initClients = function () {\n      if (_this.state.chatClient === null && _this.state.voiceClient === null) {\n        _this.getToken().then(function (token) {\n          // initialize Voice client\n          var voiceClient = new TwilioVoice.Device();\n          voiceClient.setup(token, {\n            // Set Opus as our preferred codec. Opus generally performs better,\n            // requiring less bandwidth and providing better audio quality in\n            // restrained network conditions. Opus will be default in 2.0.\n            codecPreferences: ['opus', 'pcmu'],\n            // Use fake DTMF tones client-side. Real tones are still sent to the\n            // other end of the call, but the client-side DTMF tones are fake.\n            // This prevents the local mic capturing the DTMF tone a second time\n            // and sending the tone twice. This will be default in 2.0.\n            fakeLocalDTMF: true,\n            // Use `enableRingingState` to enable the device to emit the `ringing`\n            // state. The TwiML backend also needs to have the attribute\n            // `answerOnBridge` also set to true in the `Dial` verb. This option\n            // changes the behavior of the SDK to consider a call `ringing`\n            // starting from the connection to the TwiML backend to when the\n            // recipient of the `Dial` verb answers.\n            enableRingingState: true\n          });\n          voiceClient.on('ready', function (device) {\n            console.log('voiceClient is ready');\n          });\n          voiceClient.on('error', function (error) {\n            console.log('Twilio.Device Error: ', error); // JWT Token Expired\n\n            if (error.code === 31205) {\n              _this.getToken().then(function () {\n                _this.state.chatClient.updateToken(_this.state.token);\n\n                _this.state.voiceClient.updateToken(_this.state.token);\n\n                console.log('Token updated after expiration (from voiceClient)');\n              });\n            }\n          });\n          voiceClient.on('incoming', function (connection) {\n            console.log('PC: INCOMING event fired from ' + connection.parameters.From);\n\n            _this.setState({\n              incomingCall: connection\n            });\n\n            _this.setCallConnection(connection);\n\n            connection.on('reject', function (connection) {\n              // when incoming call gets rejected from CallCanvas, update state\n              _this.setState({\n                incomingCall: null\n              });\n            });\n          });\n          voiceClient.on('cancel', function (connection) {\n            console.log('PC: CANCEL event fired');\n\n            _this.setState({\n              incomingCall: null\n            });\n          });\n          voiceClient.on('connect', function (connection) {\n            console.log('PC: CONNECT event fired');\n\n            _this.setState({\n              incomingCall: null\n            }); // cleanup the incoming call state and let the component handle this natively\n\n          });\n          voiceClient.on('disconnect', function (connection) {\n            console.log('PC: DISCONNECT event fired');\n\n            _this.setCallDisplay('');\n\n            _this.setCallStartTime(null);\n\n            _this.setCallTypingPN(true);\n\n            _this.setCallNextKeyReset(false);\n          });\n          console.log('voiceClient is initialized');\n\n          _this.setState({\n            voiceClient: voiceClient\n          }); // initialize Chat client\n\n\n          TwilioChat.Client.create(token).then(function (chatClient) {\n            _this.setState({\n              chatClient: chatClient\n            });\n\n            chatClient.getSubscribedChannels().then(function (paginator) {\n              var chatChannelList = {};\n\n              for (var i = 0; i < paginator.items.length; i++) {\n                var channel = paginator.items[i];\n                chatChannelList[channel.uniqueName] = channel;\n              }\n\n              console.log('chatClient is initialized');\n\n              _this.setState({\n                chatChannelList: chatChannelList\n              });\n            });\n            chatClient.on('channelRemoved', function (channel) {\n              if (_this.state.chatChannelList !== null) {\n                _this.setState({\n                  chatChannelList: update(_this.state.chatChannelList, {\n                    $unset: [channel.uniqueName]\n                  }),\n                  msgUnreadsCache: update(_this.state.msgUnreadsCache, {\n                    $unset: [channel.uniqueName]\n                  }),\n                  msgCache: update(_this.state.msgCache, {\n                    $unset: [channel.uniqueName]\n                  }),\n                  msgPgtrCache: update(_this.state.msgPgtrCache, {\n                    $unset: [channel.uniqueName]\n                  })\n                });\n              }\n            });\n            chatClient.on('channelAdded', function (channel) {\n              if (_this.state.chatChannelList !== null) {\n                _this.setState({\n                  chatChannelList: update(_this.state.chatChannelList, {\n                    $merge: _defineProperty({}, channel.uniqueName, channel)\n                  }),\n                  msgCache: update(_this.state.msgCache, _defineProperty({}, channel.uniqueName, {\n                    $set: undefined\n                  }))\n                });\n              }\n            });\n            chatClient.on('channelUpdated', function (_ref2) {\n              var channel = _ref2.channel,\n                  updateReasons = _ref2.updateReasons;\n\n              if (_this.state.chatChannelList !== null && updateReasons.includes('lastMessage')) {\n                _this.setState({\n                  chatChannelList: update(_this.state.chatChannelList, _defineProperty({}, channel.uniqueName, {\n                    $set: channel\n                  }))\n                });\n              }\n            });\n            chatClient.on('tokenAboutToExpire', function () {\n              _this.getToken().then(function () {\n                _this.state.chatClient.updateToken(_this.state.token);\n\n                _this.state.voiceClient.updateToken(_this.state.token);\n\n                console.log('Token updated before expiration');\n              });\n            });\n            chatClient.on('tokenExpired', function () {\n              _this.getToken().then(function () {\n                _this.state.chatClient.updateToken(_this.state.token);\n\n                _this.state.voiceClient.updateToken(_this.state.token);\n\n                console.log('Token updated after expiration (from chatClient)');\n              });\n            });\n          });\n        });\n      }\n    };\n\n    _this.setChannel = function (selectedChannel) {\n      _this.setState({\n        selectedChannel: selectedChannel\n      });\n    };\n\n    _this.state = {\n      selectedChannel: 'sms',\n      chatClient: null,\n      chatChannelList: null,\n      voiceClient: null,\n      incomingCall: null,\n      token: null,\n      authorized: false,\n      authCounter: 0,\n      authError: '',\n      secret: localStorage.getItem('secret'),\n      displayError: null,\n      msgUnreadsCache: {},\n      msgCache: {},\n      msgPgtrCache: {},\n      callDisplay: '' // phone number after formatting\n\n    };\n    _this.callConnection = null;\n    _this.callStartTime = null;\n    _this.callNextKeyReset = false; // is user typing a phone number (i.e. no call in progress) or\n    // are they using DTMF during a call?\n\n    _this.callTypingPN = true;\n    return _this;\n  }\n  /**\n   * Fetch token from the <tt>getAccessToken</tt> function.\n   * @returns {string}\n   */\n\n\n  _createClass(Canvas, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.initClients();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {}\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.state.chatClient) {\n        this.state.chatClient.removeAllListeners('channelAdded');\n        this.state.chatClient.removeAllListeners('channelUpdated');\n      }\n\n      if (this.state.voiceClient) {\n        this.state.voiceClient.removeAllListeners('ready');\n        this.state.voiceClient.removeAllListeners('error');\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (this.state.displayError) {\n        return /*#__PURE__*/React.createElement(ViewPort, {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 436,\n            columnNumber: 9\n          }\n        }, /*#__PURE__*/React.createElement(ModalMessage, {\n          msg: 'Error occurred: ' + this.state.displayError,\n          img: \"alert\",\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 437,\n            columnNumber: 11\n          }\n        }));\n      } else if ( // if the initial login attempt hasn't bee made yet, don't show anything\n      // (to avoid UI redraws with login form flashing brieafly before client load)\n      this.state.authorized === false && this.state.authCounter === 0) {\n        return /*#__PURE__*/React.createElement(ViewPort, {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 449,\n            columnNumber: 14\n          }\n        });\n      } else if ( // if the initial login attempt failed, show a login form\n      this.state.authorized === false && this.state.authCounter <= maxAuthAttempts) {\n        return /*#__PURE__*/React.createElement(ViewPort, {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 456,\n            columnNumber: 9\n          }\n        }, /*#__PURE__*/React.createElement(AuthForm, {\n          setSecret: this.setSecret,\n          errMsg: this.state.authError,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 457,\n            columnNumber: 11\n          }\n        }));\n      } else if ( // if the max number of attempts was exceeded, show error to discourage\n      // repeated logins\n      this.state.authorized === false && this.state.authCounter > maxAuthAttempts) {\n        return /*#__PURE__*/React.createElement(ViewPort, {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 467,\n            columnNumber: 9\n          }\n        }, /*#__PURE__*/React.createElement(ModalMessage, {\n          msg: \"Authorization failed\",\n          img: \"auth_fail\",\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 468,\n            columnNumber: 11\n          }\n        }));\n      } else {\n        return /*#__PURE__*/React.createElement(React.StrictMode, {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 473,\n            columnNumber: 9\n          }\n        }, /*#__PURE__*/React.createElement(ViewPort, {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 474,\n            columnNumber: 11\n          }\n        }, /*#__PURE__*/React.createElement(ChannelSwitcher, {\n          setChannel: this.setChannel,\n          selectedChannel: this.state.selectedChannel,\n          incomingCall: this.state.incomingCall,\n          msgUnreadsCache: this.state.msgUnreadsCache,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 475,\n            columnNumber: 13\n          }\n        }), /*#__PURE__*/React.createElement(ChannelContent, {\n          msgUnreadsCache: this.state.msgUnreadsCache,\n          setUnreadsCache: this.setUnreadsCache,\n          setUnreadMsgs: this.setUnreadMsgs,\n          msgCache: this.state.msgCache,\n          msgPgtrCache: this.state.msgPgtrCache,\n          addMsgCachePage: this.addMsgCachePage,\n          setMsgCachePage: this.setMsgCachePage,\n          addMsgCacheMsg: this.addMsgCacheMsg,\n          setCallDisplay: this.setCallDisplay,\n          callDisplay: this.state.callDisplay,\n          setCallConnection: this.setCallConnection,\n          getCallConnection: this.getCallConnection,\n          setCallStartTime: this.setCallStartTime,\n          getCallStartTime: this.getCallStartTime,\n          setCallNextKeyReset: this.setCallNextKeyReset,\n          getCallNextKeyReset: this.getCallNextKeyReset,\n          setCallTypingPN: this.setCallTypingPN,\n          getCallTypingPN: this.getCallTypingPN,\n          selectedChannel: this.state.selectedChannel,\n          secret: this.state.secret,\n          client: this.state.selectedChannel === 'sms' ? this.state.chatClient : this.state.voiceClient,\n          channelList: this.state.selectedChannel === 'sms' ? this.state.chatChannelList : null,\n          incomingCall: this.state.incomingCall,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 481,\n            columnNumber: 13\n          }\n        })));\n      }\n    }\n  }]);\n\n  return Canvas;\n}(Component);\n\nexport { Canvas as default };\nvar ViewPort = styled.div(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n  width: 100%;\\n  height: 100%;\\n  display: flex;\\n  flex-direction: column;\\n  flex-wrap: nowrap;\\n  align-items: stretch;\\n  max-width: 400px;\\n\"])));","map":{"version":3,"sources":["/root/twilio-phone-client/src/components/PhoneClient.js"],"names":["React","Component","styled","update","jwt_decode","formParams","stringify","ChannelSwitcher","ChannelContent","AuthForm","ModalMessage","TwilioChat","require","TwilioVoice","maxAuthAttempts","Canvas","props","_fetchToken","Promise","resolve","reject","accessTokenGenerator","process","env","REACT_APP_RUNTIME_DOMAIN","body","secret","state","fetch","method","headers","then","response","status","text","errText","setState","authorized","authError","authCounter","console","error","token","undefined","catch","err","displayError","setSecret","initClients","setCallDisplay","callDisplay","setCallConnection","callConnection","getCallConnection","setCallStartTime","callStartTime","getCallStartTime","setCallNextKeyReset","callNextKeyReset","getCallNextKeyReset","setCallTypingPN","callTypingPN","getCallTypingPN","setUnreadsCache","contact","unread","msgUnreadsCache","$set","setUnreadMsgs","channel","lastConsumedMessageIndex","getMessagesCount","cnt","getUnconsumedMessagesCount","setMsgCachePage","messages","paginator","msgCache","pgtrCache","msgPgtrCache","addMsgCachePage","$unshift","addMsgCacheMsg","msg","$merge","$push","getToken","decoded_token","s_now","Math","floor","Date","now","s_expire","exp","log","getTokenActive","chatClient","voiceClient","Device","setup","codecPreferences","fakeLocalDTMF","enableRingingState","on","device","code","updateToken","connection","parameters","From","incomingCall","Client","create","getSubscribedChannels","chatChannelList","i","items","length","uniqueName","$unset","updateReasons","includes","setChannel","selectedChannel","localStorage","getItem","removeAllListeners","ViewPort","div"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport styled from 'styled-components';\nimport update from 'immutability-helper';\nimport jwt_decode from 'jwt-decode';\nimport { formParams, stringify } from '../lib/common';\n\nimport ChannelSwitcher from './ChannelSwitcher';\nimport ChannelContent from './ChannelContent';\nimport AuthForm from './AuthForm';\nimport { ModalMessage } from './CommonComponents';\n\nconst TwilioChat = require('twilio-chat');\nconst TwilioVoice = require('twilio-client');\n\nconst maxAuthAttempts = 3;\n\nexport default class Canvas extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      selectedChannel: 'sms',\n      chatClient: null,\n      chatChannelList: null,\n      voiceClient: null,\n      incomingCall: null,\n      token: null,\n      authorized: false,\n      authCounter: 0,\n      authError: '',\n      secret: localStorage.getItem('secret'),\n      displayError: null,\n      msgUnreadsCache: {},\n      msgCache: {},\n      msgPgtrCache: {},\n      callDisplay: '' // phone number after formatting\n    };\n\n    this.callConnection = null;\n    this.callStartTime = null;\n    this.callNextKeyReset = false;\n    // is user typing a phone number (i.e. no call in progress) or\n    // are they using DTMF during a call?\n    this.callTypingPN = true;\n  }\n\n  /**\n   * Fetch token from the <tt>getAccessToken</tt> function.\n   * @returns {string}\n   */\n  _fetchToken = () => {\n    return new Promise((resolve, reject) => {\n      const accessTokenGenerator =\n        (process.env.REACT_APP_RUNTIME_DOMAIN\n          ? process.env.REACT_APP_RUNTIME_DOMAIN\n          : '') + '/getAccessToken';\n\n      const body = formParams({\n        secret: this.state.secret // handle escaping\n      });\n      fetch(accessTokenGenerator, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body\n      })\n        .then(async (response) => {\n          if (response.status === 200) {\n            return response.text();\n          } else if (response.status === 401) {\n            const errText = await response.text();\n            this.setState({\n              authorized: false,\n              authError: this.state.authCounter === 0 ? '' : errText,\n              authCounter: this.state.authCounter + 1\n            });\n            console.error(\n              'Authorization failed - check if SECRET env variable is set correctly:',\n              errText\n            );\n            reject(errText);\n          }\n        })\n        .then((token) => {\n          if (token !== undefined) {\n            this.setState({\n              authorized: true,\n              authError: '',\n              authCounter: 0\n            });\n            resolve(token);\n          }\n        })\n        .catch((err) => {\n          console.error('Error fetching Access Token:', err);\n          this.setState({\n            displayError: `Error fetching Access Token (${stringify(err)})`\n          });\n          reject(err);\n        });\n    });\n  };\n\n  /**\n   * Setters & getters for properties that don't have to be part of the state,\n   * but need to be accessed by child components and need their values to\n   * survive unmounting of the consuming component\n   */\n\n  setSecret = (secret) => {\n    this.setState({ secret }, () => this.initClients());\n  };\n  setCallDisplay = (callDisplay) => {\n    this.setState({ callDisplay });\n  };\n  setCallConnection = (callConnection) => {\n    this.callConnection = callConnection;\n  };\n  getCallConnection = () => {\n    return this.callConnection;\n  };\n  setCallStartTime = (callStartTime) => {\n    this.callStartTime = callStartTime;\n  };\n  getCallStartTime = () => {\n    return this.callStartTime;\n  };\n  setCallNextKeyReset = (callNextKeyReset) => {\n    this.callNextKeyReset = callNextKeyReset;\n  };\n  getCallNextKeyReset = () => {\n    return this.callNextKeyReset;\n  };\n  setCallTypingPN = (callTypingPN) => {\n    this.callTypingPN = callTypingPN;\n  };\n  getCallTypingPN = () => {\n    return this.callTypingPN;\n  };\n\n  /**\n   * msgUnreadsCache setter\n   * @param {*} contact - the contact for which the cache should be updated\n   * @param {*} unread - new value\n   */\n  setUnreadsCache = (contact, unread) => {\n    this.setState({\n      msgUnreadsCache: update(this.state.msgUnreadsCache, {\n        [contact]: { $set: unread }\n      })\n    });\n  };\n\n  setUnreadMsgs = (channel, contact) => {\n    // if there's no consumed messages, all messages are unread\n    // (getUnconsumedMessagesCount doesn't really work in this case\n    // so we need to handle this edge case manually)\n    if (channel.lastConsumedMessageIndex === null) {\n      channel.getMessagesCount().then((cnt) => {\n        this.setState({\n          msgUnreadsCache: update(this.state.msgUnreadsCache, {\n            [contact]: { $set: cnt }\n          })\n        });\n      });\n    } else {\n      channel.getUnconsumedMessagesCount().then((cnt) => {\n        this.setState({\n          msgUnreadsCache: update(this.state.msgUnreadsCache, {\n            [contact]: { $set: cnt }\n          })\n        });\n      });\n    }\n  };\n\n  /**\n   * Initialize message cache for given contact\n   * @param {*} contact\n   * @param {*} messages\n   * @param {*} paginator\n   */\n  setMsgCachePage = (contact, messages, paginator) => {\n    this.setState({\n      msgCache: update(this.state.msgCache, {\n        [contact]: { $set: messages }\n      }),\n      pgtrCache: update(this.state.msgPgtrCache, {\n        [contact]: { $set: paginator }\n      })\n    });\n  };\n\n  /**\n   * Add new page worth of messages using paginator\n   * @param {*} contact\n   * @param {*} messages\n   * @param {*} paginator\n   */\n  addMsgCachePage = (contact, messages, paginator) => {\n    this.setState({\n      msgCache: update(this.state.msgCache, {\n        [contact]: { $unshift: messages }\n      }),\n      pgtrCache: update(this.state.msgPgtrCache, {\n        [contact]: { $set: paginator }\n      })\n    });\n  };\n\n  /**\n   * Add one new message to the cache\n   * @param {*} contact\n   * @param {*} msg\n   */\n  addMsgCacheMsg = (contact, msg) => {\n    if (this.state.msgCache[contact] === undefined) {\n      this.setState({\n        msgCache: update(this.state.msgCache, {\n          $merge: { [contact]: [] }\n        })\n      });\n    }\n    this.setState({\n      msgCache: update(this.state.msgCache, { [contact]: { $push: [msg] } })\n    });\n  };\n\n  /**\n   * Wrapper around _fetchToken that stores the token in component's state\n   * @returns {string}\n   */\n  getToken = () => {\n    return new Promise((resolve, reject) => {\n      if (this.state.token) {\n        const decoded_token = jwt_decode(this.state.token);\n        const s_now = Math.floor(Date.now() / 1000);\n        const s_expire = decoded_token.exp;\n        console.log(`Token is expiring in ${s_expire - s_now}s`);\n        if (s_expire - s_now < 300) {\n          // token is about to expire, let's renew it\n          this._fetchToken().then((token) => {\n            this.setState({ token });\n            this.getTokenActive = false;\n            resolve(token);\n          });\n        } else {\n          this.getTokenActive = false;\n          resolve(this.state.token);\n        }\n      } else {\n        this._fetchToken().then((token) => {\n          this.setState({ token });\n          this.getTokenActive = false;\n          resolve(token);\n        });\n      }\n    });\n  };\n\n  /**\n   * Initialize the Voice and Chat clients\n   * @returns {string}\n   */\n  initClients = () => {\n    if (this.state.chatClient === null && this.state.voiceClient === null) {\n      this.getToken().then((token) => {\n        // initialize Voice client\n        const voiceClient = new TwilioVoice.Device();\n        voiceClient.setup(token, {\n          // Set Opus as our preferred codec. Opus generally performs better,\n          // requiring less bandwidth and providing better audio quality in\n          // restrained network conditions. Opus will be default in 2.0.\n          codecPreferences: ['opus', 'pcmu'],\n          // Use fake DTMF tones client-side. Real tones are still sent to the\n          // other end of the call, but the client-side DTMF tones are fake.\n          // This prevents the local mic capturing the DTMF tone a second time\n          // and sending the tone twice. This will be default in 2.0.\n          fakeLocalDTMF: true,\n          // Use `enableRingingState` to enable the device to emit the `ringing`\n          // state. The TwiML backend also needs to have the attribute\n          // `answerOnBridge` also set to true in the `Dial` verb. This option\n          // changes the behavior of the SDK to consider a call `ringing`\n          // starting from the connection to the TwiML backend to when the\n          // recipient of the `Dial` verb answers.\n          enableRingingState: true\n        });\n        voiceClient.on('ready', (device) => {\n          console.log('voiceClient is ready');\n        });\n        voiceClient.on('error', (error) => {\n          console.log('Twilio.Device Error: ', error);\n          // JWT Token Expired\n          if (error.code === 31205) {\n            this.getToken().then(() => {\n              this.state.chatClient.updateToken(this.state.token);\n              this.state.voiceClient.updateToken(this.state.token);\n              console.log('Token updated after expiration (from voiceClient)');\n            });\n          }\n        });\n        voiceClient.on('incoming', (connection) => {\n          console.log(\n            'PC: INCOMING event fired from ' + connection.parameters.From\n          );\n          this.setState({ incomingCall: connection });\n          this.setCallConnection(connection);\n          connection.on('reject', (connection) => {\n            // when incoming call gets rejected from CallCanvas, update state\n            this.setState({\n              incomingCall: null\n            });\n          });\n        });\n        voiceClient.on('cancel', (connection) => {\n          console.log('PC: CANCEL event fired');\n          this.setState({\n            incomingCall: null\n          });\n        });\n\n        voiceClient.on('connect', (connection) => {\n          console.log('PC: CONNECT event fired');\n          this.setState({ incomingCall: null }); // cleanup the incoming call state and let the component handle this natively\n        });\n\n        voiceClient.on('disconnect', (connection) => {\n          console.log('PC: DISCONNECT event fired');\n          this.setCallDisplay('');\n          this.setCallStartTime(null);\n          this.setCallTypingPN(true);\n          this.setCallNextKeyReset(false);\n        });\n\n        console.log('voiceClient is initialized');\n        this.setState({ voiceClient });\n\n        // initialize Chat client\n        TwilioChat.Client.create(token).then((chatClient) => {\n          this.setState({ chatClient });\n          chatClient.getSubscribedChannels().then((paginator) => {\n            let chatChannelList = {};\n            for (let i = 0; i < paginator.items.length; i++) {\n              const channel = paginator.items[i];\n              chatChannelList[channel.uniqueName] = channel;\n            }\n            console.log('chatClient is initialized');\n\n            this.setState({ chatChannelList });\n          });\n          chatClient.on('channelRemoved', (channel) => {\n            if (this.state.chatChannelList !== null) {\n              this.setState({\n                chatChannelList: update(this.state.chatChannelList, {\n                  $unset: [channel.uniqueName]\n                }),\n                msgUnreadsCache: update(this.state.msgUnreadsCache, {\n                  $unset: [channel.uniqueName]\n                }),\n                msgCache: update(this.state.msgCache, {\n                  $unset: [channel.uniqueName]\n                }),\n                msgPgtrCache: update(this.state.msgPgtrCache, {\n                  $unset: [channel.uniqueName]\n                })\n              });\n            }\n          });\n          chatClient.on('channelAdded', (channel) => {\n            if (this.state.chatChannelList !== null) {\n              this.setState({\n                chatChannelList: update(this.state.chatChannelList, {\n                  $merge: { [channel.uniqueName]: channel }\n                }),\n                msgCache: update(this.state.msgCache, {\n                  [channel.uniqueName]: { $set: undefined }\n                })\n              });\n            }\n          });\n          chatClient.on('channelUpdated', ({ channel, updateReasons }) => {\n            if (\n              this.state.chatChannelList !== null &&\n              updateReasons.includes('lastMessage')\n            ) {\n              this.setState({\n                chatChannelList: update(this.state.chatChannelList, {\n                  [channel.uniqueName]: { $set: channel }\n                })\n              });\n            }\n          });\n          chatClient.on('tokenAboutToExpire', () => {\n            this.getToken().then(() => {\n              this.state.chatClient.updateToken(this.state.token);\n              this.state.voiceClient.updateToken(this.state.token);\n              console.log('Token updated before expiration');\n            });\n          });\n          chatClient.on('tokenExpired', () => {\n            this.getToken().then(() => {\n              this.state.chatClient.updateToken(this.state.token);\n              this.state.voiceClient.updateToken(this.state.token);\n              console.log('Token updated after expiration (from chatClient)');\n            });\n          });\n        });\n      });\n    }\n  };\n\n  setChannel = (selectedChannel) => {\n    this.setState({ selectedChannel });\n  };\n\n  componentDidMount() {\n    this.initClients();\n  }\n\n  componentDidUpdate() {}\n\n  componentWillUnmount() {\n    if (this.state.chatClient) {\n      this.state.chatClient.removeAllListeners('channelAdded');\n      this.state.chatClient.removeAllListeners('channelUpdated');\n    }\n    if (this.state.voiceClient) {\n      this.state.voiceClient.removeAllListeners('ready');\n      this.state.voiceClient.removeAllListeners('error');\n    }\n  }\n\n  render() {\n    if (this.state.displayError) {\n      return (\n        <ViewPort>\n          <ModalMessage\n            msg={'Error occurred: ' + this.state.displayError}\n            img=\"alert\"\n          />\n        </ViewPort>\n      );\n    } else if (\n      // if the initial login attempt hasn't bee made yet, don't show anything\n      // (to avoid UI redraws with login form flashing brieafly before client load)\n      this.state.authorized === false &&\n      this.state.authCounter === 0\n    ) {\n      return <ViewPort></ViewPort>;\n    } else if (\n      // if the initial login attempt failed, show a login form\n      this.state.authorized === false &&\n      this.state.authCounter <= maxAuthAttempts\n    ) {\n      return (\n        <ViewPort>\n          <AuthForm setSecret={this.setSecret} errMsg={this.state.authError} />\n        </ViewPort>\n      );\n    } else if (\n      // if the max number of attempts was exceeded, show error to discourage\n      // repeated logins\n      this.state.authorized === false &&\n      this.state.authCounter > maxAuthAttempts\n    ) {\n      return (\n        <ViewPort>\n          <ModalMessage msg=\"Authorization failed\" img=\"auth_fail\" />\n        </ViewPort>\n      );\n    } else {\n      return (\n        <React.StrictMode>\n          <ViewPort>\n            <ChannelSwitcher\n              setChannel={this.setChannel}\n              selectedChannel={this.state.selectedChannel}\n              incomingCall={this.state.incomingCall}\n              msgUnreadsCache={this.state.msgUnreadsCache}\n            />\n            <ChannelContent\n              msgUnreadsCache={this.state.msgUnreadsCache}\n              setUnreadsCache={this.setUnreadsCache}\n              setUnreadMsgs={this.setUnreadMsgs}\n              msgCache={this.state.msgCache}\n              msgPgtrCache={this.state.msgPgtrCache}\n              addMsgCachePage={this.addMsgCachePage}\n              setMsgCachePage={this.setMsgCachePage}\n              addMsgCacheMsg={this.addMsgCacheMsg}\n              setCallDisplay={this.setCallDisplay}\n              callDisplay={this.state.callDisplay}\n              setCallConnection={this.setCallConnection}\n              getCallConnection={this.getCallConnection}\n              setCallStartTime={this.setCallStartTime}\n              getCallStartTime={this.getCallStartTime}\n              setCallNextKeyReset={this.setCallNextKeyReset}\n              getCallNextKeyReset={this.getCallNextKeyReset}\n              setCallTypingPN={this.setCallTypingPN}\n              getCallTypingPN={this.getCallTypingPN}\n              selectedChannel={this.state.selectedChannel}\n              secret={this.state.secret}\n              client={\n                this.state.selectedChannel === 'sms'\n                  ? this.state.chatClient\n                  : this.state.voiceClient\n              }\n              channelList={\n                this.state.selectedChannel === 'sms'\n                  ? this.state.chatChannelList\n                  : null\n              }\n              incomingCall={this.state.incomingCall}\n            />\n          </ViewPort>\n        </React.StrictMode>\n      );\n    }\n  }\n}\n\nconst ViewPort = styled.div`\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  align-items: stretch;\n  max-width: 400px;\n`;\n"]},"metadata":{},"sourceType":"module"}