{"ast":null,"code":"var __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n/* eslint-disable no-fallthrough */\n\n\nvar _a = require('../errors'),\n    NotSupportedError = _a.NotSupportedError,\n    InvalidArgumentError = _a.InvalidArgumentError;\n\nvar MockRTCStatsReport = require('./mockrtcstatsreport');\n\nvar ERROR_PEER_CONNECTION_NULL = 'PeerConnection is null';\nvar ERROR_WEB_RTC_UNSUPPORTED = 'WebRTC statistics are unsupported';\n/**\n * Generate WebRTC statistics report for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @return {Promise<RTCStatsReport>} WebRTC RTCStatsReport object\n */\n\nfunction getRTCStatsReport(peerConnection) {\n  if (!peerConnection) {\n    return Promise.reject(new InvalidArgumentError(ERROR_PEER_CONNECTION_NULL));\n  }\n\n  if (typeof peerConnection.getStats !== 'function') {\n    return Promise.reject(new NotSupportedError(ERROR_WEB_RTC_UNSUPPORTED));\n  }\n\n  var promise;\n\n  try {\n    promise = peerConnection.getStats();\n  } catch (e) {\n    promise = new Promise(function (resolve) {\n      return peerConnection.getStats(resolve);\n    }).then(MockRTCStatsReport.fromRTCStatsResponse);\n  }\n\n  return promise;\n}\n/**\n * @typedef {Object} StatsOptions\n * Used for testing to inject and extract methods.\n * @property {function} [createRTCSample] - Method for parsing an RTCStatsReport\n */\n\n/**\n * Collects any WebRTC statistics for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @param {StatsOptions} options - List of custom options.\n * @return {Promise<RTCSample>} Universally-formatted version of RTC stats.\n */\n\n\nfunction getRTCStats(peerConnection, options) {\n  options = Object.assign({\n    createRTCSample: createRTCSample\n  }, options);\n  return getRTCStatsReport(peerConnection).then(options.createRTCSample);\n}\n/**\n * Generate WebRTC stats report containing relevant information about ICE candidates for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @return {Promise<RTCIceCandidateStatsReport>} RTCIceCandidateStatsReport object\n */\n\n\nfunction getRTCIceCandidateStatsReport(peerConnection) {\n  return getRTCStatsReport(peerConnection).then(function (report) {\n    // Find the relevant information needed to determine selected candidates later\n    var _a = Array.from(report.values()).reduce(function (rval, stat) {\n      ['candidatePairs', 'localCandidates', 'remoteCandidates'].forEach(function (prop) {\n        if (!rval[prop]) {\n          rval[prop] = [];\n        }\n      });\n\n      switch (stat.type) {\n        case 'candidate-pair':\n          rval.candidatePairs.push(stat);\n          break;\n\n        case 'local-candidate':\n          rval.localCandidates.push(stat);\n          break;\n\n        case 'remote-candidate':\n          rval.remoteCandidates.push(stat);\n          break;\n\n        case 'transport':\n          // This transport is the one being used if selectedCandidatePairId is populated\n          if (stat.selectedCandidatePairId) {\n            rval.transport = stat;\n          }\n\n          break;\n      }\n\n      return rval;\n    }, {}),\n        candidatePairs = _a.candidatePairs,\n        localCandidates = _a.localCandidates,\n        remoteCandidates = _a.remoteCandidates,\n        transport = _a.transport; // This is a report containing information about the selected candidates, such as IDs\n    // This is coming from WebRTC stats directly and doesn't contain the actual ICE Candidates info\n\n\n    var selectedCandidatePairReport = candidatePairs.find(function (pair) {\n      // Firefox\n      return pair.selected || // Spec-compliant way\n      transport && pair.id === transport.selectedCandidatePairId;\n    });\n    var selectedIceCandidatePairStats;\n\n    if (selectedCandidatePairReport) {\n      selectedIceCandidatePairStats = {\n        localCandidate: localCandidates.find(function (candidate) {\n          return candidate.id === selectedCandidatePairReport.localCandidateId;\n        }),\n        remoteCandidate: remoteCandidates.find(function (candidate) {\n          return candidate.id === selectedCandidatePairReport.remoteCandidateId;\n        })\n      };\n    } // Build the return object\n\n\n    return {\n      iceCandidateStats: __spreadArrays(localCandidates, remoteCandidates),\n      selectedIceCandidatePairStats: selectedIceCandidatePairStats\n    };\n  });\n}\n/**\n * @typedef {Object} RTCSample - A sample containing relevant WebRTC stats information.\n * @property {Number} [timestamp]\n * @property {String} [codecName] - MimeType name of the codec being used by the outbound audio stream\n * @property {Number} [rtt] - Round trip time\n * @property {Number} [jitter]\n * @property {Number} [packetsSent]\n * @property {Number} [packetsLost]\n * @property {Number} [packetsReceived]\n * @property {Number} [bytesReceived]\n * @property {Number} [bytesSent]\n * @property {Number} [localAddress]\n * @property {Number} [remoteAddress]\n */\n\n\nfunction RTCSample() {}\n/**\n * Create an RTCSample object from an RTCStatsReport\n * @private\n * @param {RTCStatsReport} statsReport\n * @returns {RTCSample}\n */\n\n\nfunction createRTCSample(statsReport) {\n  var activeTransportId = null;\n  var sample = new RTCSample();\n  var fallbackTimestamp;\n  Array.from(statsReport.values()).forEach(function (stats) {\n    // Skip isRemote tracks which will be phased out completely and break in FF66.\n    if (stats.isRemote) {\n      return;\n    } // Firefox hack -- Older firefox doesn't have dashes in type names\n\n\n    var type = stats.type.replace('-', '');\n    fallbackTimestamp = fallbackTimestamp || stats.timestamp; // (rrowland) As I understand it, this is supposed to come in on remote-inbound-rtp but it's\n    // currently coming in on remote-outbound-rtp, so I'm leaving this outside the switch until\n    // the appropriate place to look is cleared up.\n\n    if (stats.remoteId) {\n      var remote = statsReport.get(stats.remoteId);\n\n      if (remote && remote.roundTripTime) {\n        sample.rtt = remote.roundTripTime * 1000;\n      }\n    }\n\n    switch (type) {\n      case 'inboundrtp':\n        sample.timestamp = sample.timestamp || stats.timestamp;\n        sample.jitter = stats.jitter * 1000;\n        sample.packetsLost = stats.packetsLost;\n        sample.packetsReceived = stats.packetsReceived;\n        sample.bytesReceived = stats.bytesReceived;\n        break;\n\n      case 'outboundrtp':\n        sample.timestamp = stats.timestamp;\n        sample.packetsSent = stats.packetsSent;\n        sample.bytesSent = stats.bytesSent;\n\n        if (stats.codecId) {\n          var codec = statsReport.get(stats.codecId);\n          sample.codecName = codec ? codec.mimeType && codec.mimeType.match(/(.*\\/)?(.*)/)[2] : stats.codecId;\n        }\n\n        break;\n\n      case 'transport':\n        activeTransportId = stats.id;\n        break;\n    }\n  });\n\n  if (!sample.timestamp) {\n    sample.timestamp = fallbackTimestamp;\n  }\n\n  var activeTransport = statsReport.get(activeTransportId);\n\n  if (!activeTransport) {\n    return sample;\n  }\n\n  var selectedCandidatePair = statsReport.get(activeTransport.selectedCandidatePairId);\n\n  if (!selectedCandidatePair) {\n    return sample;\n  }\n\n  var localCandidate = statsReport.get(selectedCandidatePair.localCandidateId);\n  var remoteCandidate = statsReport.get(selectedCandidatePair.remoteCandidateId);\n\n  if (!sample.rtt) {\n    sample.rtt = selectedCandidatePair && selectedCandidatePair.currentRoundTripTime * 1000;\n  }\n\n  Object.assign(sample, {\n    localAddress: localCandidate && localCandidate.ip,\n    remoteAddress: remoteCandidate && remoteCandidate.ip\n  });\n  return sample;\n}\n\nmodule.exports = {\n  getRTCStats: getRTCStats,\n  getRTCIceCandidateStatsReport: getRTCIceCandidateStatsReport\n};","map":{"version":3,"sources":["../../../lib/twilio/rtc/stats.js"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable no-fallthrough */\nconst { NotSupportedError, InvalidArgumentError } = require('../errors');\nconst MockRTCStatsReport = require('./mockrtcstatsreport');\n\nconst ERROR_PEER_CONNECTION_NULL = 'PeerConnection is null';\nconst ERROR_WEB_RTC_UNSUPPORTED = 'WebRTC statistics are unsupported';\n\n/**\n * Generate WebRTC statistics report for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @return {Promise<RTCStatsReport>} WebRTC RTCStatsReport object\n */\nfunction getRTCStatsReport(peerConnection) {\n  if (!peerConnection) {\n    return Promise.reject(new InvalidArgumentError(ERROR_PEER_CONNECTION_NULL));\n  }\n\n  if (typeof peerConnection.getStats !== 'function') {\n    return Promise.reject(new NotSupportedError(ERROR_WEB_RTC_UNSUPPORTED));\n  }\n\n  let promise;\n  try {\n    promise = peerConnection.getStats();\n  } catch (e) {\n    promise = new Promise(resolve => peerConnection.getStats(resolve)).then(MockRTCStatsReport.fromRTCStatsResponse);\n  }\n\n  return promise;\n}\n\n/**\n * @typedef {Object} StatsOptions\n * Used for testing to inject and extract methods.\n * @property {function} [createRTCSample] - Method for parsing an RTCStatsReport\n */\n/**\n * Collects any WebRTC statistics for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @param {StatsOptions} options - List of custom options.\n * @return {Promise<RTCSample>} Universally-formatted version of RTC stats.\n */\nfunction getRTCStats(peerConnection, options) {\n  options = Object.assign({\n    createRTCSample\n  }, options);\n\n  return getRTCStatsReport(peerConnection).then(options.createRTCSample);\n}\n\n/**\n * Generate WebRTC stats report containing relevant information about ICE candidates for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @return {Promise<RTCIceCandidateStatsReport>} RTCIceCandidateStatsReport object\n */\nfunction getRTCIceCandidateStatsReport(peerConnection) {\n  return getRTCStatsReport(peerConnection).then((report) => {\n    // Find the relevant information needed to determine selected candidates later\n    const {\n      candidatePairs, localCandidates, remoteCandidates, transport,\n    } = Array.from(report.values()).reduce((rval, stat) => {\n      ['candidatePairs', 'localCandidates', 'remoteCandidates'].forEach((prop) => {\n        if (!rval[prop]) {\n          rval[prop] = [];\n        }\n      });\n\n      switch (stat.type) {\n        case 'candidate-pair':\n          rval.candidatePairs.push(stat);\n          break;\n        case 'local-candidate':\n          rval.localCandidates.push(stat);\n          break;\n        case 'remote-candidate':\n          rval.remoteCandidates.push(stat);\n          break;\n        case 'transport':\n          // This transport is the one being used if selectedCandidatePairId is populated\n          if (stat.selectedCandidatePairId) {\n            rval.transport = stat;\n          }\n          break;\n      }\n\n      return rval;\n    }, {});\n\n    // This is a report containing information about the selected candidates, such as IDs\n    // This is coming from WebRTC stats directly and doesn't contain the actual ICE Candidates info\n    const selectedCandidatePairReport = candidatePairs.find(pair =>\n      // Firefox\n      pair.selected ||\n      // Spec-compliant way\n      (transport && pair.id === transport.selectedCandidatePairId)\n    );\n\n    let selectedIceCandidatePairStats;\n    if (selectedCandidatePairReport) {\n      selectedIceCandidatePairStats = {\n        localCandidate: localCandidates.find(candidate => candidate.id === selectedCandidatePairReport.localCandidateId),\n        remoteCandidate: remoteCandidates.find(candidate => candidate.id === selectedCandidatePairReport.remoteCandidateId),\n      };\n    }\n\n    // Build the return object\n    return {\n      iceCandidateStats: [...localCandidates, ...remoteCandidates],\n      selectedIceCandidatePairStats,\n    };\n  });\n}\n\n/**\n * @typedef {Object} RTCSample - A sample containing relevant WebRTC stats information.\n * @property {Number} [timestamp]\n * @property {String} [codecName] - MimeType name of the codec being used by the outbound audio stream\n * @property {Number} [rtt] - Round trip time\n * @property {Number} [jitter]\n * @property {Number} [packetsSent]\n * @property {Number} [packetsLost]\n * @property {Number} [packetsReceived]\n * @property {Number} [bytesReceived]\n * @property {Number} [bytesSent]\n * @property {Number} [localAddress]\n * @property {Number} [remoteAddress]\n */\nfunction RTCSample() { }\n\n/**\n * Create an RTCSample object from an RTCStatsReport\n * @private\n * @param {RTCStatsReport} statsReport\n * @returns {RTCSample}\n */\nfunction createRTCSample(statsReport) {\n  let activeTransportId = null;\n  const sample = new RTCSample();\n  let fallbackTimestamp;\n\n  Array.from(statsReport.values()).forEach(stats => {\n    // Skip isRemote tracks which will be phased out completely and break in FF66.\n    if (stats.isRemote) { return; }\n\n    // Firefox hack -- Older firefox doesn't have dashes in type names\n    const type = stats.type.replace('-', '');\n\n    fallbackTimestamp = fallbackTimestamp || stats.timestamp;\n\n    // (rrowland) As I understand it, this is supposed to come in on remote-inbound-rtp but it's\n    // currently coming in on remote-outbound-rtp, so I'm leaving this outside the switch until\n    // the appropriate place to look is cleared up.\n    if (stats.remoteId) {\n      const remote = statsReport.get(stats.remoteId);\n      if (remote && remote.roundTripTime) {\n        sample.rtt = remote.roundTripTime * 1000;\n      }\n    }\n\n    switch (type) {\n      case 'inboundrtp':\n        sample.timestamp = sample.timestamp || stats.timestamp;\n        sample.jitter = stats.jitter * 1000;\n        sample.packetsLost = stats.packetsLost;\n        sample.packetsReceived = stats.packetsReceived;\n        sample.bytesReceived = stats.bytesReceived;\n\n        break;\n      case 'outboundrtp':\n        sample.timestamp = stats.timestamp;\n        sample.packetsSent = stats.packetsSent;\n        sample.bytesSent = stats.bytesSent;\n\n        if (stats.codecId) {\n          const codec = statsReport.get(stats.codecId);\n          sample.codecName = codec\n            ? codec.mimeType && codec.mimeType.match(/(.*\\/)?(.*)/)[2]\n            : stats.codecId;\n        }\n\n        break;\n      case 'transport':\n        activeTransportId = stats.id;\n        break;\n    }\n  });\n\n  if (!sample.timestamp) {\n    sample.timestamp = fallbackTimestamp;\n  }\n\n  const activeTransport = statsReport.get(activeTransportId);\n  if (!activeTransport) { return sample; }\n\n  const selectedCandidatePair = statsReport.get(activeTransport.selectedCandidatePairId);\n  if (!selectedCandidatePair) { return sample; }\n\n  const localCandidate = statsReport.get(selectedCandidatePair.localCandidateId);\n  const remoteCandidate = statsReport.get(selectedCandidatePair.remoteCandidateId);\n\n  if (!sample.rtt) {\n    sample.rtt = selectedCandidatePair &&\n      (selectedCandidatePair.currentRoundTripTime * 1000);\n  }\n\n  Object.assign(sample, {\n    localAddress: localCandidate && localCandidate.ip,\n    remoteAddress: remoteCandidate && remoteCandidate.ip,\n  });\n\n  return sample;\n}\n\nmodule.exports = {\n  getRTCStats,\n  getRTCIceCandidateStatsReport,\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}